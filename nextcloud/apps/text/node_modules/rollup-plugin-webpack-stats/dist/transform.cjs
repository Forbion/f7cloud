'use strict';

var path = require('path');
var crypto = require('crypto');

const HASH_LENGTH = 7;
/**
 * Get content byte size
 */
function getByteSize(content) {
    if (typeof content === 'string') {
        return Buffer.from(content).length;
    }
    return content?.length || 0;
}
/**
 * Generate a 7 chars hash from a filepath
 */
function getHash(filepath) {
    const digest = crypto.createHash('sha256');
    return digest.update(Buffer.from(filepath)).digest('hex').substr(0, HASH_LENGTH);
}
function getChunkId(chunk) {
    let value = chunk.name;
    // Use entry module relative path
    if (chunk.moduleIds?.length > 0) {
        const absoluteModulePath = chunk.moduleIds[chunk.moduleIds.length - 1];
        value = path.relative(process.cwd(), absoluteModulePath);
    }
    return getHash([chunk, value].join('-'));
}
/**
 * Check if filepath should be excluded based on a config
 */
function checkExcludeFilepath(filepath, option) {
    if (!option) {
        return false;
    }
    if (Array.isArray(option)) {
        let res = false;
        for (let i = 0; i <= option.length - 1 && res === false; i++) {
            res = checkExcludeFilepath(filepath, option[i]);
        }
        return res;
    }
    if (typeof option === 'function') {
        return option(filepath);
    }
    if (typeof option === 'string') {
        return Boolean(filepath.match(option));
    }
    if ('test' in option) {
        return option.test(filepath);
    }
    return false;
}

/**
 * Store transformed sources
 */
class TransformSources {
    constructor() {
        this.entries = {};
    }
    entries = {};
    push(id, source) {
        this.entries[id] = source;
    }
    /**
     * Get asset source
     */
    getByAsset = (asset) => {
        return this.entries[asset.name];
    };
    /**
     * Get chunk source
     */
    getByChunk = (chunk) => {
        return this.entries[chunk.id];
    };
    /**
     * Get module source
     */
    getByModule = (module) => {
        return this.entries[module.name];
    };
}
const defaultTransform = (stats) => stats;
const bundleToWebpackStats = (bundle, pluginOptions) => {
    const options = { moduleOriginalSize: false, ...pluginOptions };
    const { excludeAssets, excludeModules, moduleOriginalSize, transform = defaultTransform } = options;
    const assets = [];
    const chunks = [];
    const moduleByFileName = {};
    const sources = new TransformSources();
    const entries = Object.values(bundle);
    entries.forEach((entry) => {
        if (entry.type === 'chunk') {
            if (checkExcludeFilepath(entry.fileName, excludeAssets)) {
                return;
            }
            assets.push({
                name: entry.fileName,
                size: getByteSize(entry.code),
            });
            sources.push(entry.fileName, entry);
            const chunkId = getChunkId(entry);
            chunks.push({
                id: chunkId,
                entry: entry.isEntry,
                initial: !entry.isDynamicEntry,
                files: [entry.fileName],
                names: [entry.name],
            });
            sources.push(chunkId, entry);
            Object.entries(entry.modules).forEach(([modulePath, moduleInfo]) => {
                if (checkExcludeFilepath(modulePath, excludeModules)) {
                    return;
                }
                // Remove unexpected rollup null prefix
                const normalizedModulePath = modulePath.replace('\u0000', '');
                const relativeModulePath = path.relative(process.cwd(), normalizedModulePath);
                // Match webpack output - add current directory prefix for child modules
                const relativeModulePathWithPrefix = relativeModulePath.match(/^\.\./)
                    ? relativeModulePath
                    : `.${path.sep}${relativeModulePath}`;
                const moduleEntry = moduleByFileName[relativeModulePathWithPrefix];
                if (moduleEntry) {
                    moduleEntry.chunks.push(chunkId);
                }
                else {
                    moduleByFileName[relativeModulePathWithPrefix] = {
                        name: relativeModulePathWithPrefix,
                        size: moduleOriginalSize
                            ? moduleInfo.originalLength
                            : moduleInfo.renderedLength,
                        chunks: [chunkId],
                    };
                    sources.push(relativeModulePathWithPrefix, { fileName: modulePath, ...moduleInfo });
                }
            });
        }
        else if (entry.type === 'asset') {
            if (checkExcludeFilepath(entry.fileName, excludeAssets)) {
                return;
            }
            assets.push({
                name: entry.fileName,
                size: getByteSize(entry.source.toString()),
            });
            sources.push(entry.fileName, entry);
        }
        else ;
    });
    const stats = {
        builtAt: Date.now(),
        assets,
        chunks,
        modules: Object.values(moduleByFileName),
    };
    let result;
    try {
        result = transform(stats, sources, bundle);
    }
    catch (error) {
        console.error('Custom transform failed! Returning stats without any transforms.', error);
        result = stats;
    }
    return result;
};

exports.bundleToWebpackStats = bundleToWebpackStats;
//# sourceMappingURL=transform.cjs.map
