'use strict';

var Docker = require('dockerode');
var waitOn = require('wait-on');
var stream = require('stream');
var path = require('path');
var fs = require('fs');
var fastXmlParser = require('fast-xml-parser');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/* eslint-disable no-console */
/**
 * @copyright Copyright (c) 2022 John Molakvo√¶ <skjnldsv@protonmail.com>
 *
 * @author John Molakvo√¶ <skjnldsv@protonmail.com>
 *
 * @license AGPL-3.0-or-later
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 */
const SERVER_IMAGE = 'ghcr.io/nextcloud/continuous-integration-shallow-server';
const VENDOR_APPS = {
    text: 'https://github.com/nextcloud/text.git',
    viewer: 'https://github.com/nextcloud/viewer.git',
    notifications: 'https://github.com/nextcloud/notifications.git',
    activity: 'https://github.com/nextcloud/activity.git',
};
const docker = new Docker();
// Store the container name, different names are used to prevent conflicts when testing multiple apps locally
let _containerName = null;
// Store latest server branch used, will be used for vendored apps
let _serverBranch = 'master';
/**
 * Get the container name that is currently created and/or used by dockerode
 */
const getContainerName = function () {
    if (_containerName === null) {
        const app = path.basename(process.cwd()).replace(' ', '');
        _containerName = `nextcloud-cypress-tests_${app}`;
    }
    return _containerName;
};
/**
 * Get the current container used
 * Throws if not found
 */
const getContainer = function () {
    return docker.getContainer(getContainerName());
};
/**
 * Start the testing container
 *
 * @param {string|undefined} branch server branch to use (default 'master')
 * @param {boolean|string|undefined} mountApp bind mount app within server (`true` for autodetect, `false` to disable, or a string to force a path) (default true)
 * @param {StartOptions|undefined} options Optional parameters to configre the container creation
 * @return Promise resolving to the IP address of the server
 * @throws {Error} If Nextcloud container could not be started
 */
function startNextcloud() {
    return __awaiter(this, arguments, void 0, function* (branch = 'master', mountApp = true, options = {}) {
        var _a;
        let appPath = mountApp === true ? process.cwd() : mountApp;
        let appId;
        let appVersion;
        if (appPath) {
            console.log('Mounting app directory');
            while (appPath) {
                const appInfoPath = path.resolve(path.join(appPath, 'appinfo', 'info.xml'));
                if (fs.existsSync(appInfoPath)) {
                    const parser = new fastXmlParser.XMLParser();
                    const xmlDoc = parser.parse(fs.readFileSync(appInfoPath));
                    appId = xmlDoc.info.id;
                    appVersion = xmlDoc.info.version;
                    console.log(`‚îî‚îÄ Found ${appId} version ${appVersion}`);
                    break;
                }
                else {
                    // skip if root is reached or manual directory was set
                    if (appPath === path.sep || typeof mountApp === 'string') {
                        console.log('‚îî‚îÄ No appinfo found');
                        appPath = false;
                        break;
                    }
                    appPath = path.join(appPath, '..');
                }
            }
        }
        try {
            // Pulling images
            console.log('Pulling images‚Ä¶ ‚è≥');
            yield new Promise((resolve, reject) => docker.pull(SERVER_IMAGE, (_err, stream) => {
                const onFinished = function (err) {
                    if (!err) {
                        return resolve(true);
                    }
                    reject(err);
                };
                // https://github.com/apocas/dockerode/issues/357
                docker.modem.followProgress(stream, onFinished);
            }));
            console.log('‚îî‚îÄ Done');
            // Getting latest image
            console.log('\nChecking running containers‚Ä¶ üîç');
            const localImage = yield docker.listImages({ filters: `{"reference": ["${SERVER_IMAGE}"]}` });
            // Remove old container if exists and not initialized by us
            try {
                const oldContainer = getContainer();
                const oldContainerData = yield oldContainer.inspect();
                if (oldContainerData.State.Running) {
                    console.log('‚îú‚îÄ Existing running container found');
                    if (options.forceRecreate === true) {
                        console.log('‚îî‚îÄ Forced recreation of container was enabled, removing‚Ä¶');
                    }
                    else if (localImage[0].Id !== oldContainerData.Image) {
                        console.log('‚îî‚îÄ But running container is outdated, replacing‚Ä¶');
                    }
                    else {
                        // Get container's IP
                        console.log('‚îú‚îÄ Reusing that container');
                        const ip = yield getContainerIP(oldContainer);
                        return ip;
                    }
                }
                else {
                    console.log('‚îî‚îÄ None found!');
                }
                // Forcing any remnants to be removed just in case
                yield oldContainer.remove({ force: true });
            }
            catch (error) {
                console.log('‚îî‚îÄ None found!');
            }
            // Starting container
            console.log('\nStarting Nextcloud container‚Ä¶ üöÄ');
            console.log(`‚îú‚îÄ Using branch '${branch}'`);
            const mounts = [];
            if (appPath !== false) {
                mounts.push(`${appPath}:/var/www/html/apps/${appId}:ro`);
            }
            Object.entries((_a = options.mounts) !== null && _a !== void 0 ? _a : {})
                .forEach(([server, local]) => mounts.push(`${local}:/var/www/html/${server}:ro`));
            const PortBindings = !options.exposePort ? undefined : {
                '80/tcp': [{
                        HostIP: '0.0.0.0',
                        HostPort: options.exposePort.toString(),
                    }],
            };
            const container = yield docker.createContainer({
                Image: SERVER_IMAGE,
                name: getContainerName(),
                Env: [`BRANCH=${branch}`],
                HostConfig: {
                    Binds: mounts.length > 0 ? mounts : undefined,
                    PortBindings,
                },
            });
            yield container.start();
            // Get container's IP
            const ip = yield getContainerIP(container);
            console.log(`‚îú‚îÄ Nextcloud container's IP is ${ip} üåè`);
            _serverBranch = branch;
            return ip;
        }
        catch (err) {
            console.log('‚îî‚îÄ Unable to start the container üõë');
            console.log(err);
            stopNextcloud();
            throw new Error('Unable to start the container');
        }
    });
}
/**
 * Configure Nextcloud
 *
 * @param {string[]} apps List of default apps to install (default is ['viewer'])
 * @param {string|undefined} vendoredBranch The branch used for vendored apps, should match server (defaults to latest branch used for `startNextcloud` or fallsback to `master`)
 * @param {Container|undefined} container Optional server container to use (defaults to current container)
 */
const configureNextcloud = function () {
    return __awaiter(this, arguments, void 0, function* (apps = ['viewer'], vendoredBranch, container) {
        vendoredBranch = vendoredBranch || _serverBranch;
        console.log('\nConfiguring Nextcloud‚Ä¶');
        container = container !== null && container !== void 0 ? container : getContainer();
        yield runExec(container, ['php', 'occ', '--version'], true);
        // Be consistent for screenshots
        yield runExec(container, ['php', 'occ', 'config:system:set', 'default_language', '--value', 'en'], true);
        yield runExec(container, ['php', 'occ', 'config:system:set', 'force_language', '--value', 'en'], true);
        yield runExec(container, ['php', 'occ', 'config:system:set', 'default_locale', '--value', 'en_US'], true);
        yield runExec(container, ['php', 'occ', 'config:system:set', 'force_locale', '--value', 'en_US'], true);
        yield runExec(container, ['php', 'occ', 'config:system:set', 'enforce_theme', '--value', 'light'], true);
        // Build app list
        const json = yield runExec(container, ['php', 'occ', 'app:list', '--output', 'json'], false);
        // fix dockerode bug returning invalid leading characters
        const applist = JSON.parse(json.substring(json.indexOf('{')));
        // Enable apps and give status
        for (const app of apps) {
            if (app in applist.enabled) {
                console.log(`‚îú‚îÄ ${app} version ${applist.enabled[app]} already installed and enabled`);
            }
            else if (app in applist.disabled) {
                // built in or mounted already as the app under development
                yield runExec(container, ['php', 'occ', 'app:enable', '--force', app], true);
            }
            else if (app in VENDOR_APPS) {
                // apps that are vendored but still missing (i.e. not build in or mounted already)
                yield runExec(container, ['git', 'clone', '--depth=1', `--branch=${vendoredBranch}`, VENDOR_APPS[app], `apps/${app}`], true);
                yield runExec(container, ['php', 'occ', 'app:enable', '--force', app], true);
            }
            else {
                // try appstore
                yield runExec(container, ['php', 'occ', 'app:install', '--force', app], true);
            }
        }
        // await runExec(container, ['php', 'occ', 'app:list'], true)
        console.log('‚îî‚îÄ Nextcloud is now ready to use üéâ');
    });
};
/**
 * Force stop the testing container
 */
const stopNextcloud = function () {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const container = getContainer();
            console.log('Stopping Nextcloud container‚Ä¶');
            container.remove({ force: true });
            console.log('‚îî‚îÄ Nextcloud container removed ü•Ä');
        }
        catch (err) {
            console.log(err);
        }
    });
};
/**
 * Get the testing container's IP
 *
 * @param container name of the container
 */
const getContainerIP = function () {
    return __awaiter(this, arguments, void 0, function* (container = getContainer()) {
        let ip = '';
        let tries = 0;
        while (ip === '' && tries < 10) {
            tries++;
            yield container.inspect((_err, data) => {
                var _a;
                ip = ((_a = data === null || data === void 0 ? void 0 : data.NetworkSettings) === null || _a === void 0 ? void 0 : _a.IPAddress) || '';
            });
            if (ip !== '') {
                break;
            }
            yield sleep(1000 * tries);
        }
        return ip;
    });
};
// Would be simpler to start the container from cypress.config.ts,
// but when checking out different branches, it can take a few seconds
// Until we can properly configure the baseUrl retry intervals,
// We need to make sure the server is already running before cypress
// https://github.com/cypress-io/cypress/issues/22676
const waitOnNextcloud = function (ip) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('‚îú‚îÄ Waiting for Nextcloud to be ready‚Ä¶ ‚è≥');
        yield waitOn({ resources: [`http://${ip}/index.php`] });
        console.log('‚îî‚îÄ Done');
    });
};
const runExec = function (container_1, command_1) {
    return __awaiter(this, arguments, void 0, function* (container, command, verbose = false, user = 'www-data') {
        const exec = yield container.exec({
            Cmd: command,
            AttachStdout: true,
            AttachStderr: true,
            User: user,
        });
        return new Promise((resolve, reject) => {
            const dataStream = new stream.PassThrough();
            exec.start({}, (err, stream) => {
                if (stream) {
                    // Pass stdout and stderr to dataStream
                    exec.modem.demuxStream(stream, dataStream, dataStream);
                    stream.on('end', () => dataStream.end());
                }
                else {
                    reject(err);
                }
            });
            const data = [];
            dataStream.on('data', (chunk) => {
                var _a;
                data.push(chunk.toString('utf8'));
                const printable = (_a = data.at(-1)) === null || _a === void 0 ? void 0 : _a.trim();
                if (verbose && printable) {
                    console.log(`‚îú‚îÄ ${printable.replace(/\n/gi, '\n‚îú‚îÄ ')}`);
                }
            });
            dataStream.on('error', (err) => reject(err));
            dataStream.on('end', () => resolve(data.join('')));
        });
    });
};
const sleep = function (milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
};

exports.configureNextcloud = configureNextcloud;
exports.docker = docker;
exports.getContainer = getContainer;
exports.getContainerIP = getContainerIP;
exports.getContainerName = getContainerName;
exports.startNextcloud = startNextcloud;
exports.stopNextcloud = stopNextcloud;
exports.waitOnNextcloud = waitOnNextcloud;
