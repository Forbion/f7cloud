'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var parseUrl = _interopDefault(require('url-parse'));

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function renderMention(tokens, idx) {
  return '<span class="mention" data-type="' + tokens[idx].mention.type + '" data-id="' + tokens[idx].mention.id + '">' + tokens[idx].mention.label + '</span>';
}

function parseUri(uri) {
  var pieces = parseUrl(uri);

  return {
    type: pieces.host,
    id: pieces.pathname.slice(1)
  };
}

function parseMentions(state) {
  var matcher = /@$/;

  state.tokens.forEach(function (blockToken) {
    if (blockToken.type !== 'inline') return;

    var children = blockToken.children;


    children.forEach(function (token, idx) {
      // Back out if we're near the end of the token array
      if (idx + 3 > children.length) return;

      // Grab the next four tokens that could potentially construct a mention

      var _children$slice = children.slice(idx, idx + 4),
          _children$slice2 = _slicedToArray(_children$slice, 4),
          matchToken = _children$slice2[0],
          openToken = _children$slice2[1],
          textToken = _children$slice2[2],
          _children$slice2$ = _children$slice2[3],
          closeToken = _children$slice2$ === undefined ? {} : _children$slice2$;

      // Compensate for when the link has no label


      if (textToken.type === 'link_close') {
        closeToken = textToken;
        textToken = null;
      }

      // Back out if we're not dealing with a mention
      if (matchToken.type !== 'text') return;
      if (!matcher.test(matchToken.content)) return;
      if (openToken.type !== 'link_open') return;
      if (closeToken.type !== 'link_close') return;

      // Lookup the mention type and ID from the link's href
      var href = openToken.attrs.reduce(function (href, attr) {
        return attr[0] === 'href' ? attr[1] : href;
      }, '');

      // Remove the @ character from the previous text node
      matchToken.content = matchToken.content.slice(0, -1);

      // Replace the "link_open" with a single "mention" token
      openToken.type = 'mention';
      openToken.mention = parseUri(href);
      openToken.mention.label = textToken && textToken.content || '';

      // Remove the "text" and "link_close" tokens
      children.splice(idx + 2, textToken ? 2 : 1);
    });

    blockToken.children = children;
  });
}

module.exports = function (md, opts) {
  md.renderer.rules.mention = renderMention;
  md.core.ruler.after('inline', 'mention', parseMentions);
};

exports.renderMention = renderMention;
exports.parseUri = parseUri;
exports.parseMentions = parseMentions;
//# sourceMappingURL=index.js.map
