const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=[window.OC.filePath('contacts', '', 'js/index-Kg2hZgGF-cCkQTNoH.chunk.mjs'),window.OC.filePath('contacts', '', 'js/style-NE2zwFZ0.chunk.mjs'),window.OC.filePath('contacts', '', 'js/index-fSqcvS-W.chunk.mjs'),window.OC.filePath('contacts', '', 'js/index-C-qT-4FH.chunk.mjs'),window.OC.filePath('contacts', '', 'css/index-DOdf9JBh.chunk.css'),window.OC.filePath('contacts', '', 'css/style-C4vl5zVD.chunk.css')])))=>i.map(i=>d[i]);
/*! third party licenses: js/vendor.LICENSE.txt */
const appName = "contacts";
const appVersion = "7.1.0-dev.0";
import { n as normalizeComponent, V as Vue, s as subscribe, e as emit, u as unsubscribe, t as toRaw, d as defineComponent, g as getAugmentedNamespace, v as vue_runtime_esm, c as commonjsGlobal, a as getDefaultExportFromCjs, b as cancelableClient, f as v, r as ref$1, B as Buffer, l as loadState, U, h as getCurrentUser, _ } from "./index-C-qT-4FH.chunk.mjs";
import { n as normalizeComponent$1, N as NcAppNavigationToggle, u as useIsMobile, c as createFocusTrap, g as getTrapStack, a as useHotKey, t as tabbable, l as logger, b as NcActions, d as getCanonicalLocale, e as NcVNodes, f as NcAvatar, h as NcPopover, L as Link, p as pathBrowserify, i as NcCheckboxRadioSwitch, j as NcActionButton, k as NcActionText, m as NcEmptyContent, o as NcLoadingIcon, q as NcModal, r as debounce, s as NcButton, v as translate, w as NcRichContenteditable, x as useElementSize, y as NcAppContent, z as NcSelect, A as getLocale$1, I as ICALmodule, B as NcActionLink, C as NcRelatedResourcesPanel, D as NcAppNavigationItem, E as NcActionInput, F as NcTextField, G as NcAppSettingsDialog, H as e$1, J as NcContent, V as VueRouter$1, K as VTooltip } from "./index-fSqcvS-W.chunk.mjs";
import { t as t$1, n as n$1, _ as __vitePreload, s as showSuccess, a as showError, C as Circle, j as joinCircle, M as Member, P as PUBLIC_CIRCLE_CONFIG, e as editCircle, b as CircleEdit, I as IconDelete, c as MemberLevels, d as CIRCLES_MEMBER_LEVELS, f as MemberStatus, g as changeMemberLevel, S as SHARES_TYPES_MEMBER_MAP, h as IconContact, i as IconAdd, k as index, l as CIRCLES_MEMBER_GROUPING, m as showWarning, o as transformNode, p as getChart, q as PropertyTitleIcon, O as OrgChartsMixin, r as Contact, u as rfcProps, v as _default$1, w as logger$1, x as showInfo, y as PropertyTitle, z as o, A as ContactDetailsProperty, B as IconEmail, D as IconMessage, E as IconCall, F as IconUser, G as IconCopy$1, H as IconRename$1, J as PropertySelect, K as mitt, L as validate, N as pLimit, Q as client, R as NcActionCheckbox, T as usePrincipalsStore, U as CONTACTS_SETTINGS, V as hooks, W as CIRCLE_DESC, X as ELLIPSIS_COUNT, Y as GROUP_ALL_CONTACTS, Z as CHART_ALL_CONTACTS, $ as GROUP_NO_GROUP_CONTACTS, a0 as GROUP_RECENTLY_CONTACTED, a1 as isCirclesEnabled, a2 as ROUTE_CIRCLE, a3 as ROUTE_CHART, a4 as PiniaVuePlugin, a5 as createPinia, a6 as ClickOutside, a7 as store } from "./style-NE2zwFZ0.chunk.mjs";
import { e as encodePath } from "./index-ghM_rkL4.chunk.mjs";
var sync = function(store2, router2, options) {
  var moduleName = (options || {}).moduleName || "route";
  store2.registerModule(moduleName, {
    namespaced: true,
    state: cloneRoute(router2.currentRoute),
    mutations: {
      "ROUTE_CHANGED": function ROUTE_CHANGED(state, transition) {
        store2.state[moduleName] = cloneRoute(transition.to, transition.from);
      }
    }
  });
  var isTimeTraveling = false;
  var currentPath;
  var storeUnwatch = store2.watch(
    function(state) {
      return state[moduleName];
    },
    function(route) {
      var fullPath = route.fullPath;
      if (fullPath === currentPath) {
        return;
      }
      if (currentPath != null) {
        isTimeTraveling = true;
        router2.push(route);
      }
      currentPath = fullPath;
    },
    { sync: true }
  );
  var afterEachUnHook = router2.afterEach(function(to, from) {
    if (isTimeTraveling) {
      isTimeTraveling = false;
      return;
    }
    currentPath = to.fullPath;
    store2.commit(moduleName + "/ROUTE_CHANGED", { to, from });
  });
  return function unsync() {
    if (afterEachUnHook != null) {
      afterEachUnHook();
    }
    if (storeUnwatch != null) {
      storeUnwatch();
    }
    store2.unregisterModule(moduleName);
  };
};
function cloneRoute(to, from) {
  var clone = {
    name: to.name,
    path: to.path,
    hash: to.hash,
    query: to.query,
    params: to.params,
    fullPath: to.fullPath,
    meta: to.meta
  };
  if (from) {
    clone.from = cloneRoute(from);
  }
  return Object.freeze(clone);
}
const _sfc_main$1f = {
  name: "ContactsRoot"
};
var _sfc_render$1f = function render() {
  var _vm = this, _c = _vm._self._c;
  return _c("router-view");
};
var _sfc_staticRenderFns$1f = [];
var __component__$1f = /* @__PURE__ */ normalizeComponent(
  _sfc_main$1f,
  _sfc_render$1f,
  _sfc_staticRenderFns$1f,
  false,
  null,
  null
);
const App = __component__$1f.exports;
const _sfc_main$1e = {
  name: "NcActionSeparator"
};
var _sfc_render$1e = function render2() {
  var _vm = this, _c = _vm._self._c;
  return _c("li", { staticClass: "action action-separator action--disabled", attrs: { "role": "separator" } });
};
var _sfc_staticRenderFns$1e = [];
var __component__$1e = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$1e,
  _sfc_render$1e,
  _sfc_staticRenderFns$1e,
  false,
  null,
  "3e2324b7"
);
const NcActionSeparator = __component__$1e.exports;
const _sfc_main$1d = {
  name: "NcAppContentDetails"
};
var _sfc_render$1d = function render3() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "app-content-details" }, [_vm._t("default")], 2);
};
var _sfc_staticRenderFns$1d = [];
var __component__$1d = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$1d,
  _sfc_render$1d,
  _sfc_staticRenderFns$1d,
  false,
  null,
  null
);
const NcAppContentDetails = __component__$1d.exports;
const _sfc_main$1c = {
  name: "NcAppContentList",
  props: {
    selection: {
      type: Boolean,
      default: false
    },
    showDetails: {
      type: Boolean,
      default: false
    }
  }
};
var _sfc_render$1c = function render4() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "app-content-list", class: { selection: _vm.selection, showdetails: _vm.showDetails } }, [_vm._t("default")], 2);
};
var _sfc_staticRenderFns$1c = [];
var __component__$1c = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$1c,
  _sfc_render$1c,
  _sfc_staticRenderFns$1c,
  false,
  null,
  null
);
const NcAppContentList = __component__$1c.exports;
const _sfc_main$1b = {
  name: "NcAppNavigationList"
};
var _sfc_render$1b = function render5() {
  var _vm = this, _c = _vm._self._c;
  return _c("ul", { staticClass: "app-navigation-list" }, [_vm._t("default")], 2);
};
var _sfc_staticRenderFns$1b = [];
var __component__$1b = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$1b,
  _sfc_render$1b,
  _sfc_staticRenderFns$1b,
  false,
  null,
  "058e6060"
);
const NcAppNavigationList = __component__$1b.exports;
const _sfc_main$1a = {
  name: "NcAppNavigation",
  components: {
    NcAppNavigationList,
    NcAppNavigationToggle
  },
  // Injected from NcContent
  inject: {
    setHasAppNavigation: {
      default: () => () => Vue.util.warn("NcAppNavigation is not mounted inside NcContent, this is probably an error."),
      from: "NcContent:setHasAppNavigation"
    }
  },
  props: {
    /**
     * The aria label to describe the navigation
     */
    ariaLabel: {
      type: String,
      default: ""
    },
    /**
     * aria-labelledby attribute to describe the navigation
     */
    ariaLabelledby: {
      type: String,
      default: ""
    }
  },
  setup() {
    return {
      isMobile: useIsMobile()
    };
  },
  data() {
    return {
      open: !this.isMobile,
      focusTrap: null
    };
  },
  watch: {
    isMobile() {
      this.open = !this.isMobile;
      this.toggleFocusTrap();
    },
    open() {
      this.toggleFocusTrap();
    }
  },
  mounted() {
    this.setHasAppNavigation(true);
    subscribe("toggle-navigation", this.toggleNavigationByEventBus);
    emit("navigation-toggled", {
      open: this.open
    });
    this.focusTrap = createFocusTrap(this.$refs.appNavigationContainer, {
      allowOutsideClick: true,
      fallbackFocus: this.$refs.appNavigationContainer,
      trapStack: getTrapStack(),
      escapeDeactivates: false
    });
    this.toggleFocusTrap();
    useHotKey("n", this.onKeyDown, {
      prevent: true,
      stop: true
    });
  },
  unmounted() {
    this.setHasAppNavigation(false);
    unsubscribe("toggle-navigation", this.toggleNavigationByEventBus);
    this.focusTrap.deactivate();
  },
  methods: {
    /**
     * Toggle the navigation
     *
     * @param {boolean} [state] set the state instead of inverting the current one
     */
    async toggleNavigation(state) {
      if (this.open === state) {
        emit("navigation-toggled", {
          open: this.open
        });
        return;
      }
      this.open = typeof state === "undefined" ? !this.open : state;
      const bodyStyles = getComputedStyle(document.body);
      const animationLength = parseInt(bodyStyles.getPropertyValue("--animation-quick")) || 100;
      if (this.open) {
        await this.$nextTick();
        this.focusFirstElement();
      }
      setTimeout(() => {
        emit("navigation-toggled", {
          open: this.open
        });
      }, 1.5 * animationLength);
    },
    toggleNavigationByEventBus({ open }) {
      this.toggleNavigation(open);
    },
    /**
     * Activate focus trap if it is currently needed, otherwise deactivate
     */
    toggleFocusTrap() {
      if (this.isMobile && this.open) {
        this.focusTrap.activate();
      } else {
        this.focusTrap.deactivate();
      }
    },
    handleEsc() {
      if (this.isMobile && this.open) {
        this.toggleNavigation(false);
      }
    },
    focusFirstElement() {
      const element = tabbable(this.$refs.appNavigationContainer)[0];
      if (element) {
        element.focus();
        logger.debug("Focusing first element in the navigation", { element });
      }
    },
    onKeyDown(event) {
      if (event.key === "n") {
        if (!this.open) {
          this.toggleNavigation(true);
          return;
        }
        if (this.isFocusWithinNavigation()) {
          this.toggleNavigation(false);
        }
      }
    },
    isFocusWithinNavigation() {
      const activeElement = document.activeElement;
      return this.$refs.appNavigationContainer.contains(activeElement);
    }
  }
};
var _sfc_render$1a = function render6() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { ref: "appNavigationContainer", staticClass: "app-navigation", class: { "app-navigation--close": !_vm.open } }, [_c("nav", { staticClass: "app-navigation__content", attrs: { "id": "app-navigation-vue", "aria-hidden": _vm.open ? "false" : "true", "aria-label": _vm.ariaLabel || void 0, "aria-labelledby": _vm.ariaLabelledby || void 0, "inert": !_vm.open || void 0 }, on: { "keydown": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) return null;
    return _vm.handleEsc.apply(null, arguments);
  } } }, [_c("div", { staticClass: "app-navigation__search" }, [_vm._t("search")], 2), _c("div", { staticClass: "app-navigation__body", class: { "app-navigation__body--no-list": !_vm.$scopedSlots.list } }, [_vm._t("default")], 2), _vm.$scopedSlots.list ? _c("NcAppNavigationList", { staticClass: "app-navigation__list" }, [_vm._t("list")], 2) : _vm._e(), _vm._t("footer")], 2), _c("NcAppNavigationToggle", { attrs: { "open": _vm.open }, on: { "update:open": _vm.toggleNavigation } })], 1);
};
var _sfc_staticRenderFns$1a = [];
var __component__$1a = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$1a,
  _sfc_render$1a,
  _sfc_staticRenderFns$1a,
  false,
  null,
  "1329aac9"
);
const NcAppNavigation = __component__$1a.exports;
const _sfc_main$19 = {
  name: "NcAppNavigationCaption",
  components: {
    NcActions
  },
  inheritAttrs: false,
  props: {
    name: {
      type: String,
      required: true
    },
    /**
     * `id` to set on the inner caption
     * Can be used for connecting the `NcActionCaption` with `NcActionList` using `aria-labelledby`.
     */
    headingId: {
      type: String,
      default: null
    },
    /**
     * Enable when used as a heading
     * e.g. Before NcAppNavigationList
     */
    isHeading: {
      type: Boolean,
      default: false
    },
    /**
     * If `isHeading` is set, this defines the heading level that should be used
     */
    headingLevel: {
      type: Number,
      default: 2
    },
    /**
     * Any [NcActions](#/Components/NcActions?id=ncactions-1) prop
     */
    // Not an actual prop but needed to show in vue-styleguidist docs
    // eslint-disable-next-line
    " ": {}
  },
  computed: {
    wrapperTag() {
      return this.isHeading ? "div" : "li";
    },
    captionTag() {
      const headingLevel = Math.max(2, this.headingLevel);
      return this.isHeading ? `h${headingLevel}` : "span";
    },
    // Check if the actions slot is populated
    hasActions() {
      return !!this.$slots.actions;
    }
  }
};
var _sfc_render$19 = function render7() {
  var _vm = this, _c = _vm._self._c;
  return _c(_vm.wrapperTag, { tag: "component", staticClass: "app-navigation-caption", class: { "app-navigation-caption--heading": _vm.isHeading } }, [_c(_vm.captionTag, { tag: "component", staticClass: "app-navigation-caption__name", attrs: { "id": _vm.headingId } }, [_vm._v(" " + _vm._s(_vm.name) + " ")]), _vm.hasActions ? _c("div", { staticClass: "app-navigation-caption__actions" }, [_c("NcActions", _vm._g(_vm._b({ scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm._t("actionsTriggerIcon")];
  }, proxy: true }], null, true) }, "NcActions", _vm.$attrs, false), _vm.$listeners), [_vm._t("actions")], 2)], 1) : _vm._e()], 1);
};
var _sfc_staticRenderFns$19 = [];
var __component__$19 = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$19,
  _sfc_render$19,
  _sfc_staticRenderFns$19,
  false,
  null,
  "1133b4da"
);
const NcAppNavigationCaption = __component__$19.exports;
const _sfc_main$18 = {
  name: "NcAppSettingsSection",
  inject: ["registerSection", "unregisterSection"],
  props: {
    name: {
      type: String,
      required: true
    },
    id: {
      type: String,
      required: true,
      validator(id2) {
        return /^[a-z0-9\-_]+$/.test(id2);
      }
    }
  },
  computed: {
    // generate an id for each settingssection based on the name without whitespaces
    htmlId() {
      return "settings-section_" + this.id;
    }
  },
  // Reactive changes for section navigation
  watch: {
    id(newId2, oldId) {
      this.unregisterSection(oldId);
      this.registerSection(newId2, this.name, this.$slots?.icon);
    },
    name(newName) {
      this.unregisterSection(this.id);
      this.registerSection(this.id, newName, this.$slots?.icon);
    }
  },
  mounted() {
    this.registerSection(this.id, this.name, this.$slots?.icon);
  },
  beforeDestroy() {
    this.unregisterSection(this.id);
  }
};
var _sfc_render$18 = function render8() {
  var _vm = this, _c = _vm._self._c;
  return _c("section", { staticClass: "app-settings-section", attrs: { "id": _vm.htmlId, "aria-labelledby": `${_vm.htmlId}--label` } }, [_c("h3", { staticClass: "app-settings-section__name", attrs: { "id": `${_vm.htmlId}--label` } }, [_vm._v(" " + _vm._s(_vm.name) + " ")]), _vm._t("default"), _vm._e()], 2);
};
var _sfc_staticRenderFns$18 = [];
var __component__$18 = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$18,
  _sfc_render$18,
  _sfc_staticRenderFns$18,
  false,
  null,
  "e970c9f7"
);
const NcAppSettingsSection = __component__$18.exports;
const _sfc_main$17 = {
  name: "NcCounterBubble",
  props: {
    type: {
      type: String,
      default: "",
      validator(value) {
        return ["highlighted", "outlined", ""].includes(value);
      }
    },
    /**
     * Specifies whether the component is used within a component that is
     * active and therefore has a primary background. Inverts the color of
     * this component when that is the case.
     */
    active: {
      type: Boolean,
      default: false
    },
    /**
     * The count to display in the counter bubble.
     * Alternatively, you can pass any value to the default slot.
     */
    count: {
      type: Number,
      required: false,
      default: void 0
    },
    /**
     * Disables humanization to display count or content as it is
     */
    raw: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  computed: {
    counterClassObject() {
      return {
        "counter-bubble__counter--highlighted": this.type === "highlighted",
        "counter-bubble__counter--outlined": this.type === "outlined",
        active: this.active
      };
    },
    humanizedCount() {
      return this.humanizeCount(this.count);
    }
  },
  methods: {
    humanizeCount(count2) {
      if (this.raw) {
        return count2.toString();
      }
      const formatter = new Intl.NumberFormat(getCanonicalLocale(), {
        notation: "compact",
        compactDisplay: "short"
      });
      return formatter.format(count2);
    },
    /**
     * Get the humanized count from `count` prop
     * @return {{ humanized: string, original: string} | undefined}
     */
    getHumanizedCount() {
      if (this.count !== void 0) {
        return {
          humanized: this.humanizedCount,
          original: this.count.toString()
        };
      }
      if (this.raw) {
        return void 0;
      }
      if (this.$slots.default?.length === 1) {
        const slotContent = this.$slots.default[0].text?.trim();
        if (slotContent && /^\d+$/.test(slotContent)) {
          const count2 = parseInt(slotContent, 10);
          return {
            humanized: this.humanizeCount(count2),
            original: slotContent
          };
        }
      }
    }
  },
  render(h) {
    const count2 = this.getHumanizedCount();
    return h("div", {
      staticClass: "counter-bubble__counter",
      class: this.counterClassObject,
      attrs: {
        // Show original count in title if humanized
        title: count2 && count2.original !== count2.humanized ? count2.original : void 0
      }
    }, [count2?.humanized ?? this.$slots.default]);
  }
};
const _sfc_render$17 = null;
const _sfc_staticRenderFns$17 = null;
var __component__$17 = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$17,
  _sfc_render$17,
  _sfc_staticRenderFns$17,
  false,
  null,
  "f1abaa29"
);
const NcCounterBubble = __component__$17.exports;
const _sfc_main$16 = {
  name: "NcListItem",
  components: {
    NcActions,
    NcCounterBubble,
    NcVNodes
  },
  props: {
    /**
     * The details text displayed in the upper right part of the component
     */
    details: {
      type: String,
      default: ""
    },
    /**
     * Name (first line of text)
     */
    name: {
      type: String,
      default: void 0
    },
    /**
     * Pass in `true` if you want the matching behavior to
     * be non-inclusive: https://router.vuejs.org/api/#exact
     */
    exact: {
      type: Boolean,
      default: false
    },
    /**
     * The route for the router link.
     */
    to: {
      type: [String, Object],
      default: null
    },
    /**
     * The value for the external link
     */
    href: {
      type: String,
      default: "#"
    },
    target: {
      type: String,
      default: ""
    },
    /**
     * Id for the `<a>` element
     */
    anchorId: {
      type: String,
      default: ""
    },
    /**
     * Make subname bold
     */
    bold: {
      type: Boolean,
      default: false
    },
    /**
     * Show the NcListItem in compact design
     */
    compact: {
      type: Boolean,
      default: false
    },
    /**
     * Toggle the active state of the component
     */
    active: {
      type: Boolean,
      default: false
    },
    /**
     * Aria label for the wrapper element
     */
    linkAriaLabel: {
      type: String,
      default: ""
    },
    /**
     * Aria label for the actions toggle
     */
    actionsAriaLabel: {
      type: String,
      default: void 0
    },
    /**
     * If different from 0 this component will display the
     * NcCounterBubble component
     */
    counterNumber: {
      type: [Number, String],
      default: 0
    },
    /**
     * Outlined or highlighted state of the counter
     */
    counterType: {
      type: String,
      default: "",
      validator(value) {
        return ["highlighted", "outlined", ""].indexOf(value) !== -1;
      }
    },
    /**
     * To be used only when the elements in the actions menu are very important
     */
    forceDisplayActions: {
      type: Boolean,
      default: false
    },
    /**
     * Force the actions to display in a three dot menu
     */
    forceMenu: {
      type: Boolean,
      default: false
    },
    /**
     * Show the list component layout
     */
    oneLine: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "click",
    "update:menuOpen"
  ],
  setup() {
    const [major] = window._oc_config?.version.split(".", 2) ?? [];
    const isLegacy = major && Number.parseInt(major) < 30;
    return {
      isLegacy
    };
  },
  data() {
    return {
      hovered: false,
      hasActions: false,
      hasSubname: false,
      displayActionsOnHoverFocus: false,
      menuOpen: false,
      hasIndicator: false,
      hasDetails: false
    };
  },
  computed: {
    showAdditionalElements() {
      return !this.displayActionsOnHoverFocus || this.forceDisplayActions;
    },
    showDetails() {
      return (this.details !== "" || this.hasDetails) && (!this.displayActionsOnHoverFocus || this.forceDisplayActions);
    }
  },
  watch: {
    menuOpen(newValue) {
      if (!newValue && !this.hovered) {
        this.displayActionsOnHoverFocus = false;
      }
    }
  },
  mounted() {
    this.checkSlots();
  },
  updated() {
    this.checkSlots();
  },
  methods: {
    /**
     * Handle link click
     *
     * @param {MouseEvent|KeyboardEvent} event - Native click or keydown event
     * @param {Function} [navigate] - VueRouter link's navigate if any
     * @param {string} [routerLinkHref] - VueRouter link's href
     */
    onClick(event, navigate, routerLinkHref) {
      this.$emit("click", event);
      if (event.metaKey || event.altKey || event.ctrlKey || event.shiftKey) {
        return;
      }
      if (routerLinkHref) {
        navigate?.(event);
        event.preventDefault();
      }
    },
    showActions() {
      if (this.hasActions) {
        this.displayActionsOnHoverFocus = true;
      }
      this.hovered = false;
    },
    hideActions() {
      this.displayActionsOnHoverFocus = false;
    },
    /**
     * @param {FocusEvent} event UI event
     */
    handleBlur(event) {
      if (this.menuOpen) {
        return;
      }
      if (this.$refs["list-item"].contains(event.relatedTarget)) {
        return;
      }
      this.hideActions();
    },
    /**
     * Hide the actions on mouseleave unless the menu is open
     */
    handleMouseleave() {
      if (!this.menuOpen) {
        this.displayActionsOnHoverFocus = false;
      }
      this.hovered = false;
    },
    handleMouseover() {
      this.showActions();
      this.hovered = true;
    },
    handleActionsUpdateOpen(e2) {
      this.menuOpen = e2;
      this.$emit("update:menuOpen", e2);
    },
    // Check if subname and actions slots are populated
    checkSlots() {
      if (this.hasActions !== !!this.$slots.actions) {
        this.hasActions = !!this.$slots.actions;
      }
      if (this.hasSubname !== !!this.$slots.subname) {
        this.hasSubname = !!this.$slots.subname;
      }
      if (this.hasIndicator !== !!this.$slots.indicator) {
        this.hasIndicator = !!this.$slots.indicator;
      }
      if (this.hasDetails !== !!this.$slots.details) {
        this.hasDetails = !!this.$slots.details;
      }
    }
  }
};
var _sfc_render$16 = function render9() {
  var _vm = this, _c = _vm._self._c;
  return _c(_vm.to ? "router-link" : "NcVNodes", { tag: "component", attrs: { "custom": _vm.to ? true : null, "to": _vm.to, "exact": _vm.to ? _vm.exact : null }, scopedSlots: _vm._u([{ key: "default", fn: function({ href: routerLinkHref, navigate, isActive }) {
    return [_c("li", { staticClass: "list-item__wrapper", class: { "list-item__wrapper--active": isActive || _vm.active } }, [_c("div", { ref: "list-item", staticClass: "list-item", class: {
      "list-item--compact": _vm.compact,
      "list-item--legacy": _vm.isLegacy,
      "list-item--one-line": _vm.oneLine
    }, on: { "mouseover": _vm.handleMouseover, "mouseleave": _vm.handleMouseleave } }, [_c("a", { staticClass: "list-item__anchor", attrs: { "id": _vm.anchorId || void 0, "aria-label": _vm.linkAriaLabel, "href": routerLinkHref || _vm.href, "target": _vm.target || (_vm.href === "#" ? void 0 : "_blank"), "rel": _vm.href === "#" ? void 0 : "noopener noreferrer" }, on: { "focus": _vm.showActions, "focusout": _vm.handleBlur, "click": function($event) {
      return _vm.onClick($event, navigate, routerLinkHref);
    }, "keydown": function($event) {
      if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "esc", 27, $event.key, ["Esc", "Escape"])) return null;
      return _vm.hideActions.apply(null, arguments);
    } } }, [_vm._t("icon"), _c("div", { staticClass: "list-item-content" }, [_c("div", { staticClass: "list-item-content__main" }, [_c("div", { staticClass: "list-item-content__name" }, [_vm._t("name", function() {
      return [_vm._v(_vm._s(_vm.name))];
    })], 2), _vm.hasSubname ? _c("div", { staticClass: "list-item-content__subname", class: { "list-item-content__subname--bold": _vm.bold } }, [_vm._t("subname")], 2) : _vm._e()]), _c("div", { staticClass: "list-item-content__details" }, [_vm.showDetails ? _c("div", { staticClass: "list-item-details__details" }, [_vm._t("details", function() {
      return [_vm._v(_vm._s(_vm.details))];
    })], 2) : _vm._e(), _vm.counterNumber || _vm.hasIndicator ? _c("div", { directives: [{ name: "show", rawName: "v-show", value: _vm.showAdditionalElements, expression: "showAdditionalElements" }], staticClass: "list-item-details__extra" }, [_vm.counterNumber ? _c("NcCounterBubble", { staticClass: "list-item-details__counter", attrs: { "active": isActive || _vm.active, "type": _vm.counterType } }, [_vm._v(" " + _vm._s(_vm.counterNumber) + " ")]) : _vm._e(), _vm.hasIndicator ? _c("span", { staticClass: "list-item-details__indicator" }, [_vm._t("indicator")], 2) : _vm._e()], 1) : _vm._e()])])], 2), _vm.$slots["extra-actions"] ? _c("div", { staticClass: "list-item-content__extra-actions" }, [_vm._t("extra-actions")], 2) : _vm._e(), _c("div", { directives: [{ name: "show", rawName: "v-show", value: _vm.forceDisplayActions || _vm.displayActionsOnHoverFocus, expression: "forceDisplayActions || displayActionsOnHoverFocus" }], staticClass: "list-item-content__actions", on: { "focusout": _vm.handleBlur } }, [_c("NcActions", { ref: "actions", attrs: { "primary": isActive || _vm.active, "force-menu": _vm.forceMenu, "aria-label": _vm.actionsAriaLabel }, on: { "update:open": _vm.handleActionsUpdateOpen }, scopedSlots: _vm._u([_vm.$slots["actions-icon"] ? { key: "icon", fn: function() {
      return [_vm._t("actions-icon")];
    }, proxy: true } : null], null, true) }, [_vm._t("actions")], 2)], 1), _vm.$slots.extra ? _c("div", { staticClass: "list-item__extra" }, [_vm._t("extra")], 2) : _vm._e()])])];
  } }], null, true) });
};
var _sfc_staticRenderFns$16 = [];
var __component__$16 = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$16,
  _sfc_render$16,
  _sfc_staticRenderFns$16,
  false,
  null,
  "ccc793f0"
);
const NcListItem = __component__$16.exports;
const _sfc_main$1$1 = {
  name: "NcUserBubbleDiv"
};
var _sfc_render$1$1 = function render10() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", [_vm._t("trigger")], 2);
};
var _sfc_staticRenderFns$1$1 = [];
var __component__$1$1 = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$1$1,
  _sfc_render$1$1,
  _sfc_staticRenderFns$1$1,
  false,
  null,
  null
);
const NcUserBubbleDiv = __component__$1$1.exports;
const _sfc_main$15 = {
  name: "NcUserBubble",
  components: {
    NcAvatar,
    NcPopover,
    NcUserBubbleDiv
  },
  props: {
    /**
     * Override generated avatar, can be an url or an icon class
     */
    avatarImage: {
      type: String,
      default: void 0
    },
    /**
     * Provide the user id if this is a user
     */
    user: {
      type: String,
      default: void 0
    },
    /**
     * Displayed label
     */
    displayName: {
      type: String,
      default: void 0
    },
    /**
     * Whether or not to display the user-status
     */
    showUserStatus: {
      type: Boolean,
      default: false
    },
    /**
     * Define the whole bubble as a link
     */
    url: {
      type: String,
      default: void 0,
      validator: (url) => {
        try {
          url = new URL(url, url?.startsWith?.("/") ? window.location.href : void 0);
          return true;
        } catch (error) {
          return false;
        }
      }
    },
    /**
     * Use bubble as a router-link for in-app navigation
     */
    to: {
      type: [String, Object],
      default: void 0
    },
    /**
     * Default popover state. Requires the UserBubble
     * to have some content to render inside the popover
     */
    open: {
      type: Boolean,
      default: false
    },
    /**
     * Use the primary colour
     */
    primary: {
      type: Boolean,
      default: false
    },
    /**
     * This is the height of the component
     */
    size: {
      type: Number,
      default: 20
    },
    /**
     * This is the margin of the avatar (size - margin = avatar size)
     */
    margin: {
      type: Number,
      default: 2
    }
  },
  emits: [
    "click",
    "update:open"
  ],
  computed: {
    /**
     * If userbubble is empty, let's NOT
     * use the Popover component
     * We need a component instead of a simple div here,
     * because otherwise the trigger template will not be shown.
     *
     * @return {string} 'Popover' or 'UserBubbleDiv'
     */
    isPopoverComponent() {
      return !this.popoverEmpty ? "NcPopover" : "NcUserBubbleDiv";
    },
    /**
     * Is the provided avatar url valid or not
     *
     * @return {boolean}
     */
    isAvatarUrl() {
      if (!this.avatarImage) {
        return false;
      }
      try {
        const url = new URL(this.avatarImage);
        return !!url;
      } catch (error) {
        return false;
      }
    },
    /**
     * Do we have a custom avatar or not
     *
     * @return {boolean}
     */
    isCustomAvatar() {
      return !!this.avatarImage;
    },
    hasUrl() {
      return this.url && this.url.trim() !== "";
    },
    isLinkComponent() {
      if (this.hasUrl) {
        return "a";
      } else if (this.to) {
        return Link;
      } else {
        return "div";
      }
    },
    popoverEmpty() {
      if ("default" in this.$slots) {
        return false;
      }
      return true;
    },
    styles() {
      return {
        content: {
          height: this.size + "px",
          lineHeight: this.size + "px",
          borderRadius: this.size / 2 + "px"
        },
        avatar: {
          marginInlineStart: this.margin + "px"
        }
      };
    }
  },
  mounted() {
    if (!this.displayName && !this.user) {
      Vue.util.warn("[NcUserBubble] At least `displayName` or `user` property should be set.");
    }
  },
  methods: {
    onOpenChange(state) {
      this.$emit("update:open", state);
    },
    /**
     * Catch and forward click event to parent
     *
     * @param {Event} event the click event
     */
    onClick(event) {
      this.$emit("click", event);
    }
  }
};
var _sfc_render$15 = function render22() {
  var _vm = this, _c = _vm._self._c;
  return _c(_vm.isPopoverComponent, { tag: "component", staticClass: "user-bubble__wrapper", attrs: { "trigger": "hover focus", "shown": _vm.open }, on: { "update:open": _vm.onOpenChange }, scopedSlots: _vm._u([{ key: "trigger", fn: function({ attrs }) {
    return [_c(_vm.isLinkComponent, _vm._b({ tag: "component", staticClass: "user-bubble__content", class: { "user-bubble__content--primary": _vm.primary }, style: _vm.styles.content, attrs: { "to": _vm.to, "href": _vm.hasUrl ? _vm.url : null }, on: { "click": _vm.onClick } }, "component", attrs, false), [_c("NcAvatar", { staticClass: "user-bubble__avatar", style: _vm.styles.avatar, attrs: { "url": _vm.isCustomAvatar && _vm.isAvatarUrl ? _vm.avatarImage : void 0, "icon-class": _vm.isCustomAvatar && !_vm.isAvatarUrl ? _vm.avatarImage : void 0, "user": _vm.user, "display-name": _vm.displayName, "size": _vm.size - _vm.margin * 2, "disable-tooltip": true, "disable-menu": true, "show-user-status": _vm.showUserStatus } }), _c("span", { staticClass: "user-bubble__name" }, [_vm._v(" " + _vm._s(_vm.displayName || _vm.user) + " ")]), _vm.$slots.name ? _c("span", { staticClass: "user-bubble__secondary" }, [_vm._t("name")], 2) : _vm._e()], 1)];
  } }], null, true) }, [_vm._t("default")], 2);
};
var _sfc_staticRenderFns$15 = [];
var __component__$15 = /* @__PURE__ */ normalizeComponent$1(
  _sfc_main$15,
  _sfc_render$15,
  _sfc_staticRenderFns$15,
  false,
  null,
  "a62a9496"
);
const NcUserBubble = __component__$15.exports;
const spawnDialog = (dialog, props, onClose = () => {
}) => {
  const el = document.createElement("div");
  const container = document.querySelector(props == null ? void 0 : props.container) || document.body;
  container.appendChild(el);
  const vue = new Vue({
    el,
    name: "VueDialogHelper",
    render: (h2) => h2(dialog, {
      props,
      on: {
        close: (...rest) => {
          onClose(...rest.map((v2) => toRaw(v2)));
          vue.$destroy();
        }
      }
    })
  });
  return vue;
};
const IconMove = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-folder-move" viewBox="0 0 24 24"><path d="M14,18V15H10V11H14V8L19,13M20,6H12L10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6Z" /></svg>';
const IconCopy = '<svg xmlns="http://www.w3.org/2000/svg" id="mdi-folder-multiple" viewBox="0 0 24 24"><path d="M22,4H14L12,2H6A2,2 0 0,0 4,4V16A2,2 0 0,0 6,18H22A2,2 0 0,0 24,16V6A2,2 0 0,0 22,4M2,6H0V11H0V20A2,2 0 0,0 2,22H20V20H2V6Z" /></svg>';
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
class FilePickerClosed extends Error {
}
class FilePicker {
  constructor(title, multiSelect, mimeTypeFilter, directoriesAllowed, buttons, path2, filter2, container, disabledNavigation = false) {
    __publicField(this, "title");
    __publicField(this, "multiSelect");
    __publicField(this, "mimeTypeFilter");
    __publicField(this, "directoriesAllowed");
    __publicField(this, "buttons");
    __publicField(this, "path");
    __publicField(this, "filter");
    __publicField(this, "container");
    __publicField(this, "disabledNavigation");
    this.title = title;
    this.multiSelect = multiSelect;
    this.mimeTypeFilter = mimeTypeFilter;
    this.directoriesAllowed = directoriesAllowed;
    this.path = path2;
    this.filter = filter2;
    this.buttons = buttons;
    this.container = container;
    this.disabledNavigation = disabledNavigation;
  }
  /**
   * Pick files using the FilePicker
   *
   * @return Promise with array of picked files or rejected promise on close without picking
   */
  async pick() {
    const { FilePickerVue } = await __vitePreload(async () => {
      const { FilePickerVue: FilePickerVue2 } = await import("./index-Kg2hZgGF-cCkQTNoH.chunk.mjs");
      return { FilePickerVue: FilePickerVue2 };
    }, true ? __vite__mapDeps([0,1,2,3,4,5]) : void 0, import.meta.url);
    return new Promise((resolve, reject) => {
      spawnDialog(FilePickerVue, {
        allowPickDirectory: this.directoriesAllowed,
        buttons: this.buttons,
        container: this.container,
        name: this.title,
        path: this.path,
        mimetypeFilter: this.mimeTypeFilter,
        multiselect: this.multiSelect,
        filterFn: this.filter,
        disabledNavigation: this.disabledNavigation
      }, (...rest) => {
        var _a;
        const [nodes] = rest;
        if (!Array.isArray(nodes) || nodes.length === 0) {
          reject(new FilePickerClosed("FilePicker: No nodes selected"));
        } else {
          if (this.multiSelect) {
            resolve(nodes.map((node) => node.path));
          } else {
            resolve(((_a = nodes[0]) == null ? void 0 : _a.path) || "/");
          }
        }
      });
    });
  }
}
class FilePickerBuilder {
  /**
   * Construct a new FilePicker
   *
   * @param title Title of the FilePicker
   */
  constructor(title) {
    __publicField(this, "title");
    __publicField(this, "multiSelect", false);
    __publicField(this, "mimeTypeFilter", []);
    __publicField(this, "directoriesAllowed", false);
    __publicField(this, "path");
    __publicField(this, "filter");
    __publicField(this, "buttons", []);
    __publicField(this, "container");
    __publicField(this, "disabledNavigation", false);
    this.title = title;
  }
  /**
   * Set the container where the FilePicker will be mounted
   * By default 'body' is used
   *
   * @param container The dialog container
   */
  setContainer(container) {
    this.container = container;
    return this;
  }
  /**
   * Enable or disable picking multiple files
   *
   * @param ms True to enable picking multiple files, false otherwise
   */
  setMultiSelect(ms) {
    this.multiSelect = ms;
    return this;
  }
  /**
   * Add allowed MIME type
   *
   * @param filter MIME type to allow
   */
  addMimeTypeFilter(filter2) {
    this.mimeTypeFilter.push(filter2);
    return this;
  }
  /**
   * Set allowed MIME types
   *
   * @param filter Array of allowed MIME types
   */
  setMimeTypeFilter(filter2) {
    this.mimeTypeFilter = filter2;
    return this;
  }
  /**
   * Add a button to the FilePicker
   * Note: This overrides any previous `setButtonFactory` call
   *
   * @param button The button
   */
  addButton(button) {
    if (typeof this.buttons === "function") {
      console.warn("FilePicker buttons were set to factory, now overwritten with button object.");
      this.buttons = [];
    }
    this.buttons.push(button);
    return this;
  }
  /**
   * Set the button factory which is used to generate buttons from current view, path and selected nodes
   * Note: This overrides any previous `addButton` call
   *
   * @param factory The button factory
   */
  setButtonFactory(factory) {
    this.buttons = factory;
    return this;
  }
  /**
   * Set FilePicker type based on legacy file picker types
   * @param type The legacy filepicker type to emulate
   * @deprecated Use `addButton` or `setButtonFactory` instead as with setType you do not know which button was pressed
   */
  setType(type) {
    this.buttons = (nodes, path2) => {
      var _a, _b, _c;
      const buttons = [];
      const node = ((_b = (_a = nodes == null ? void 0 : nodes[0]) == null ? void 0 : _a.attributes) == null ? void 0 : _b.displayName) || ((_c = nodes == null ? void 0 : nodes[0]) == null ? void 0 : _c.basename);
      const target = node || pathBrowserify.basename(path2);
      if (type === 1) {
        let label = t$1("Choose");
        if (nodes.length === 1) {
          label = t$1("Choose {file}", { file: node });
        } else if (this.multiSelect) {
          label = n$1("Choose %n file", "Choose %n files", nodes.length);
        }
        buttons.push({
          callback: () => {
          },
          type: "primary",
          label
        });
      }
      if (type === 4 || type === 3) {
        buttons.push({
          callback: () => {
          },
          label: target ? t$1("Copy to {target}", { target }) : t$1("Copy"),
          type: "primary",
          icon: IconCopy
        });
      }
      if (type === 2 || type === 4) {
        buttons.push({
          callback: () => {
          },
          label: target ? t$1("Move to {target}", { target }) : t$1("Move"),
          type: type === 2 ? "primary" : "secondary",
          icon: IconMove
        });
      }
      return buttons;
    };
    return this;
  }
  /**
   * Allow to pick directories besides files
   *
   * @param allow True to allow picking directories
   */
  allowDirectories(allow = true) {
    this.directoriesAllowed = allow;
    return this;
  }
  /**
   * Set starting path of the FilePicker
   *
   * @param path Path to start from picking
   */
  startAt(path2) {
    this.path = path2;
    return this;
  }
  /**
   * Add filter function to filter file list of FilePicker
   *
   * @param filter Filter function to apply
   */
  setFilter(filter2) {
    this.filter = filter2;
    return this;
  }
  /**
   * Allow to pick directories besides files
   *
   * @param allow True to allow picking directories
   */
  disableNavigation() {
    this.disabledNavigation = true;
    return this;
  }
  /**
   * Construct the configured FilePicker
   */
  build() {
    return new FilePicker(
      this.title,
      this.multiSelect,
      this.mimeTypeFilter,
      this.directoriesAllowed,
      this.buttons,
      this.path,
      this.filter,
      this.container,
      this.disabledNavigation
    );
  }
}
function getFilePickerBuilder(title) {
  return new FilePickerBuilder(title);
}
const _sfc_main$14 = {
  name: "AccountGroupIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$14 = function render11() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon account-group-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,5.5A3.5,3.5 0 0,1 15.5,9A3.5,3.5 0 0,1 12,12.5A3.5,3.5 0 0,1 8.5,9A3.5,3.5 0 0,1 12,5.5M5,8C5.56,8 6.08,8.15 6.53,8.42C6.38,9.85 6.8,11.27 7.66,12.38C7.16,13.34 6.16,14 5,14A3,3 0 0,1 2,11A3,3 0 0,1 5,8M19,8A3,3 0 0,1 22,11A3,3 0 0,1 19,14C17.84,14 16.84,13.34 16.34,12.38C17.2,11.27 17.62,9.85 17.47,8.42C17.92,8.15 18.44,8 19,8M5.5,18.25C5.5,16.18 8.41,14.5 12,14.5C15.59,14.5 18.5,16.18 18.5,18.25V20H5.5V18.25M0,20V18.5C0,17.11 1.89,15.94 4.45,15.6C3.86,16.28 3.5,17.22 3.5,18.25V20H0M24,20H20.5V18.25C20.5,17.22 20.14,16.28 19.55,15.6C22.11,15.94 24,17.11 24,18.5V20Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$14 = [];
var __component__$14 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$14,
  _sfc_render$14,
  _sfc_staticRenderFns$14,
  false,
  null,
  null
);
const AccountGroup = __component__$14.exports;
const _sfc_main$13 = {
  name: "CogIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$13 = function render12() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon cog-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,15.5A3.5,3.5 0 0,1 8.5,12A3.5,3.5 0 0,1 12,8.5A3.5,3.5 0 0,1 15.5,12A3.5,3.5 0 0,1 12,15.5M19.43,12.97C19.47,12.65 19.5,12.33 19.5,12C19.5,11.67 19.47,11.34 19.43,11L21.54,9.37C21.73,9.22 21.78,8.95 21.66,8.73L19.66,5.27C19.54,5.05 19.27,4.96 19.05,5.05L16.56,6.05C16.04,5.66 15.5,5.32 14.87,5.07L14.5,2.42C14.46,2.18 14.25,2 14,2H10C9.75,2 9.54,2.18 9.5,2.42L9.13,5.07C8.5,5.32 7.96,5.66 7.44,6.05L4.95,5.05C4.73,4.96 4.46,5.05 4.34,5.27L2.34,8.73C2.21,8.95 2.27,9.22 2.46,9.37L4.57,11C4.53,11.34 4.5,11.67 4.5,12C4.5,12.33 4.53,12.65 4.57,12.97L2.46,14.63C2.27,14.78 2.21,15.05 2.34,15.27L4.34,18.73C4.46,18.95 4.73,19.03 4.95,18.95L7.44,17.94C7.96,18.34 8.5,18.68 9.13,18.93L9.5,21.58C9.54,21.82 9.75,22 10,22H14C14.25,22 14.46,21.82 14.5,21.58L14.87,18.93C15.5,18.67 16.04,18.34 16.56,17.94L19.05,18.95C19.27,19.03 19.54,18.95 19.66,18.73L21.66,15.27C21.78,15.05 21.73,14.78 21.54,14.63L19.43,12.97Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$13 = [];
var __component__$13 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$13,
  _sfc_render$13,
  _sfc_staticRenderFns$13,
  false,
  null,
  null
);
const Cog = __component__$13.exports;
const _sfc_main$12 = {
  name: "LoginIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$12 = function render13() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon login-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M11 7L9.6 8.4L12.2 11H2V13H12.2L9.6 15.6L11 17L16 12L11 7M20 19H12V21H20C21.1 21 22 20.1 22 19V5C22 3.9 21.1 3 20 3H12V5H20V19Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$12 = [];
var __component__$12 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$12,
  _sfc_render$12,
  _sfc_staticRenderFns$12,
  false,
  null,
  null
);
const Login = __component__$12.exports;
const _sfc_main$11 = {
  name: "LogoutIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$11 = function render14() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon logout-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M17 7L15.59 8.41L18.17 11H8V13H18.17L15.59 15.58L17 17L22 12M4 5H12V3H4C2.9 3 2 3.9 2 5V19C2 20.1 2.9 21 4 21H12V19H4V5Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$11 = [];
var __component__$11 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$11,
  _sfc_render$11,
  _sfc_staticRenderFns$11,
  false,
  null,
  null
);
const Logout = __component__$11.exports;
const CopyToClipboardMixin = {
  data() {
    return {
      copied: false,
      copyLoading: false,
      copySuccess: false
    };
  },
  computed: {
    copyLinkIcon() {
      if (this.copySuccess) {
        return "icon-checkmark";
      }
      if (this.copyLoading) {
        return "icon-loading-small";
      }
      return "icon-public";
    }
  },
  methods: {
    async copyToClipboard(url) {
      this.copyLoading = true;
      try {
        await navigator.clipboard.writeText(url);
        this.copySuccess = true;
        this.copied = true;
        showSuccess(t("contacts", "Link copied to the clipboard"));
      } catch (error) {
        this.copySuccess = false;
        this.copied = true;
        showError(t("contacts", "Could not copy link to the clipboard."));
      } finally {
        this.copyLoading = false;
        setTimeout(() => {
          this.copied = false;
          this.copySuccess = false;
        }, 2e3);
      }
    }
  }
};
const CircleActionsMixin = {
  props: {
    circle: {
      type: Circle,
      required: true
    }
  },
  mixins: [CopyToClipboardMixin],
  data() {
    return {
      loadingAction: false,
      loadingJoin: false
    };
  },
  computed: {
    copyButtonText() {
      if (this.copied) {
        return this.copySuccess ? t("contacts", "Copied") : t("contacts", "Could not copy");
      }
      return t("contacts", "Copy link");
    },
    circleUrl() {
      const route = this.$router.resolve(this.circle.router);
      return window.location.origin + route.href;
    },
    joinButtonTitle() {
      if (this.circle.requireJoinAccept) {
        return t("contacts", "Request to join");
      }
      return t("contacts", "Join team");
    }
  },
  methods: {
    confirmLeaveCircle() {
      window.OC.dialogs.confirmDestructive(
        t("contacts", "You are about to leave {circle}.\nAre you sure?", {
          circle: this.circle.displayName
        }),
        t("contacts", "Please confirm team leave"),
        window.OC.dialogs.YES_NO_BUTTONS,
        this.leaveCircle,
        true
      );
    },
    async leaveCircle(confirm2) {
      if (!confirm2) {
        this.logger.debug("Circle leave cancelled");
        return;
      }
      this.loadingAction = true;
      const member = this.circle.initiator;
      try {
        await this.$store.dispatch("deleteMemberFromCircle", {
          member,
          leave: true
        });
        this.circle.initiator = null;
      } catch (error) {
        console.error("Could not leave the circle", member, error);
        showError(t("contacts", "Could not leave the team {displayName}", this.circle));
      } finally {
        this.loadingAction = false;
      }
    },
    async joinCircle() {
      this.loadingJoin = true;
      try {
        const initiator = await joinCircle(this.circle.id);
        const member = new Member(initiator, this.circle);
        this.circle.initiator = member;
        member.circle.addMember(member);
      } catch (error) {
        showError(t("contacts", "Unable to join the team"));
        console.error("Unable to join the circle", error);
      } finally {
        this.loadingJoin = false;
      }
    },
    confirmDeleteCircle() {
      window.OC.dialogs.confirmDestructive(
        t("contacts", "You are about to delete {circle}.\nAre you sure?", {
          circle: this.circle.displayName
        }),
        t("contacts", "Please confirm team deletion"),
        window.OC.dialogs.YES_NO_BUTTONS,
        this.deleteCircle,
        true
      );
    },
    async deleteCircle(confirm2) {
      if (!confirm2) {
        this.logger.debug("Circle deletion cancelled");
        return;
      }
      this.loadingAction = true;
      try {
        this.$store.dispatch("deleteCircle", this.circle.id);
      } catch (error) {
        showError(t("contacts", "Unable to delete the team"));
      } finally {
        this.loadingAction = false;
      }
    },
    /**
     * Trigger the entity picker view
     */
    async addMemberToCircle() {
      try {
        await this.$router.push(this.circle.router);
      } catch (error) {
      }
      emit("contacts:circles:append", this.circle.id);
    }
  }
};
const _sfc_main$10 = {
  name: "DetailsHeader",
  components: {
    Actions: NcActions
  },
  data() {
    return {
      avatarSize: 75
    };
  },
  computed: {
    cssStyle() {
      return {
        "--avatar-size": this.avatarSize + "px"
      };
    }
  }
};
var _sfc_render$10 = function render15() {
  var _vm = this, _c = _vm._self._c;
  return _c("header", { staticClass: "contact-header", style: _vm.cssStyle }, [_c("div", { staticClass: "contact-header__no-wrap" }, [_c("div", { staticClass: "contact-header__avatar" }, [_vm._t("avatar", null, { "avatarSize": _vm.avatarSize })], 2), _c("div", { staticClass: "contact-header__infos" }, [_c("h2", { staticClass: "contact-header__infos-title" }, [_vm._t("title")], 2), _vm.$slots.subtitle ? _c("div", { staticClass: "contact-header__infos-subtitle" }, [_vm._t("subtitle")], 2) : _vm._e(), _c("div", { staticClass: "contact-header__quick-actions" }, [_vm._t("quick-actions")], 2)])]), _c("div", { staticClass: "contact-header__actions" }, [_vm._t("actions"), _c("Actions", _vm._b({ ref: "actions", staticClass: "header-menu", attrs: { "menu-align": "right" } }, "Actions", _vm.$attrs, false), [_vm._t("actions-menu")], 2)], 2)]);
};
var _sfc_staticRenderFns$10 = [];
var __component__$10 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$10,
  _sfc_render$10,
  _sfc_staticRenderFns$10,
  false,
  null,
  "e422f1ab"
);
const DetailsHeader = __component__$10.exports;
const _sfc_main$$ = {
  name: "ContentHeading",
  props: {
    loading: {
      type: Boolean,
      default: false
    }
  }
};
var _sfc_render$$ = function render16() {
  var _vm = this, _c = _vm._self._c;
  return _c("h3", { staticClass: "app-content-heading" }, [_vm._t("default"), _vm.loading ? _c("div", { staticClass: "app-content-heading__loader icon-loading-small" }) : _vm._e()], 2);
};
var _sfc_staticRenderFns$$ = [];
var __component__$$ = /* @__PURE__ */ normalizeComponent(
  _sfc_main$$,
  _sfc_render$$,
  _sfc_staticRenderFns$$,
  false,
  null,
  "1296536b"
);
const ContentHeading = __component__$$.exports;
const _sfc_main$_ = {
  name: "CircleConfigs",
  components: {
    CheckboxRadioSwitch: NcCheckboxRadioSwitch,
    ContentHeading
  },
  props: {
    circle: {
      type: Circle,
      required: true
    }
  },
  data() {
    return {
      PUBLIC_CIRCLE_CONFIG,
      loading: false
    };
  },
  methods: {
    isChecked(config) {
      return (this.circle.config & config) !== 0;
    },
    /**
     * On toggle, add or remove the config bitwise
     *
     * @param {CircleConfig} config the circle config to manage
     * @param {boolean} checked checked or not
     */
    async onChange(config, checked) {
      this.logger.debug(`Circle config ${config} is set to ${checked}`);
      this.loading = config;
      const prevConfig = this.circle.config;
      if (checked) {
        config = prevConfig | config;
      } else {
        config = prevConfig & ~config;
      }
      try {
        const circleData = await editCircle(this.circle.id, CircleEdit.Config, config);
        this.circle.config = circleData.config;
      } catch (error) {
        console.error("Unable to edit circle config", prevConfig, config, error);
        showError(t("contacts", "An error happened during the config change"));
      } finally {
        this.loading = false;
      }
    }
  }
};
var _sfc_render$_ = function render17() {
  var _vm = this, _c = _vm._self._c;
  return _c("ul", _vm._l(_vm.PUBLIC_CIRCLE_CONFIG, function(configs, title) {
    return _c("li", { key: title, staticClass: "circle-config" }, [_c("ContentHeading", { staticClass: "circle-config__title" }, [_vm._v(" " + _vm._s(title) + " ")]), _c("ul", { staticClass: "circle-config__list" }, _vm._l(configs, function(label, config) {
      return _c("CheckboxRadioSwitch", { key: "circle-config" + config, attrs: { "checked": _vm.isChecked(config), "loading": _vm.loading === config, "disabled": _vm.loading !== false, "wrapper-element": "li" }, on: { "update:checked": function($event) {
        return _vm.onChange(config, $event);
      } } }, [_vm._v(" " + _vm._s(label) + " ")]);
    }), 1)], 1);
  }), 0);
};
var _sfc_staticRenderFns$_ = [];
var __component__$_ = /* @__PURE__ */ normalizeComponent(
  _sfc_main$_,
  _sfc_render$_,
  _sfc_staticRenderFns$_,
  false,
  null,
  "4e2fc442"
);
const CircleConfigs = __component__$_.exports;
const _sfc_main$Z = {
  name: "CheckIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$Z = function render18() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon check-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$Z = [];
var __component__$Z = /* @__PURE__ */ normalizeComponent(
  _sfc_main$Z,
  _sfc_render$Z,
  _sfc_staticRenderFns$Z,
  false,
  null,
  null
);
const CheckIcon = __component__$Z.exports;
const _sfc_main$Y = {
  name: "CloseIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$Y = function render19() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon close-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$Y = [];
var __component__$Y = /* @__PURE__ */ normalizeComponent(
  _sfc_main$Y,
  _sfc_render$Y,
  _sfc_staticRenderFns$Y,
  false,
  null,
  null
);
const IconClose = __component__$Y.exports;
const _sfc_main$X = {
  name: "ExitToAppIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$X = function render20() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon exit-to-app-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19,3H5C3.89,3 3,3.89 3,5V9H5V5H19V19H5V15H3V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5C21,3.89 20.1,3 19,3M10.08,15.58L11.5,17L16.5,12L11.5,7L10.08,8.41L12.67,11H3V13H12.67L10.08,15.58Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$X = [];
var __component__$X = /* @__PURE__ */ normalizeComponent(
  _sfc_main$X,
  _sfc_render$X,
  _sfc_staticRenderFns$X,
  false,
  null,
  null
);
const ExitToApp = __component__$X.exports;
const _sfc_main$W = {
  name: "ShieldCheckIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$W = function render21() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon shield-check-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M10,17L6,13L7.41,11.59L10,14.17L16.59,7.58L18,9M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$W = [];
var __component__$W = /* @__PURE__ */ normalizeComponent(
  _sfc_main$W,
  _sfc_render$W,
  _sfc_staticRenderFns$W,
  false,
  null,
  null
);
const IconShieldCheck = __component__$W.exports;
const RouterMixin = {
  computed: {
    // router variables
    selectedContact() {
      return this.$route.params.selectedContact;
    },
    selectedGroup() {
      return this.$route.params.selectedGroup;
    },
    selectedCircle() {
      return this.$route.params.selectedCircle;
    }
  }
};
const _sfc_main$V = {
  name: "MemberListItem",
  components: {
    IconCheck: CheckIcon,
    IconClose,
    IconDelete,
    IconExitToApp: ExitToApp,
    IconShieldCheck,
    NcListItem,
    NcActionButton,
    NcActionSeparator,
    NcActionText,
    NcAvatar
  },
  mixins: [RouterMixin],
  props: {
    source: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      loading: false
    };
  },
  computed: {
    /**
     * Return the current circle
     *
     * @return {Circle}
     */
    circle() {
      return this.$store.getters.getCircle(this.selectedCircle);
    },
    /**
     * Current member level translated name
     *
     * @return {string}
     */
    levelName() {
      if (this.source.level === MemberLevels.NONE) {
        return t("contacts", "Pending");
      }
      return CIRCLES_MEMBER_LEVELS[this.source.level] || CIRCLES_MEMBER_LEVELS[MemberLevels.MEMBER];
    },
    /**
     * Current user member level
     *
     * @return {number}
     */
    currentUserLevel() {
      return this.circle?.initiator?.level || MemberLevels.MEMBER;
    },
    /**
     * Current user member level
     *
     * @return {string}
     */
    currentUserId() {
      return this.circle?.initiator?.singleId;
    },
    /**
     * Available levels change to the current user
     *
     * @return {Array}
     */
    availableLevelsChange() {
      const levels = Object.keys(CIRCLES_MEMBER_LEVELS).map((level) => parseInt(level, 10)).filter((level) => level < this.currentUserLevel);
      if (this.currentUserLevel === MemberLevels.ADMIN) {
        levels.push(MemberLevels.ADMIN);
      }
      if (this.circle.isOwner) {
        levels.push(MemberLevels.OWNER);
      }
      return levels.filter((level) => level !== this.source.level);
    },
    /**
     * Is the current member the current user?
     *
     * @return {boolean}
     */
    isCurrentUser() {
      return this.currentUserId === this.source.singleId;
    },
    /**
     * Is the current member pending moderator approval?
     *
     * @return {boolean}
     */
    isPendingApproval() {
      return this.source?.level === MemberLevels.NONE && this.source?.status === MemberStatus.REQUESTING;
    },
    /**
     * Can the current user change the level of others?
     *
     * @return {boolean}
     */
    canChangeLevel() {
      return this.source.level > MemberLevels.NONE && this.availableLevelsChange.length > 0 && this.currentUserLevel >= this.source.level && this.circle.canManageMembers && !(this.circle.isOwner && this.isCurrentUser);
    },
    /**
     * Can the current user delete members or?
     *
     * @return {boolean}
     */
    canDelete() {
      return this.circle.canManageMembers && this.source.level <= this.currentUserLevel && !this.isCurrentUser;
    },
    avatarSize() {
      return parseInt(window.getComputedStyle(document.body).getPropertyValue("--default-clickable-area"));
    }
  },
  methods: {
    /**
     * Return the promote/demote member action label
     *
     * @param {MemberLevel} level the member level
     * @return {string}
     */
    levelChangeLabel(level) {
      if (level === MemberLevels.OWNER) {
        return t("contacts", "Promote as sole owner");
      }
      if (this.source.level < level) {
        return t("contacts", "Promote to {level}", { level: CIRCLES_MEMBER_LEVELS[level] });
      }
      return t("contacts", "Demote to {level}", { level: CIRCLES_MEMBER_LEVELS[level] });
    },
    /**
     * Delete the current member
     */
    async deleteMember() {
      this.loading = true;
      try {
        await this.$store.dispatch("deleteMemberFromCircle", {
          member: this.source,
          leave: this.isCurrentUser
        });
      } catch (error) {
        if (error?.response?.status === 404) {
          this.logger.debug("Member is not in circle");
          return;
        }
        console.error("Could not delete the member", this.source, error);
        showError(t("contacts", "Could not delete the member {displayName}", this.source));
      } finally {
        this.loading = false;
      }
    },
    async changeLevel(level) {
      this.loading = true;
      try {
        await changeMemberLevel(this.circle.id, this.source.id, level);
        this.showLevelMenu = false;
        if (level === MemberLevels.OWNER) {
          await this.$store.dispatch("getCircle", this.circle.id);
          await this.$store.dispatch("getCircleMembers", this.circle.id);
          return;
        }
        this.source.level = level;
      } catch (error) {
        console.error("Could not change the member level to", CIRCLES_MEMBER_LEVELS[level]);
        showError(t("contacts", "Could not change the member level to {level}", {
          level: CIRCLES_MEMBER_LEVELS[level]
        }));
      } finally {
        this.loading = false;
      }
    },
    async acceptMember() {
      this.loading = true;
      try {
        await await this.$store.dispatch("acceptCircleMember", {
          circleId: this.circle.id,
          memberId: this.source.id
        });
      } catch (error) {
        console.error("Could not accept membership request", this.source, error);
        showError(t("contacts", "Could not accept membership request"));
      } finally {
        this.loading = false;
      }
    },
    /**
     * Reset menu on close
     */
    onMenuClose() {
      this.showLevelMenu = false;
    }
  }
};
var _sfc_render$V = function render23() {
  var _vm = this, _c = _vm._self._c;
  return _c("NcListItem", { staticClass: "members-list-item", attrs: { "compact": "", "name": _vm.source.displayName }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("NcAvatar", { attrs: { "disable-menu": "", "size": _vm.avatarSize, "display-name": _vm.source.displayName, "is-no-user": !_vm.source.isUser } })];
  }, proxy: true }, { key: "subname", fn: function() {
    return [_vm._v(" " + _vm._s(_vm.levelName) + " ")];
  }, proxy: true }, !_vm.loading && _vm.isPendingApproval && _vm.circle.canManageMembers ? { key: "extra-actions", fn: function() {
    return [_c("NcButton", { on: { "click": _vm.acceptMember }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconCheck", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 905113861) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Accept membership request")) + " ")]), _c("NcButton", { on: { "click": _vm.deleteMember }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconClose", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 2888946197) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Reject membership request")) + " ")])];
  }, proxy: true } : { key: "actions", fn: function() {
    return [_vm.loading ? _c("NcActionText", { attrs: { "icon": "icon-loading-small" } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Loading ")) + " ")]) : [_vm.canChangeLevel ? [_c("NcActionText", { scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconShieldCheck", { attrs: { "size": 16 } })];
    }, proxy: true }], null, false, 3970731743) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Manage level")) + " ")]), _vm._l(_vm.availableLevelsChange, function(level) {
      return _c("NcActionButton", { key: level, attrs: { "icon": "" }, on: { "click": function($event) {
        return _vm.changeLevel(level);
      } } }, [_vm._v(" " + _vm._s(_vm.levelChangeLabel(level)) + " ")]);
    }), _c("NcActionSeparator")] : _vm._e(), _vm.isCurrentUser && !_vm.circle.isOwner ? _c("NcActionButton", { on: { "click": _vm.deleteMember }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconExitToApp", { attrs: { "size": 16 } })];
    }, proxy: true }], null, false, 1644731612) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Leave team")) + " ")]) : _vm.canDelete ? _c("NcActionButton", { on: { "click": _vm.deleteMember }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconDelete", { attrs: { "size": 20 } })];
    }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Remove member")) + " ")]) : _vm._e()]];
  }, proxy: true }], null, true) });
};
var _sfc_staticRenderFns$V = [];
var __component__$V = /* @__PURE__ */ normalizeComponent(
  _sfc_main$V,
  _sfc_render$V,
  _sfc_staticRenderFns$V,
  false,
  null,
  null
);
const MemberListItem = __component__$V.exports;
/*! third party licenses: js/vendor.LICENSE.txt */
const _sfc_main$U = /* @__PURE__ */ defineComponent({
  __name: "MemberListGroup",
  props: {
    label: null,
    type: null,
    members: null
  },
  setup(__props) {
    return { __sfc: true, MemberListItem };
  }
});
var _sfc_render$U = function render24() {
  var _vm = this, _c = _vm._self._c, _setup = _vm._self._setupProxy;
  return _c("div", { staticClass: "member-list-group" }, [_c("h4", { staticClass: "member-list-group__heading", attrs: { "id": `member-list-group-${_vm.type}` } }, [_vm._v(" " + _vm._s(_vm.label) + " ")]), _c("ul", { staticClass: "member-list-group__list", attrs: { "aria-labelledby": `member-list-group-${_vm.type}` } }, _vm._l(_vm.members, function(member) {
    return _c(_setup.MemberListItem, { key: member.singleId, attrs: { "source": member } });
  }), 1)]);
};
var _sfc_staticRenderFns$U = [];
var __component__$U = /* @__PURE__ */ normalizeComponent(
  _sfc_main$U,
  _sfc_render$U,
  _sfc_staticRenderFns$U,
  false,
  null,
  "5cc5fa63"
);
const MemberListGroup = __component__$U.exports;
var dist$1 = { exports: {} };
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(vue_runtime_esm);
/*!
 * vue-virtual-scroll-list v2.3.4
 * open source under the MIT license
 * https://github.com/tangbc/vue-virtual-scroll-list#readme
 */
(function(module2, exports) {
  (function(global, factory) {
    module2.exports = factory(require$$0);
  })(commonjsGlobal, function(Vue2) {
    Vue2 = Vue2 && Object.prototype.hasOwnProperty.call(Vue2, "default") ? Vue2["default"] : Vue2;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2) return;
      if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var DIRECTION_TYPE = {
      FRONT: "FRONT",
      // scroll up or left
      BEHIND: "BEHIND"
      // scroll down or right
    };
    var CALC_TYPE = {
      INIT: "INIT",
      FIXED: "FIXED",
      DYNAMIC: "DYNAMIC"
    };
    var LEADING_BUFFER = 0;
    var Virtual = /* @__PURE__ */ function() {
      function Virtual2(param, callUpdate) {
        _classCallCheck(this, Virtual2);
        this.init(param, callUpdate);
      }
      _createClass(Virtual2, [{
        key: "init",
        value: function init2(param, callUpdate) {
          this.param = param;
          this.callUpdate = callUpdate;
          this.sizes = /* @__PURE__ */ new Map();
          this.firstRangeTotalSize = 0;
          this.firstRangeAverageSize = 0;
          this.fixedSizeValue = 0;
          this.calcType = CALC_TYPE.INIT;
          this.offset = 0;
          this.direction = "";
          this.range = /* @__PURE__ */ Object.create(null);
          if (param) {
            this.checkRange(0, param.keeps - 1);
          }
        }
      }, {
        key: "destroy",
        value: function destroy2() {
          this.init(null, null);
        }
        // return current render range
      }, {
        key: "getRange",
        value: function getRange() {
          var range = /* @__PURE__ */ Object.create(null);
          range.start = this.range.start;
          range.end = this.range.end;
          range.padFront = this.range.padFront;
          range.padBehind = this.range.padBehind;
          return range;
        }
      }, {
        key: "isBehind",
        value: function isBehind() {
          return this.direction === DIRECTION_TYPE.BEHIND;
        }
      }, {
        key: "isFront",
        value: function isFront() {
          return this.direction === DIRECTION_TYPE.FRONT;
        }
        // return start index offset
      }, {
        key: "getOffset",
        value: function getOffset(start2) {
          return (start2 < 1 ? 0 : this.getIndexOffset(start2)) + this.param.slotHeaderSize;
        }
      }, {
        key: "updateParam",
        value: function updateParam(key, value) {
          var _this = this;
          if (this.param && key in this.param) {
            if (key === "uniqueIds") {
              this.sizes.forEach(function(v2, key2) {
                if (!value.includes(key2)) {
                  _this.sizes["delete"](key2);
                }
              });
            }
            this.param[key] = value;
          }
        }
        // save each size map by id
      }, {
        key: "saveSize",
        value: function saveSize(id2, size) {
          this.sizes.set(id2, size);
          if (this.calcType === CALC_TYPE.INIT) {
            this.fixedSizeValue = size;
            this.calcType = CALC_TYPE.FIXED;
          } else if (this.calcType === CALC_TYPE.FIXED && this.fixedSizeValue !== size) {
            this.calcType = CALC_TYPE.DYNAMIC;
            delete this.fixedSizeValue;
          }
          if (this.calcType !== CALC_TYPE.FIXED && typeof this.firstRangeTotalSize !== "undefined") {
            if (this.sizes.size < Math.min(this.param.keeps, this.param.uniqueIds.length)) {
              this.firstRangeTotalSize = _toConsumableArray(this.sizes.values()).reduce(function(acc, val) {
                return acc + val;
              }, 0);
              this.firstRangeAverageSize = Math.round(this.firstRangeTotalSize / this.sizes.size);
            } else {
              delete this.firstRangeTotalSize;
            }
          }
        }
        // in some special situation (e.g. length change) we need to update in a row
        // try goiong to render next range by a leading buffer according to current direction
      }, {
        key: "handleDataSourcesChange",
        value: function handleDataSourcesChange() {
          var start2 = this.range.start;
          if (this.isFront()) {
            start2 = start2 - LEADING_BUFFER;
          } else if (this.isBehind()) {
            start2 = start2 + LEADING_BUFFER;
          }
          start2 = Math.max(start2, 0);
          this.updateRange(this.range.start, this.getEndByStart(start2));
        }
        // when slot size change, we also need force update
      }, {
        key: "handleSlotSizeChange",
        value: function handleSlotSizeChange() {
          this.handleDataSourcesChange();
        }
        // calculating range on scroll
      }, {
        key: "handleScroll",
        value: function handleScroll(offset) {
          this.direction = offset < this.offset || offset === 0 ? DIRECTION_TYPE.FRONT : DIRECTION_TYPE.BEHIND;
          this.offset = offset;
          if (!this.param) {
            return;
          }
          if (this.direction === DIRECTION_TYPE.FRONT) {
            this.handleFront();
          } else if (this.direction === DIRECTION_TYPE.BEHIND) {
            this.handleBehind();
          }
        }
        // ----------- public method end -----------
      }, {
        key: "handleFront",
        value: function handleFront() {
          var overs = this.getScrollOvers();
          if (overs > this.range.start) {
            return;
          }
          var start2 = Math.max(overs - this.param.buffer, 0);
          this.checkRange(start2, this.getEndByStart(start2));
        }
      }, {
        key: "handleBehind",
        value: function handleBehind() {
          var overs = this.getScrollOvers();
          if (overs < this.range.start + this.param.buffer) {
            return;
          }
          this.checkRange(overs, this.getEndByStart(overs));
        }
        // return the pass overs according to current scroll offset
      }, {
        key: "getScrollOvers",
        value: function getScrollOvers() {
          var offset = this.offset - this.param.slotHeaderSize;
          if (offset <= 0) {
            return 0;
          }
          if (this.isFixedType()) {
            return Math.floor(offset / this.fixedSizeValue);
          }
          var low = 0;
          var middle = 0;
          var middleOffset = 0;
          var high = this.param.uniqueIds.length;
          while (low <= high) {
            middle = low + Math.floor((high - low) / 2);
            middleOffset = this.getIndexOffset(middle);
            if (middleOffset === offset) {
              return middle;
            } else if (middleOffset < offset) {
              low = middle + 1;
            } else if (middleOffset > offset) {
              high = middle - 1;
            }
          }
          return low > 0 ? --low : 0;
        }
        // return a scroll offset from given index, can efficiency be improved more here?
        // although the call frequency is very high, its only a superposition of numbers
      }, {
        key: "getIndexOffset",
        value: function getIndexOffset(givenIndex) {
          if (!givenIndex) {
            return 0;
          }
          var offset = 0;
          var indexSize = 0;
          for (var index2 = 0; index2 < givenIndex; index2++) {
            indexSize = this.sizes.get(this.param.uniqueIds[index2]);
            offset = offset + (typeof indexSize === "number" ? indexSize : this.getEstimateSize());
          }
          return offset;
        }
        // is fixed size type
      }, {
        key: "isFixedType",
        value: function isFixedType() {
          return this.calcType === CALC_TYPE.FIXED;
        }
        // return the real last index
      }, {
        key: "getLastIndex",
        value: function getLastIndex() {
          return this.param.uniqueIds.length - 1;
        }
        // in some conditions range is broke, we need correct it
        // and then decide whether need update to next range
      }, {
        key: "checkRange",
        value: function checkRange(start2, end) {
          var keeps = this.param.keeps;
          var total = this.param.uniqueIds.length;
          if (total <= keeps) {
            start2 = 0;
            end = this.getLastIndex();
          } else if (end - start2 < keeps - 1) {
            start2 = end - keeps + 1;
          }
          if (this.range.start !== start2) {
            this.updateRange(start2, end);
          }
        }
        // setting to a new range and rerender
      }, {
        key: "updateRange",
        value: function updateRange(start2, end) {
          this.range.start = start2;
          this.range.end = end;
          this.range.padFront = this.getPadFront();
          this.range.padBehind = this.getPadBehind();
          this.callUpdate(this.getRange());
        }
        // return end base on start
      }, {
        key: "getEndByStart",
        value: function getEndByStart(start2) {
          var theoryEnd = start2 + this.param.keeps - 1;
          var truelyEnd = Math.min(theoryEnd, this.getLastIndex());
          return truelyEnd;
        }
        // return total front offset
      }, {
        key: "getPadFront",
        value: function getPadFront() {
          if (this.isFixedType()) {
            return this.fixedSizeValue * this.range.start;
          } else {
            return this.getIndexOffset(this.range.start);
          }
        }
        // return total behind offset
      }, {
        key: "getPadBehind",
        value: function getPadBehind() {
          var end = this.range.end;
          var lastIndex = this.getLastIndex();
          if (this.isFixedType()) {
            return (lastIndex - end) * this.fixedSizeValue;
          }
          return (lastIndex - end) * this.getEstimateSize();
        }
        // get the item estimate size
      }, {
        key: "getEstimateSize",
        value: function getEstimateSize() {
          return this.isFixedType() ? this.fixedSizeValue : this.firstRangeAverageSize || this.param.estimateSize;
        }
      }]);
      return Virtual2;
    }();
    var VirtualProps = {
      dataKey: {
        type: [String, Function],
        required: true
      },
      dataSources: {
        type: Array,
        required: true
      },
      dataComponent: {
        type: [Object, Function],
        required: true
      },
      keeps: {
        type: Number,
        "default": 30
      },
      extraProps: {
        type: Object
      },
      estimateSize: {
        type: Number,
        "default": 50
      },
      direction: {
        type: String,
        "default": "vertical"
        // the other value is horizontal
      },
      start: {
        type: Number,
        "default": 0
      },
      offset: {
        type: Number,
        "default": 0
      },
      topThreshold: {
        type: Number,
        "default": 0
      },
      bottomThreshold: {
        type: Number,
        "default": 0
      },
      pageMode: {
        type: Boolean,
        "default": false
      },
      rootTag: {
        type: String,
        "default": "div"
      },
      wrapTag: {
        type: String,
        "default": "div"
      },
      wrapClass: {
        type: String,
        "default": ""
      },
      wrapStyle: {
        type: Object
      },
      itemTag: {
        type: String,
        "default": "div"
      },
      itemClass: {
        type: String,
        "default": ""
      },
      itemClassAdd: {
        type: Function
      },
      itemStyle: {
        type: Object
      },
      headerTag: {
        type: String,
        "default": "div"
      },
      headerClass: {
        type: String,
        "default": ""
      },
      headerStyle: {
        type: Object
      },
      footerTag: {
        type: String,
        "default": "div"
      },
      footerClass: {
        type: String,
        "default": ""
      },
      footerStyle: {
        type: Object
      },
      itemScopedSlots: {
        type: Object
      }
    };
    var ItemProps = {
      index: {
        type: Number
      },
      event: {
        type: String
      },
      tag: {
        type: String
      },
      horizontal: {
        type: Boolean
      },
      source: {
        type: Object
      },
      component: {
        type: [Object, Function]
      },
      slotComponent: {
        type: Function
      },
      uniqueKey: {
        type: [String, Number]
      },
      extraProps: {
        type: Object
      },
      scopedSlots: {
        type: Object
      }
    };
    var SlotProps = {
      event: {
        type: String
      },
      uniqueKey: {
        type: String
      },
      tag: {
        type: String
      },
      horizontal: {
        type: Boolean
      }
    };
    var Wrapper = {
      created: function created() {
        this.shapeKey = this.horizontal ? "offsetWidth" : "offsetHeight";
      },
      mounted: function mounted2() {
        var _this = this;
        if (typeof ResizeObserver !== "undefined") {
          this.resizeObserver = new ResizeObserver(function() {
            _this.dispatchSizeChange();
          });
          this.resizeObserver.observe(this.$el);
        }
      },
      // since componet will be reused, so disptach when updated
      updated: function updated() {
        this.resizeObserver.observe(this.$el);
      },
      beforeDestroy: function beforeDestroy() {
        if (this.resizeObserver) {
          this.resizeObserver.disconnect();
          this.resizeObserver = null;
        }
      },
      methods: {
        getCurrentSize: function getCurrentSize() {
          return this.$el ? this.$el[this.shapeKey] : 0;
        },
        // tell parent current size identify by unqiue key
        dispatchSizeChange: function dispatchSizeChange() {
          this.$parent.$emit(this.event, this.uniqueKey, this.getCurrentSize(), this.hasInitial);
        }
      }
    };
    var Item = Vue2.component("virtual-list-item", {
      mixins: [Wrapper],
      props: ItemProps,
      render: function render82(h) {
        var tag = this.tag, component = this.component, _this$extraProps = this.extraProps, extraProps = _this$extraProps === void 0 ? {} : _this$extraProps, index2 = this.index, source = this.source, _this$scopedSlots = this.scopedSlots, scopedSlots = _this$scopedSlots === void 0 ? {} : _this$scopedSlots, uniqueKey = this.uniqueKey, slotComponent = this.slotComponent;
        var props = _objectSpread2(_objectSpread2({}, extraProps), {}, {
          source,
          index: index2
        });
        return h(tag, {
          key: uniqueKey,
          attrs: {
            role: "listitem"
          }
        }, [slotComponent ? slotComponent({
          item: source,
          index: index2,
          scope: props
        }) : h(component, {
          props,
          scopedSlots
        })]);
      }
    });
    var Slot = Vue2.component("virtual-list-slot", {
      mixins: [Wrapper],
      props: SlotProps,
      render: function render82(h) {
        var tag = this.tag, uniqueKey = this.uniqueKey;
        return h(tag, {
          key: uniqueKey,
          attrs: {
            role: uniqueKey
          }
        }, this.$slots["default"]);
      }
    });
    var EVENT_TYPE = {
      ITEM: "item_resize",
      SLOT: "slot_resize"
    };
    var SLOT_TYPE = {
      HEADER: "thead",
      // string value also use for aria role attribute
      FOOTER: "tfoot"
    };
    var VirtualList2 = Vue2.component("virtual-list", {
      props: VirtualProps,
      data: function data() {
        return {
          range: null
        };
      },
      watch: {
        "dataSources.length": function dataSourcesLength() {
          this.virtual.updateParam("uniqueIds", this.getUniqueIdFromDataSources());
          this.virtual.handleDataSourcesChange();
        },
        keeps: function keeps(newValue) {
          this.virtual.updateParam("keeps", newValue);
          this.virtual.handleSlotSizeChange();
        },
        start: function start2(newValue) {
          this.scrollToIndex(newValue);
        },
        offset: function offset(newValue) {
          this.scrollToOffset(newValue);
        }
      },
      created: function created() {
        this.isHorizontal = this.direction === "horizontal";
        this.directionKey = this.isHorizontal ? "scrollLeft" : "scrollTop";
        this.installVirtual();
        this.$on(EVENT_TYPE.ITEM, this.onItemResized);
        if (this.$slots.header || this.$slots.footer) {
          this.$on(EVENT_TYPE.SLOT, this.onSlotResized);
        }
      },
      activated: function activated() {
        this.scrollToOffset(this.virtual.offset);
        if (this.pageMode) {
          document.addEventListener("scroll", this.onScroll, {
            passive: false
          });
        }
      },
      deactivated: function deactivated() {
        if (this.pageMode) {
          document.removeEventListener("scroll", this.onScroll);
        }
      },
      mounted: function mounted2() {
        if (this.start) {
          this.scrollToIndex(this.start);
        } else if (this.offset) {
          this.scrollToOffset(this.offset);
        }
        if (this.pageMode) {
          this.updatePageModeFront();
          document.addEventListener("scroll", this.onScroll, {
            passive: false
          });
        }
      },
      beforeDestroy: function beforeDestroy() {
        this.virtual.destroy();
        if (this.pageMode) {
          document.removeEventListener("scroll", this.onScroll);
        }
      },
      methods: {
        // get item size by id
        getSize: function getSize(id2) {
          return this.virtual.sizes.get(id2);
        },
        // get the total number of stored (rendered) items
        getSizes: function getSizes() {
          return this.virtual.sizes.size;
        },
        // return current scroll offset
        getOffset: function getOffset() {
          if (this.pageMode) {
            return document.documentElement[this.directionKey] || document.body[this.directionKey];
          } else {
            var root2 = this.$refs.root;
            return root2 ? Math.ceil(root2[this.directionKey]) : 0;
          }
        },
        // return client viewport size
        getClientSize: function getClientSize() {
          var key = this.isHorizontal ? "clientWidth" : "clientHeight";
          if (this.pageMode) {
            return document.documentElement[key] || document.body[key];
          } else {
            var root2 = this.$refs.root;
            return root2 ? Math.ceil(root2[key]) : 0;
          }
        },
        // return all scroll size
        getScrollSize: function getScrollSize() {
          var key = this.isHorizontal ? "scrollWidth" : "scrollHeight";
          if (this.pageMode) {
            return document.documentElement[key] || document.body[key];
          } else {
            var root2 = this.$refs.root;
            return root2 ? Math.ceil(root2[key]) : 0;
          }
        },
        // set current scroll position to a expectant offset
        scrollToOffset: function scrollToOffset(offset) {
          if (this.pageMode) {
            document.body[this.directionKey] = offset;
            document.documentElement[this.directionKey] = offset;
          } else {
            var root2 = this.$refs.root;
            if (root2) {
              root2[this.directionKey] = offset;
            }
          }
        },
        // set current scroll position to a expectant index
        scrollToIndex: function scrollToIndex(index2) {
          if (index2 >= this.dataSources.length - 1) {
            this.scrollToBottom();
          } else {
            var offset = this.virtual.getOffset(index2);
            this.scrollToOffset(offset);
          }
        },
        // set current scroll position to bottom
        scrollToBottom: function scrollToBottom() {
          var _this = this;
          var shepherd = this.$refs.shepherd;
          if (shepherd) {
            var offset = shepherd[this.isHorizontal ? "offsetLeft" : "offsetTop"];
            this.scrollToOffset(offset);
            setTimeout(function() {
              if (_this.getOffset() + _this.getClientSize() + 1 < _this.getScrollSize()) {
                _this.scrollToBottom();
              }
            }, 3);
          }
        },
        // when using page mode we need update slot header size manually
        // taking root offset relative to the browser as slot header size
        updatePageModeFront: function updatePageModeFront() {
          var root2 = this.$refs.root;
          if (root2) {
            var rect = root2.getBoundingClientRect();
            var defaultView2 = root2.ownerDocument.defaultView;
            var offsetFront = this.isHorizontal ? rect.left + defaultView2.pageXOffset : rect.top + defaultView2.pageYOffset;
            this.virtual.updateParam("slotHeaderSize", offsetFront);
          }
        },
        // reset all state back to initial
        reset: function reset2() {
          this.virtual.destroy();
          this.scrollToOffset(0);
          this.installVirtual();
        },
        // ----------- public method end -----------
        installVirtual: function installVirtual() {
          this.virtual = new Virtual({
            slotHeaderSize: 0,
            slotFooterSize: 0,
            keeps: this.keeps,
            estimateSize: this.estimateSize,
            buffer: Math.round(this.keeps / 3),
            // recommend for a third of keeps
            uniqueIds: this.getUniqueIdFromDataSources()
          }, this.onRangeChanged);
          this.range = this.virtual.getRange();
        },
        getUniqueIdFromDataSources: function getUniqueIdFromDataSources() {
          var dataKey = this.dataKey;
          return this.dataSources.map(function(dataSource) {
            return typeof dataKey === "function" ? dataKey(dataSource) : dataSource[dataKey];
          });
        },
        // event called when each item mounted or size changed
        onItemResized: function onItemResized(id2, size) {
          this.virtual.saveSize(id2, size);
          this.$emit("resized", id2, size);
        },
        // event called when slot mounted or size changed
        onSlotResized: function onSlotResized(type, size, hasInit) {
          if (type === SLOT_TYPE.HEADER) {
            this.virtual.updateParam("slotHeaderSize", size);
          } else if (type === SLOT_TYPE.FOOTER) {
            this.virtual.updateParam("slotFooterSize", size);
          }
          if (hasInit) {
            this.virtual.handleSlotSizeChange();
          }
        },
        // here is the rerendering entry
        onRangeChanged: function onRangeChanged(range) {
          this.range = range;
        },
        onScroll: function onScroll(evt) {
          var offset = this.getOffset();
          var clientSize = this.getClientSize();
          var scrollSize = this.getScrollSize();
          if (offset < 0 || offset + clientSize > scrollSize + 1 || !scrollSize) {
            return;
          }
          this.virtual.handleScroll(offset);
          this.emitEvent(offset, clientSize, scrollSize, evt);
        },
        // emit event in special position
        emitEvent: function emitEvent(offset, clientSize, scrollSize, evt) {
          this.$emit("scroll", evt, this.virtual.getRange());
          if (this.virtual.isFront() && !!this.dataSources.length && offset - this.topThreshold <= 0) {
            this.$emit("totop");
          } else if (this.virtual.isBehind() && offset + clientSize + this.bottomThreshold >= scrollSize) {
            this.$emit("tobottom");
          }
        },
        // get the real render slots based on range data
        // in-place patch strategy will try to reuse components as possible
        // so those components that are reused will not trigger lifecycle mounted
        getRenderSlots: function getRenderSlots(h) {
          var slots = [];
          var _this$range = this.range, start2 = _this$range.start, end = _this$range.end;
          var dataSources = this.dataSources, dataKey = this.dataKey, itemClass = this.itemClass, itemTag = this.itemTag, itemStyle = this.itemStyle, isHorizontal = this.isHorizontal, extraProps = this.extraProps, dataComponent = this.dataComponent, itemScopedSlots = this.itemScopedSlots;
          var slotComponent = this.$scopedSlots && this.$scopedSlots.item;
          for (var index2 = start2; index2 <= end; index2++) {
            var dataSource = dataSources[index2];
            if (dataSource) {
              var uniqueKey = typeof dataKey === "function" ? dataKey(dataSource) : dataSource[dataKey];
              if (typeof uniqueKey === "string" || typeof uniqueKey === "number") {
                slots.push(h(Item, {
                  props: {
                    index: index2,
                    tag: itemTag,
                    event: EVENT_TYPE.ITEM,
                    horizontal: isHorizontal,
                    uniqueKey,
                    source: dataSource,
                    extraProps,
                    component: dataComponent,
                    slotComponent,
                    scopedSlots: itemScopedSlots
                  },
                  style: itemStyle,
                  "class": "".concat(itemClass).concat(this.itemClassAdd ? " " + this.itemClassAdd(index2) : "")
                }));
              } else {
                console.warn("Cannot get the data-key '".concat(dataKey, "' from data-sources."));
              }
            } else {
              console.warn("Cannot get the index '".concat(index2, "' from data-sources."));
            }
          }
          return slots;
        }
      },
      // render function, a closer-to-the-compiler alternative to templates
      // https://vuejs.org/v2/guide/render-function.html#The-Data-Object-In-Depth
      render: function render82(h) {
        var _this$$slots = this.$slots, header = _this$$slots.header, footer = _this$$slots.footer;
        var _this$range2 = this.range, padFront = _this$range2.padFront, padBehind = _this$range2.padBehind;
        var isHorizontal = this.isHorizontal, pageMode = this.pageMode, rootTag = this.rootTag, wrapTag = this.wrapTag, wrapClass = this.wrapClass, wrapStyle = this.wrapStyle, headerTag = this.headerTag, headerClass = this.headerClass, headerStyle = this.headerStyle, footerTag = this.footerTag, footerClass = this.footerClass, footerStyle = this.footerStyle;
        var paddingStyle = {
          padding: isHorizontal ? "0px ".concat(padBehind, "px 0px ").concat(padFront, "px") : "".concat(padFront, "px 0px ").concat(padBehind, "px")
        };
        var wrapperStyle = wrapStyle ? Object.assign({}, wrapStyle, paddingStyle) : paddingStyle;
        return h(rootTag, {
          ref: "root",
          on: {
            "&scroll": !pageMode && this.onScroll
          }
        }, [
          // header slot
          header ? h(Slot, {
            "class": headerClass,
            style: headerStyle,
            props: {
              tag: headerTag,
              event: EVENT_TYPE.SLOT,
              uniqueKey: SLOT_TYPE.HEADER
            }
          }, header) : null,
          // main list
          h(wrapTag, {
            "class": wrapClass,
            attrs: {
              role: "group"
            },
            style: wrapperStyle
          }, this.getRenderSlots(h)),
          // footer slot
          footer ? h(Slot, {
            "class": footerClass,
            style: footerStyle,
            props: {
              tag: footerTag,
              event: EVENT_TYPE.SLOT,
              uniqueKey: SLOT_TYPE.FOOTER
            }
          }, footer) : null,
          // an empty element use to scroll to bottom
          h("div", {
            ref: "shepherd",
            style: {
              width: isHorizontal ? "0px" : "100%",
              height: isHorizontal ? "100%" : "0px"
            }
          })
        ]);
      }
    });
    return VirtualList2;
  });
})(dist$1);
var distExports = dist$1.exports;
const VirtualList = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
const _sfc_main$T = {
  name: "MagnifyIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$T = function render25() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon magnify-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$T = [];
var __component__$T = /* @__PURE__ */ normalizeComponent(
  _sfc_main$T,
  _sfc_render$T,
  _sfc_staticRenderFns$T,
  false,
  null,
  null
);
const IconSearch = __component__$T.exports;
const _sfc_main$S = {
  name: "EntityBubble",
  components: {
    UserBubble: NcUserBubble
  },
  props: {
    /**
     * Unique id of the entity
     */
    id: {
      type: String,
      required: true
    },
    /**
     * Label of the entity
     */
    label: {
      type: String,
      required: true
    },
    /**
     * Type of the entity. e.g user, circle, group...
     */
    type: {
      type: String,
      required: true
    }
  },
  methods: {
    onDelete() {
      this.$emit("delete", {
        id: this.id,
        type: this.type
      });
    }
  }
};
var _sfc_render$S = function render26() {
  var _vm = this, _c = _vm._self._c;
  return _c("UserBubble", { staticClass: "entity-picker__bubble", attrs: { "margin": 0, "size": 22, "display-name": _vm.label }, scopedSlots: _vm._u([{ key: "name", fn: function() {
    return [_c("a", { staticClass: "entity-picker__bubble-delete icon-close", attrs: { "href": "#", "title": _vm.t("contacts", "Remove {type}", { type: _vm.type }) }, on: { "click": _vm.onDelete } })];
  }, proxy: true }]) });
};
var _sfc_staticRenderFns$S = [];
var __component__$S = /* @__PURE__ */ normalizeComponent(
  _sfc_main$S,
  _sfc_render$S,
  _sfc_staticRenderFns$S,
  false,
  null,
  "ac68ebb0"
);
const EntityBubble = __component__$S.exports;
const _sfc_main$R = {
  name: "EntitySearchResult",
  components: {
    UserBubble: NcUserBubble
  },
  props: {
    source: {
      type: Object,
      default() {
        return {};
      }
    },
    onClick: {
      type: Function,
      default() {
      }
    },
    selection: {
      type: Object,
      default: () => ({})
    }
  },
  computed: {
    isSelected() {
      return this.source.id in this.selection;
    }
  }
};
var _sfc_render$R = function render27() {
  var _vm = this, _c = _vm._self._c;
  return _vm.source.heading ? _c("h4", { key: _vm.source.id, staticClass: "entity-picker__option-caption" }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Add {type}", { type: _vm.source.label.toLowerCase() })) + " ")]) : _c("UserBubble", { staticClass: "entity-picker__bubble", class: { "entity-picker__bubble--selected": _vm.isSelected }, attrs: { "display-name": _vm.source.label, "user": _vm.source.user, "margin": 6, "size": 44, "url": "#" }, on: { "click": function($event) {
    $event.stopPropagation();
    $event.preventDefault();
    return _vm.onClick(_vm.source);
  } }, scopedSlots: _vm._u([{ key: "title", fn: function() {
    return [_c("span", { staticClass: "entity-picker__bubble-checkmark icon-checkmark" })];
  }, proxy: true }]) });
};
var _sfc_staticRenderFns$R = [];
var __component__$R = /* @__PURE__ */ normalizeComponent(
  _sfc_main$R,
  _sfc_render$R,
  _sfc_staticRenderFns$R,
  false,
  null,
  "e0ab897e"
);
const EntitySearchResult = __component__$R.exports;
const _sfc_main$Q = {
  name: "EntityPicker",
  components: {
    EmptyContent: NcEmptyContent,
    EntityBubble,
    IconSearch,
    IconLoading: NcLoadingIcon,
    Modal: NcModal,
    VirtualList
  },
  props: {
    loading: {
      type: Boolean,
      default: false
    },
    /**
     * The types of data within dataSet
     * Array of objects. id must match dataSet entity type
     */
    dataTypes: {
      type: Array,
      required: true,
      validator: (types) => {
        const invalidTypes = types.filter((type) => !type.id && !type.label);
        if (invalidTypes.length > 0) {
          console.error("The following types MUST have a proper id and label key", invalidTypes);
          return false;
        }
        return true;
      }
    },
    /**
     * The data to be used
     */
    dataSet: {
      type: Array,
      required: true,
      validator: (data) => {
        data.forEach((source) => {
          if (!source.id || !source.label) {
            console.error("The following source MUST have a proper id and label key", source);
          }
        });
        return true;
      }
    },
    /**
     * The sorting key for the dataSet
     */
    sort: {
      type: String,
      default: "label"
    },
    /**
     * Confirm button text
     */
    confirmLabel: {
      type: String,
      default: t("contacts", "Add to group")
    },
    /**
     * The input will also filter the dataSet based on the label.
     * If you are using the search event to inject a different dataSet, you can disable this
     */
    internalSearch: {
      type: Boolean,
      default: true
    },
    /**
     * Override the local management of selection
     * You MUST use a sync modifier or the selection will be locked
     */
    selection: {
      type: Object,
      default: null
    }
  },
  data() {
    return {
      searchQuery: "",
      localSelection: {},
      EntitySearchResult
    };
  },
  computed: {
    /**
     * If the selection is set externally, let's use it
     */
    selectionSet: {
      get() {
        if (this.selection !== null) {
          return this.selection;
        }
        return this.localSelection;
      },
      set(selection2) {
        if (this.selection !== null) {
          this.$emit("update:selection", selection2);
        }
        this.localSelection = selection2;
      }
    },
    /**
     * Are we handling a single entity type ?
     *
     * @return {boolean}
     */
    isSingleType() {
      return !(this.dataTypes.length > 1);
    },
    /**
     * Is the current selection empty
     *
     * @return {boolean}
     */
    isEmptySelection() {
      return Object.keys(this.selectionSet).length === 0;
    },
    /**
     * Formatted search input placeholder based on
     * available types
     *
     * @return {string}
     */
    searchPlaceholderTypes() {
      const types = this.dataTypes.map((type) => type.label).join(", ");
      return `${types}`;
    },
    /**
     * Available data based on current search if query
     * is valid, returns default full data et otherwise
     *
     * @return {object[]}
     */
    searchSet() {
      if (this.internalSearch && this.searchQuery && this.searchQuery.trim !== "") {
        return this.dataSet.filter((entity) => {
          return entity.label.toLowerCase().indexOf(this.searchQuery.toLowerCase()) > -1;
        });
      }
      return this.dataSet;
    },
    /**
     * Returns available entities grouped by type(s) if any
     *
     * @return {object[]}
     */
    availableEntities() {
      if (this.isSingleType) {
        return this.searchSet;
      }
      return this.dataTypes.map((type) => {
        const dataSet = this.searchSet.filter((entity) => entity.type === type.id);
        const dataList = [
          {
            id: type.id,
            label: type.label,
            heading: true
          },
          ...dataSet
        ];
        if (dataSet.length === 0) {
          return [];
        }
        return dataList;
      }).flat();
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.$refs.input.focus();
      this.$refs.input.select();
    });
  },
  methods: {
    onCancel() {
      this.$emit("close");
    },
    onSubmit() {
      this.$emit("submit", Object.values(this.selectionSet));
    },
    onSearch: debounce(function() {
      this.$emit("search", this.searchQuery);
    }, 200),
    /**
     * Remove entity from selection
     *
     * @param {object} entity the entity to remove
     */
    onDelete(entity) {
      this.$delete(this.selectionSet, entity.id, entity);
      console.debug("Removing entity from selection", entity);
    },
    /**
     * Add/remove entity from selection
     *
     * @param {object} entity the entity to add
     */
    onClick(entity) {
      if (entity.id in this.selectionSet) {
        this.$delete(this.selectionSet, entity.id);
        console.debug("Removed entity to selection", entity);
        return;
      }
      this.$set(this.selectionSet, entity.id, entity);
      console.debug("Added entity to selection", entity);
    },
    /**
     * Toggle entity from selection
     *
     * @param {object} entity the entity to add/remove
     */
    onToggle(entity) {
      if (entity.id in this.selectionSet) {
        this.onDelete(entity);
      } else {
        this.onPick(entity);
      }
    }
  }
};
var _sfc_render$Q = function render28() {
  var _vm = this, _c = _vm._self._c;
  return _c("Modal", { attrs: { "size": "normal" }, on: { "close": _vm.onCancel } }, [_c("div", { staticClass: "entity-picker" }, [_c("div", { staticClass: "entity-picker__search" }, [_c("div", { staticClass: "entity-picker__search-icon icon-search" }), _c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.searchQuery, expression: "searchQuery" }], ref: "input", staticClass: "entity-picker__search-input", attrs: { "placeholder": _vm.t("contacts", "Search {types}", { types: _vm.searchPlaceholderTypes }), "type": "search" }, domProps: { "value": _vm.searchQuery }, on: { "input": [function($event) {
    if ($event.target.composing) return;
    _vm.searchQuery = $event.target.value;
  }, _vm.onSearch] } })]), _vm.loading ? _c("EmptyContent", { attrs: { "name": _vm.t("contacts", "Loading ") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconLoading", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 3081367109) }) : [Object.keys(_vm.selectionSet).length > 0 ? _c("transition-group", { staticClass: "entity-picker__selection", attrs: { "name": "zoom", "tag": "ul" } }, _vm._l(_vm.selectionSet, function(entity) {
    return _c("EntityBubble", _vm._b({ key: entity.key || `entity-${entity.type}-${entity.id}`, on: { "delete": function($event) {
      return _vm.onDelete(entity);
    } } }, "EntityBubble", entity, false));
  }), 1) : _vm._e(), _vm.dataSet.length === 0 ? _c("EmptyContent", { attrs: { "name": _vm.t("contacts", "Search for people to add") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconSearch", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2588625165) }) : _vm.searchSet.length > 0 && _vm.availableEntities.length > 0 ? _c("VirtualList", { staticClass: "entity-picker__options", attrs: { "data-key": "id", "data-sources": _vm.availableEntities, "data-component": _vm.EntitySearchResult, "estimate-size": 44, "extra-props": { selection: _vm.selectionSet, onClick: _vm.onClick } } }) : _vm.searchQuery ? _c("EmptyContent", { attrs: { "name": _vm.t("contacts", "No results") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconSearch", { attrs: { "size": 20 } })];
  }, proxy: true }]) }) : _vm._e(), _c("div", { staticClass: "entity-picker__navigation" }, [_c("button", { staticClass: "navigation__button-left", attrs: { "disabled": _vm.loading }, on: { "click": _vm.onCancel } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Cancel")) + " ")]), _c("button", { staticClass: "navigation__button-right primary", attrs: { "disabled": _vm.isEmptySelection || _vm.loading }, on: { "click": _vm.onSubmit } }, [_vm._v(" " + _vm._s(_vm.confirmLabel) + " ")])])]], 2)]);
};
var _sfc_staticRenderFns$Q = [];
var __component__$Q = /* @__PURE__ */ normalizeComponent(
  _sfc_main$Q,
  _sfc_render$Q,
  _sfc_staticRenderFns$Q,
  false,
  null,
  "485cea51"
);
const EntityPicker = __component__$Q.exports;
const shareType = Object.keys(SHARES_TYPES_MEMBER_MAP);
const maxAutocompleteResults = parseInt(window.OC.config["sharing.maxAutocompleteResults"], 10) || 25;
const getSuggestions = async function(search) {
  const request = await cancelableClient.get(v("apps/files_sharing/api/v1/sharees"), {
    params: {
      format: "json",
      itemType: "file",
      search,
      perPage: maxAutocompleteResults,
      shareType,
      lookup: false
    }
  });
  const data = request.data.ocs.data;
  const exact = request.data.ocs.data.exact;
  data.exact = [];
  const rawExactSuggestions = Object.values(exact).reduce((arr, elem) => arr.concat(elem), []);
  const rawSuggestions = Object.values(data).reduce((arr, elem) => arr.concat(elem), []);
  const exactSuggestions = rawExactSuggestions.filter((result) => typeof result === "object").map((share) => formatResults(share)).sort((a, b) => a.shareType - b.shareType);
  const suggestions = rawSuggestions.filter((result) => typeof result === "object").map((share) => formatResults(share)).sort((a, b) => a.shareType - b.shareType);
  const allSuggestions = exactSuggestions.concat(suggestions);
  const nameCounts = allSuggestions.reduce((nameCounts2, result) => {
    if (!result.displayName) {
      return nameCounts2;
    }
    if (!nameCounts2[result.displayName]) {
      nameCounts2[result.displayName] = 0;
    }
    nameCounts2[result.displayName]++;
    return nameCounts2;
  }, {});
  const finalResults = allSuggestions.map((item) => {
    if (nameCounts[item.displayName] > 1 && !item.desc) {
      return { ...item, desc: item.shareWithDisplayNameUnique };
    }
    return item;
  });
  console.info("suggestions", finalResults);
  return finalResults;
};
const getRecommendations = async function() {
  const request = await cancelableClient.get(v("apps/files_sharing/api/v1/sharees_recommended"), {
    params: {
      format: "json",
      itemType: "file",
      shareType
    }
  });
  const exact = request.data.ocs.data.exact;
  const recommendations = Object.values(exact).reduce((arr, elem) => arr.concat(elem), []);
  const finalResults = recommendations.map((share) => formatResults(share));
  console.info("recommendations", finalResults);
  return finalResults;
};
const formatResults = function(result) {
  const type = `picker-${result.value.shareType}`;
  return {
    label: result.label,
    id: `${type}-${result.value.shareWith}`,
    // If this is a user, set as user for avatar display by UserBubble
    user: [window.OC.Share.SHARE_TYPE_USER, window.OC.Share.SHARE_TYPE_REMOTE].indexOf(result.value.shareType) > -1 ? result.value.shareWith : null,
    type,
    ...result.value
  };
};
/*! third party licenses: js/vendor.LICENSE.txt */
const _sfc_main$P = defineComponent({
  name: "MemberList",
  components: {
    EntityPicker,
    IconContact,
    IconAdd,
    MemberListGroup,
    NcButton,
    NcEmptyContent,
    NcLoadingIcon
  },
  mixins: [index, RouterMixin],
  props: {
    list: {
      type: Array,
      required: true
    },
    loading: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      pickerLoading: false,
      showPicker: false,
      showPickerIntro: true,
      recommendations: [],
      pickerCircle: null,
      pickerData: [],
      pickerSelection: {},
      pickerTypes: CIRCLES_MEMBER_GROUPING
    };
  },
  computed: {
    /**
     * Return the current circle
     *
     * @return {Circle}
     */
    circle() {
      return this.$store.getters.getCircle(this.selectedCircle);
    },
    hasMembers() {
      return this.groupedList.length > 0;
    },
    filteredPickerData() {
      return this.pickerData.filter((entity) => {
        const type = SHARES_TYPES_MEMBER_MAP[entity.shareType];
        const list = this.list.filter(({ userType }) => userType === type);
        if (list) {
          return list.find((member) => member.userId === entity.shareWith) === void 0;
        }
        return true;
      });
    },
    groupedList() {
      return CIRCLES_MEMBER_GROUPING.map(({ labelStandalone, type }) => ({
        type,
        label: labelStandalone,
        members: [...this.list.filter(({ userType }) => userType === type)]
      })).filter(({ members }) => members.length > 0);
    }
  },
  mounted() {
    subscribe("contacts:circles:append", this.onShowPicker);
  },
  methods: {
    /**
     * Show picker and fetch for recommendations
     * Cache the circleId in case the url change or something
     * and make sure we add them to the desired circle.
     *
     * @param {string} circleId the circle id to add members to
     */
    async onShowPicker(circleId) {
      this.showPicker = true;
      this.pickerLoading = true;
      this.pickerCircle = circleId;
      try {
        const results = await getRecommendations();
        this.recommendations = results;
        this.pickerData = results;
      } catch (error) {
        console.error("Unable to get the recommendations list", error);
      } finally {
        this.pickerLoading = false;
      }
    },
    /**
     * On EntityPicker search.
     * Returns recommendations if empty
     *
     * @param {string} term the searched term
     */
    async onSearch(term) {
      if (term.trim() === "") {
        this.pickerData = this.recommendations;
        return;
      }
      this.pickerLoading = true;
      try {
        const results = await getSuggestions(term);
        this.pickerData = results;
      } catch (error) {
        console.error("Unable to get the results", error);
        showError(translate("contacts", "Unable to get the results"));
      } finally {
        this.pickerLoading = false;
      }
    },
    /**
     * On picker submit
     *
     * @param {Array} selection the selection to add to the circle
     */
    async onPickerPick(selection2) {
      this.logger.info("Adding selection to circle", { selection: selection2, pickerCircle: this.pickerCircle });
      this.pickerLoading = true;
      selection2 = selection2.map((entry) => ({
        id: entry.shareWith,
        type: SHARES_TYPES_MEMBER_MAP[entry.shareType]
      }));
      try {
        const members = await this.$store.dispatch("addMembersToCircle", { circleId: this.pickerCircle, selection: selection2 });
        if (members.length < selection2.length) {
          showWarning(translate("contacts", "Some members could not be added"));
          this.pickerSelection = {};
          return;
        }
        this.resetPicker();
      } catch (error) {
        showError(translate("contacts", "There was an issue adding members to the team"));
        console.error("There was an issue adding members to the circle", this.pickerCircle, error);
      } finally {
        this.pickerLoading = false;
      }
    },
    /**
     * Reset picker related variables
     */
    resetPicker() {
      this.showPicker = false;
      this.pickerCircle = null;
      this.pickerData = [];
      this.pickerSelection = {};
    }
  }
});
var _sfc_render$P = function render29() {
  var _vm = this, _c = _vm._self._c;
  _vm._self._setupProxy;
  return _c("section", { staticClass: "member-list" }, [_c("ContentHeading", [_vm._v(" " + _vm._s(_vm.t("contacts", "Team members")) + " ")]), _vm.loading ? _c("NcEmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "Loading members list ") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconLoading", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 3081367109) }) : !_vm.circle.isMember ? _c("NcEmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "The list of members is only visible to members of this team") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconContact", { attrs: { "size": 20 } })];
  }, proxy: true }]) }) : !_vm.hasMembers ? _c("NcEmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "You currently have no access to the member list") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconContact", { attrs: { "size": 20 } })];
  }, proxy: true }]) }) : _c("div", [_c("div", { staticClass: "member-list__new" }, [_vm.circle.canManageMembers ? _c("NcButton", { on: { "click": function($event) {
    return _vm.onShowPicker(_vm.circle.id);
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.loading ? _c("NcLoadingIcon") : _c("IconAdd", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2183041309) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Add members")) + " ")]) : _vm._e()], 1), _vm._l(_vm.groupedList, function(group, index2) {
    return _c("MemberListGroup", _vm._b({ key: `member-list-group-${index2}` }, "MemberListGroup", group, false));
  })], 2), _vm.showPicker ? _c("EntityPicker", { attrs: { "confirm-label": _vm.t("contacts", "Add to {circle}", { circle: _vm.circle.displayName }), "data-types": _vm.pickerTypes, "data-set": _vm.filteredPickerData, "internal-search": false, "loading": _vm.pickerLoading, "selection": _vm.pickerSelection }, on: { "update:selection": function($event) {
    _vm.pickerSelection = $event;
  }, "close": _vm.resetPicker, "search": _vm.onSearch, "submit": _vm.onPickerPick } }) : _vm._e()], 1);
};
var _sfc_staticRenderFns$P = [];
var __component__$P = /* @__PURE__ */ normalizeComponent(
  _sfc_main$P,
  _sfc_render$P,
  _sfc_staticRenderFns$P,
  false,
  null,
  "8729863b"
);
const MemberList = __component__$P.exports;
const ENFORCE_PASSWORD_PROTECTION = "enforce_password";
const USE_UNIQUE_PASSWORD = "password_single_enabled";
const UNIQUE_PASSWORD = "password_single";
const _sfc_main$O = {
  name: "CirclePasswordSettings",
  components: {
    ContentHeading,
    CheckboxRadioSwitch: NcCheckboxRadioSwitch,
    Button: NcButton
  },
  props: {
    circle: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      ENFORCE_PASSWORD_PROTECTION,
      USE_UNIQUE_PASSWORD,
      UNIQUE_PASSWORD,
      loading: [],
      uniquePassword: "",
      uniquePasswordError: false,
      showUniquePasswordInput: false
    };
  },
  computed: {
    /**
     * @return {string}
     */
    circleId() {
      return this.circle._data.id;
    },
    /**
     * @return {boolean}
     */
    enforcePasswordProtection() {
      const value = this.circle._data.settings[ENFORCE_PASSWORD_PROTECTION];
      return value === "1" || value === "true";
    },
    /**
     * @return {boolean}
     */
    useUniquePassword() {
      const value = this.circle._data.settings[USE_UNIQUE_PASSWORD];
      return value === "1" || value === "true";
    }
  },
  methods: {
    /**
     * Change handler for enforcePasswordProtection checkbox.
     */
    async changePasswordProtection() {
      this.loading.push(ENFORCE_PASSWORD_PROTECTION);
      try {
        const newValue = !this.enforcePasswordProtection;
        if (!newValue && this.useUniquePassword) {
          await this.saveUseUniquePassword(false);
        }
        if (!newValue && this.showUniquePasswordInput) {
          this.showUniquePasswordInput = false;
        }
        await this.$store.dispatch("editCircleSetting", {
          circleId: this.circleId,
          setting: {
            setting: ENFORCE_PASSWORD_PROTECTION,
            value: newValue.toString()
          }
        });
      } finally {
        this.loading = this.loading.filter((item) => item !== ENFORCE_PASSWORD_PROTECTION);
      }
    },
    /**
     * Change handler for useUniquePassword checkbox.
     */
    async changeUseUniquePassword() {
      if (!this.useUniquePassword) {
        this.showUniquePasswordInput = !this.showUniquePasswordInput;
        return;
      }
      await this.saveUseUniquePassword(!this.useUniquePassword);
    },
    /**
     * Update backend with given value for useUniquePassword.
     *
     * @param {boolean} value New value
     */
    async saveUseUniquePassword(value) {
      this.loading.push(USE_UNIQUE_PASSWORD);
      try {
        await this.$store.dispatch("editCircleSetting", {
          circleId: this.circleId,
          setting: {
            setting: USE_UNIQUE_PASSWORD,
            value: value.toString()
          }
        });
        if (!value) {
          this.uniquePassword = "";
          this.showUniquePasswordInput = false;
        }
      } finally {
        this.loading = this.loading.filter((item) => item !== USE_UNIQUE_PASSWORD);
      }
    },
    /**
     * Persist uniquePassword to backend.
     */
    async saveUniquePassword() {
      if (this.uniquePassword.length === 0) {
        return;
      }
      this.loading.push(UNIQUE_PASSWORD);
      this.uniquePasswordError = false;
      try {
        if (!this.useUniquePassword) {
          await this.saveUseUniquePassword(true);
        }
        await this.$store.dispatch("editCircleSetting", {
          circleId: this.circleId,
          setting: {
            setting: UNIQUE_PASSWORD,
            value: this.uniquePassword
          }
        });
        this.showUniquePasswordInput = false;
        this.uniquePassword = "";
      } catch {
        this.uniquePasswordError = true;
      } finally {
        this.loading = this.loading.filter((item) => item !== UNIQUE_PASSWORD);
      }
    },
    /**
     * Click handler for the button to show the uniquePassword input.
     */
    onClickChangePassword() {
      this.showUniquePasswordInput = true;
    }
  }
};
var _sfc_render$O = function render30() {
  var _vm = this, _c = _vm._self._c;
  return _c("ul", [_c("li", { staticClass: "circle-config" }, [_c("ContentHeading", { staticClass: "circle-config__title" }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Password protection")) + " ")]), _c("ul", { staticClass: "circle-config__list" }, [_c("CheckboxRadioSwitch", { attrs: { "checked": _vm.enforcePasswordProtection, "loading": _vm.loading.includes(_vm.ENFORCE_PASSWORD_PROTECTION), "disabled": _vm.loading.length > 0, "wrapper-element": "li" }, on: { "update:checked": _vm.changePasswordProtection } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Enforce password protection on files shared to this team")) + " ")]), _vm.enforcePasswordProtection ? _c("CheckboxRadioSwitch", { attrs: { "checked": _vm.useUniquePassword || _vm.showUniquePasswordInput, "loading": _vm.loading.includes(_vm.USE_UNIQUE_PASSWORD), "disabled": _vm.loading.length > 0, "wrapper-element": "li" }, on: { "update:checked": _vm.changeUseUniquePassword } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Use a unique password for all shares to this team")) + " ")]) : _vm._e(), _c("li", { staticClass: "unique-password" }, [_vm.showUniquePasswordInput ? [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.uniquePassword, expression: "uniquePassword" }], attrs: { "disabled": _vm.loading.length > 0, "placeholder": _vm.t("contacts", "Unique password "), "type": "text" }, domProps: { "value": _vm.uniquePassword }, on: { "keyup": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) return null;
    return _vm.saveUniquePassword.apply(null, arguments);
  }, "input": function($event) {
    if ($event.target.composing) return;
    _vm.uniquePassword = $event.target.value;
  } } }), _c("Button", { attrs: { "type": "tertiary-no-background", "disabled": _vm.loading.length > 0 || _vm.uniquePassword.length === 0 }, on: { "click": _vm.saveUniquePassword } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Save")) + " ")])] : _vm.useUniquePassword ? _c("Button", { staticClass: "change-unique-password", on: { "click": _vm.onClickChangePassword } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Change unique password")) + " ")]) : _vm._e(), _vm.uniquePasswordError ? _c("div", { staticClass: "unique-password-error" }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Failed to save password. Please try again later.")) + " ")]) : _vm._e()], 2)], 1)], 1)]);
};
var _sfc_staticRenderFns$O = [];
var __component__$O = /* @__PURE__ */ normalizeComponent(
  _sfc_main$O,
  _sfc_render$O,
  _sfc_staticRenderFns$O,
  false,
  null,
  "8009c985"
);
const CirclePasswordSettings = __component__$O.exports;
const _sfc_main$N = {
  name: "CircleDetails",
  components: {
    Avatar: NcAvatar,
    Button: NcButton,
    CircleConfigs,
    CirclePasswordSettings,
    ContentHeading,
    DetailsHeader,
    ListItem: NcListItem,
    Cog,
    IconAccountGroup: AccountGroup,
    IconDelete,
    Login,
    Logout,
    MemberList,
    Modal: NcModal,
    NcEmptyContent,
    NcLoadingIcon,
    RichContenteditable: NcRichContenteditable
  },
  mixins: [CircleActionsMixin],
  setup() {
    const avatarList = ref$1();
    const { width } = useElementSize(avatarList);
    return { avatarList, width };
  },
  data() {
    return {
      loadingDescription: false,
      loadingName: false,
      showSettingsModal: false,
      showMembersModal: false,
      resources: null
    };
  },
  computed: {
    descriptionPlaceholder() {
      if (this.circle.description.trim() === "") {
        return t("contacts", "There is no description for this team");
      }
      return t("contacts", "Enter a description for the team");
    },
    isEmptyDescription() {
      return this.circle.description.trim() === "";
    },
    showDescription() {
      if (this.circle.isOwner) {
        return true;
      }
      return !this.isEmptyDescription;
    },
    members() {
      return Object.values(this.$store.getters.getCircle(this.circle.id)?.members || []);
    },
    maxMembers() {
      const avatarWidth = parseInt(window.getComputedStyle(document.body).getPropertyValue("--default-clickable-area")) + 12;
      const maxMembers = Math.floor(this.width / avatarWidth);
      return this.members.length > maxMembers ? maxMembers - 1 : maxMembers;
    },
    memberLimit() {
      return Math.min(this.members.length, this.maxMembers);
    },
    membersLimited() {
      return this.members.slice(0, this.memberLimit);
    },
    hasExtraMembers() {
      return this.members.length > this.maxMembers;
    },
    resourceProviders() {
      return this.resources?.reduce((acc, res) => {
        if (!acc.find((p) => p.id === res.provider.id)) {
          acc.push(res.provider);
        }
        return acc;
      }, []) ?? [];
    },
    resourcesForProvider() {
      return (providerId) => {
        return this.resources?.filter((res) => res.provider.id === providerId) ?? [];
      };
    }
  },
  watch: {
    "circle.id": {
      handler() {
        this.fetchTeamResources();
      },
      immediate: true
    }
  },
  methods: {
    async fetchTeamResources() {
      const response = await cancelableClient.get(v(`/teams/${this.circle.id}/resources`));
      this.resources = response.data.ocs.data.resources;
    },
    /**
     * Autocomplete @mentions on the description
     *
     * @param {string} search the search term
     * @param {Function} callback callback to be called with results array
     */
    onAutocomplete(search, callback) {
      callback([]);
    },
    onDescriptionChangeDebounce: debounce(function(...args) {
      this.onDescriptionChange(...args);
    }, 500),
    async onDescriptionChange(description2) {
      this.loadingDescription = true;
      try {
        await editCircle(this.circle.id, CircleEdit.Description, description2);
      } catch (error) {
        console.error("Unable to edit team description", description2, error);
        showError(t("contacts", "An error happened during description sync"));
      } finally {
        this.loadingDescription = false;
      }
    },
    onNameChangeDebounce: debounce(function(event) {
      this.onNameChange(event.target.value);
    }, 500),
    async onNameChange(name) {
      this.loadingName = true;
      try {
        await editCircle(this.circle.id, CircleEdit.Name, name);
      } catch (error) {
        console.error("Unable to edit name", name, error);
        showError(t("contacts", "An error happened during name sync"));
      } finally {
        this.loadingName = false;
      }
    }
  }
};
var _sfc_render$N = function render31() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "circle-details" }, [_c("DetailsHeader", { scopedSlots: _vm._u([{ key: "avatar", fn: function({ avatarSize }) {
    return [_c("Avatar", { attrs: { "disable-tooltip": true, "display-name": _vm.circle.displayName, "is-no-user": true, "size": avatarSize } })];
  } }, { key: "title", fn: function() {
    return [_vm.loadingName ? _c("div", { staticClass: "circle-name__loader icon-loading-small" }) : _vm._e(), _c("h2", [_vm._v(" " + _vm._s(_vm.circle.displayName) + " ")])];
  }, proxy: true }, !_vm.circle.isOwner ? { key: "subtitle", fn: function() {
    return [_vm._v(" " + _vm._s(_vm.t("contacts", "Team owned by {owner}", { owner: _vm.circle.owner.displayName })) + " ")];
  }, proxy: true } : null, { key: "actions", fn: function() {
    return [_c("Button", { class: _vm.copyLinkIcon, attrs: { "type": "tertiary", "href": _vm.circleUrl, "title": _vm.copyButtonText }, on: { "click": function($event) {
      $event.stopPropagation();
      $event.preventDefault();
      return _vm.copyToClipboard(_vm.circleUrl);
    } } }), (_vm.circle.isOwner || _vm.circle.isAdmin) && !_vm.circle.isPersonal ? _c("Button", { on: { "click": function($event) {
      _vm.showSettingsModal = true;
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("Cog", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 3604109635) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Team settings")) + " ")]) : _vm._e(), !_vm.circle.isPendingMember && !_vm.circle.isMember && _vm.circle.canJoin ? _c("Button", { staticClass: "primary", attrs: { "disabled": _vm.loadingJoin }, on: { "click": _vm.joinCircle }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("Login", { attrs: { "size": 16 } })];
    }, proxy: true }], null, false, 1886710894) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Request to join")) + " ")]) : _vm._e()];
  }, proxy: true }], null, true) }), _vm.showDescription ? _c("section", { staticClass: "circle-details-section" }, [_c("ContentHeading", { attrs: { "loading": _vm.loadingDescription } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Description")) + " ")]), _c("RichContenteditable", { staticClass: "circle-details-section__description", attrs: { "value": _vm.circle.description, "auto-complete": _vm.onAutocomplete, "maxlength": 1024, "multiline": true, "contenteditable": false, "placeholder": _vm.descriptionPlaceholder }, on: { "update:value": [function($event) {
    return _vm.$set(_vm.circle, "description", $event);
  }, _vm.onDescriptionChangeDebounce] } })], 1) : _vm._e(), !_vm.circle.isMember ? [_vm.circle.isPendingMember ? _c("NcEmptyContent", { attrs: { "name": _vm.t("contacts", "Your request to join this team is pending approval") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("NcLoadingIcon", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 3155754792) }) : _c("NcEmptyContent", { attrs: { "name": _vm.t("contacts", "You are not a member of {circle}", { circle: _vm.circle.displayName }) }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconAccountGroup", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2121133277) })] : _c("section", [_c("ContentHeading", [_vm._v(" " + _vm._s(_vm.t("contacts", "Team resources")) + " ")]), _c("p", [_vm._v(_vm._s(_vm.t("contacts", "Anything shared with this team will show up here")))]), _vm._l(_vm.resourceProviders, function(provider) {
    return _c("div", { key: provider.id }, [_c("ContentHeading", [_c("span", { directives: [{ name: "show", rawName: "v-show", value: false, expression: "false" }], staticClass: "provider__icon", domProps: { "innerHTML": _vm._s(provider.icon) } }), _vm._v(" " + _vm._s(provider.name) + " ")]), _c("ul", _vm._l(_vm.resourcesForProvider(provider.id), function(resource) {
      return _c("ListItem", { key: resource.url, staticClass: "resource", attrs: { "name": resource.label, "href": resource.url }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
        return [resource.iconEmoji ? _c("span", { staticClass: "resource__icon" }, [_vm._v(" " + _vm._s(resource.iconEmoji) + " ")]) : resource.iconSvg ? _c("span", { staticClass: "resource__icon", domProps: { "innerHTML": _vm._s(resource.iconSvg) } }) : resource.iconURL ? _c("span", { staticClass: "resource__icon" }, [_c("img", { attrs: { "src": resource.iconURL, "alt": "" } })]) : _vm._e()];
      }, proxy: true }], null, true) });
    }), 1)], 1);
  })], 2), _vm.members.length ? _c("MemberList", { attrs: { "list": _vm.members } }) : _vm._e(), (_vm.circle.isOwner || _vm.circle.isAdmin) && !_vm.circle.isPersonal && _vm.showSettingsModal ? _c("Modal", { on: { "close": function($event) {
    _vm.showSettingsModal = false;
  } } }, [_c("div", { staticClass: "circle-settings" }, [_c("h2", [_vm._v(_vm._s(_vm.t("contacts", "Team settings")))]), _c("h3", [_vm._v(_vm._s(_vm.t("contacts", "Team name")))]), _c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.circle.displayName, expression: "circle.displayName" }], attrs: { "readonly": !_vm.circle.isOwner, "placeholder": _vm.t("contacts", "Team name"), "type": "text", "autocomplete": "off", "autocorrect": "off", "spellcheck": "false", "name": "displayname" }, domProps: { "value": _vm.circle.displayName }, on: { "input": [function($event) {
    if ($event.target.composing) return;
    _vm.$set(_vm.circle, "displayName", $event.target.value);
  }, _vm.onNameChangeDebounce] } }), _c("h3", [_vm._v(_vm._s(_vm.t("contacts", "Description")))]), _c("RichContenteditable", { staticClass: "circle-details-section__description", attrs: { "value": _vm.circle.description, "auto-complete": _vm.onAutocomplete, "maxlength": 1024, "multiline": true, "contenteditable": _vm.circle.isOwner, "placeholder": _vm.descriptionPlaceholder }, on: { "update:value": [function($event) {
    return _vm.$set(_vm.circle, "description", $event);
  }, _vm.onDescriptionChangeDebounce] } }), _c("h3", [_vm._v(_vm._s(_vm.t("contacts", "Settings")))]), _c("CircleConfigs", { staticClass: "circle-details-section__configs", attrs: { "circle": _vm.circle } }), _c("CirclePasswordSettings", { staticClass: "circle-details-section__configs", attrs: { "circle": _vm.circle } }), _c("h3", [_vm._v(_vm._s(_vm.t("contacts", "Actions")))]), _vm.circle.canLeave ? _c("Button", { attrs: { "type": "warning" }, on: { "click": _vm.confirmLeaveCircle }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("Logout", { attrs: { "size": 16 } })];
  }, proxy: true }], null, false, 1893119367) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Leave team")) + " ")]) : _vm._e(), _vm.circle.canDelete ? _c("Button", { attrs: { "type": "error", "href": "#" }, on: { "click": function($event) {
    $event.preventDefault();
    $event.stopPropagation();
    return _vm.confirmDeleteCircle.apply(null, arguments);
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconDelete", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 881161434) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Delete team")) + " ")]) : _vm._e()], 1)]) : _vm._e()], 2);
};
var _sfc_staticRenderFns$N = [];
var __component__$N = /* @__PURE__ */ normalizeComponent(
  _sfc_main$N,
  _sfc_render$N,
  _sfc_staticRenderFns$N,
  false,
  null,
  "df4b9575"
);
const CircleDetails = __component__$N.exports;
const _sfc_main$M = {
  name: "CircleContent",
  components: {
    AppContent: NcAppContent,
    CircleDetails,
    EmptyContent: NcEmptyContent,
    AccountGroup,
    IconLoading: NcLoadingIcon
  },
  mixins: [index, RouterMixin],
  props: {
    loading: {
      type: Boolean,
      default: true
    }
  },
  data() {
    return {
      loadingList: false
    };
  },
  computed: {
    // store variables
    circles() {
      return this.$store.getters.getCircles;
    },
    circle() {
      return this.$store.getters.getCircle(this.selectedCircle);
    },
    members() {
      return Object.values(this.circle?.members || []);
    },
    /**
     * Is the current circle empty
     *
     * @return {boolean}
     */
    isEmptyCircle() {
      return this.members.length === 0;
    }
  },
  watch: {
    circle(newCircle) {
      if (newCircle?.id) {
        this.fetchCircleMembers(newCircle.id);
      }
    }
  },
  beforeMount() {
    if (this.circle?.id) {
      this.fetchCircleMembers(this.circle.id);
    }
  },
  methods: {
    async fetchCircleMembers(circleId) {
      this.loadingList = true;
      this.logger.debug("Fetching members for", { circleId });
      try {
        await this.$store.dispatch("getCircleMembers", circleId);
      } catch (error) {
        console.error(error);
        showError(t("contacts", "There was an error fetching the member list"));
      } finally {
        this.loadingList = false;
      }
    }
  }
};
var _sfc_render$M = function render32() {
  var _vm = this, _c = _vm._self._c;
  return _c("AppContent", [!_vm.circle ? _c("EmptyContent", { attrs: { "name": _vm.t("contacts", "Please select a team") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("AccountGroup", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 4176711638) }) : _vm.loading ? _c("EmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "Loading team") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconLoading", { attrs: { "size": 20 } })];
  }, proxy: true }]) }) : _c("CircleDetails", { attrs: { "circle": _vm.circle } })], 1);
};
var _sfc_staticRenderFns$M = [];
var __component__$M = /* @__PURE__ */ normalizeComponent(
  _sfc_main$M,
  _sfc_render$M,
  _sfc_staticRenderFns$M,
  false,
  null,
  "c7999225"
);
const CircleContent = __component__$M.exports;
function cumsum(values, valueof) {
  var sum2 = 0, index2 = 0;
  return Float64Array.from(values, valueof === void 0 ? (v2) => sum2 += +v2 || 0 : (v2) => sum2 += +valueof(v2, index2++, values) || 0);
}
function max(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index2, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
function sum(values, valueof) {
  let sum2 = 0;
  if (valueof === void 0) {
    for (let value of values) {
      if (value = +value) {
        sum2 += value;
      }
    }
  } else {
    let index2 = -1;
    for (let value of values) {
      if (value = +valueof(value, ++index2, values)) {
        sum2 += value;
      }
    }
  }
  return sum2;
}
var noop = { value: () => {
} };
function dispatch() {
  for (var i = 0, n2 = arguments.length, _2 = {}, t2; i < n2; ++i) {
    if (!(t2 = arguments[i] + "") || t2 in _2 || /[\s.]/.test(t2)) throw new Error("illegal type: " + t2);
    _2[t2] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i = t2.indexOf(".");
    if (i >= 0) name = t2.slice(i + 1), t2 = t2.slice(0, i);
    if (t2 && !types.hasOwnProperty(t2)) throw new Error("unknown type: " + t2);
    return { type: t2, name };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames$1(typename + "", _2), t2, i = -1, n2 = T.length;
    if (arguments.length < 2) {
      while (++i < n2) if ((t2 = (typename = T[i]).type) && (t2 = get$1(_2[t2], typename.name))) return t2;
      return;
    }
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n2) {
      if (t2 = (typename = T[i]).type) _2[t2] = set$1(_2[t2], typename.name, callback);
      else if (callback == null) for (t2 in _2) _2[t2] = set$1(_2[t2], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy = {}, _2 = this._;
    for (var t2 in _2) copy[t2] = _2[t2].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i = 0, n2, t2; i < n2; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t2 = this._[type], i = 0, n2 = t2.length; i < n2; ++i) t2[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t2 = this._[type], i = 0, n2 = t2.length; i < n2; ++i) t2[i].value.apply(that, args);
  }
};
function get$1(type, name) {
  for (var i = 0, n2 = type.length, c; i < n2; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}
function set$1(type, name, callback) {
  for (var i = 0, n2 = type.length; i < n2; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({ name, value: callback });
  return type;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? { space: namespaces[prefix], local: name } : name;
}
function creatorInherit(name) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name) : document2.createElementNS(uri, name);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name) {
  var fullname = namespace(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none() {
}
function selector(selector2) {
  return selector2 == null ? none : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function") select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i = 0; i < n2; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function array(x2) {
  return x2 == null ? [] : Array.isArray(x2) ? x2 : Array.from(x2);
}
function empty() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty : function() {
    return this.querySelectorAll(selector2);
  };
}
function arrayAll(select2) {
  return function() {
    return array(select2.apply(this, arguments));
  };
}
function selection_selectAll(select2) {
  if (typeof select2 === "function") select2 = arrayAll(select2);
  else select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        subgroups.push(select2.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }
  return new Selection$1(subgroups, parents);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function childMatcher(selector2) {
  return function(node) {
    return node.matches(selector2);
  };
}
var find = Array.prototype.find;
function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}
function childFirst() {
  return this.firstElementChild;
}
function selection_selectChild(match) {
  return this.select(match == null ? childFirst : childFind(typeof match === "function" ? match : childMatcher(match)));
}
var filter = Array.prototype.filter;
function children() {
  return Array.from(this.children);
}
function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}
function selection_selectChildren(match) {
  return this.selectAll(match == null ? children : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}
function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n2; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum2) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum2;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$3(x2) {
  return function() {
    return x2;
  };
}
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node, nodeByKeyValue = /* @__PURE__ */ new Map(), groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue.get(keyValues[i]) === node) {
      exit[i] = node;
    }
  }
}
function datum(node) {
  return node.__data__;
}
function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);
  var bind = key ? bindKey : bindIndex, parents = this._parents, groups = this._groups;
  if (typeof value !== "function") value = constant$3(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j], group = groups[j], groupLength = group.length, data = arraylike(value.call(parent, parent && parent.__data__, j, parents)), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength) ;
        previous._next = next || null;
      }
    }
  }
  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function arraylike(data) {
  return typeof data === "object" && "length" in data ? data : Array.from(data);
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove();
  else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(context) {
  var selection2 = context.selection ? context.selection() : context;
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge = merges[j] = new Array(n2), node, i = 0; i < n2; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare) compare = ascending;
  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, sortgroup = sortgroups[j] = new Array(n2), node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  return Array.from(this);
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n2 = group.length; i < n2; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }
  return null;
}
function selection_size() {
  let size = 0;
  for (const node of this) ++size;
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n2 = group.length, node; i < n2; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.removeAttribute(name);
    else this.setAttribute(name, v2);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v2);
  };
}
function selection_attr(name, value) {
  var fullname = namespace(name);
  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView;
}
function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}
function styleFunction$1(name, value, priority) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v2, priority);
  };
}
function selection_style(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}
function styleValue(node, name) {
  return node.style.getPropertyValue(name) || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}
function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}
function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}
function propertyFunction(name, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (v2 == null) delete this[name];
    else this[name] = v2;
  };
}
function selection_property(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node) {
  return node.classList || new ClassList(node);
}
function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};
function classedAdd(node, names) {
  var list = classList(node), i = -1, n2 = names.length;
  while (++i < n2) list.add(names[i]);
}
function classedRemove(node, names) {
  var list = classList(node), i = -1, n2 = names.length;
  while (++i < n2) list.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name, value) {
  var names = classArray(name + "");
  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n2 = names.length;
    while (++i < n2) if (!list.contains(names[i])) return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.textContent = v2 == null ? "" : v2;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v2 = value.apply(this, arguments);
    this.innerHTML = v2 == null ? "" : v2;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name) {
  var create2 = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name, before) {
  var create2 = typeof name === "function" ? name : creator(name), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t2) {
    var name = "", i = t2.indexOf(".");
    if (i >= 0) name = t2.slice(i + 1), t2 = t2.slice(0, i);
    return { type: t2, name };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o2; j < m; ++j) {
      if (o2 = on[j], (!typename.type || o2.type === typename.type) && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
      } else {
        on[++i] = o2;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}
function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o2, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o2 = on[j]).type === typename.type && o2.name === typename.name) {
        this.removeEventListener(o2.type, o2.listener, o2.options);
        this.addEventListener(o2.type, o2.listener = listener, o2.options = options);
        o2.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o2 = { type: typename.type, name: typename.name, value, listener, options };
    if (!on) this.__on = [o2];
    else on.push(o2);
  };
}
function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n2 = typenames.length, t2;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o2; j < m; ++j) {
      for (i = 0, o2 = on[j]; i < n2; ++i) {
        if ((t2 = typenames[i]).type === o2.type && t2.name === o2.name) {
          return o2.value;
        }
      }
    }
    return;
  }
  on = value ? onAdd : onRemove;
  for (i = 0; i < n2; ++i) this.each(on(typenames[i], value, options));
  return this;
}
function dispatchEvent(node, type, params) {
  var window2 = defaultView(node), event = window2.CustomEvent;
  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window2.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }
  node.dispatchEvent(event);
}
function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}
function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}
function selection_dispatch(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n2 = group.length, node; i < n2; ++i) {
      if (node = group[i]) yield node;
    }
  }
}
var root = [null];
function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}
function selection() {
  return new Selection$1([[document.documentElement]], root);
}
function selection_selection() {
  return this;
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root);
}
function sourceEvent(event) {
  let sourceEvent2;
  while (sourceEvent2 = event.sourceEvent) event = sourceEvent2;
  return event;
}
function pointer(event, node) {
  event = sourceEvent(event);
  if (node === void 0) node = event.currentTarget;
  if (node) {
    var svg = node.ownerSVGElement || node;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      point.x = event.clientX, point.y = event.clientY;
      point = point.matrixTransform(node.getScreenCTM().inverse());
      return [point.x, point.y];
    }
    if (node.getBoundingClientRect) {
      var rect = node.getBoundingClientRect();
      return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
    }
  }
  return [event.pageX, event.pageY];
}
const nonpassivecapture = { capture: true, passive: false };
function noevent$1(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$1, nonpassivecapture);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$1, nonpassivecapture);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$1, nonpassivecapture);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o2) {
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Rgb();
  o2 = o2.rgb();
  return new Rgb(o2.r, o2.g, o2.b, o2.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a) {
  if (a <= 0) h = s2 = l = NaN;
  else if (l <= 0 || l >= 1) h = s2 = NaN;
  else if (s2 <= 0) h = NaN;
  return new Hsl(h, s2, l, a);
}
function hslConvert(o2) {
  if (o2 instanceof Hsl) return new Hsl(o2.h, o2.s, o2.l, o2.opacity);
  if (!(o2 instanceof Color)) o2 = color(o2);
  if (!o2) return new Hsl();
  if (o2 instanceof Hsl) return o2;
  o2 = o2.rgb();
  var r = o2.r / 255, g = o2.g / 255, b = o2.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s2 = max2 - min2, l = (max2 + min2) / 2;
  if (s2) {
    if (r === max2) h = (g - b) / s2 + (g < b) * 6;
    else if (g === max2) h = (b - r) / s2 + 2;
    else h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o2.opacity);
}
function hsl(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
const constant$2 = (x2) => () => x2;
function linear(a, d) {
  return function(t2) {
    return a + t2 * d;
  };
}
function exponential(a, b, y2) {
  return a = Math.pow(a, y2), b = Math.pow(b, y2) - a, y2 = 1 / y2, function(t2) {
    return Math.pow(a + t2 * b, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y2) : constant$2(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$2(isNaN(a) ? b : a);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end) {
    var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
    return function(t2) {
      start2.r = r(t2);
      start2.g = g(t2);
      start2.b = b(t2);
      start2.opacity = opacity(t2);
      return start2 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t2) {
    return a * (1 - t2) + b * t2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t2) {
    return b(t2) + "";
  };
}
function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i]) s2[i] += bs;
      else s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i]) s2[i] += bm;
      else s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i]) s2[i] += bs;
    else s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t2) {
    for (var i2 = 0, o2; i2 < b; ++i2) s2[(o2 = q[i2]).i] = o2.x(t2);
    return s2.join("");
  });
}
var degrees = 180 / Math.PI;
var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a, b, c, d, e2, f) {
  var scaleX2, scaleY2, skewX;
  if (scaleX2 = Math.sqrt(a * a + b * b)) a /= scaleX2, b /= scaleX2;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY2 = Math.sqrt(c * c + d * d)) c /= scaleY2, d /= scaleY2, skewX /= scaleY2;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX2 = -scaleX2;
  return {
    translateX: e2,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX2,
    scaleY: scaleY2
  };
}
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null) return identity$1;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate2(a, b, s2, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;
      else if (b - a > 180) a += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s2, q) {
    if (a !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale2(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s2 = [], q = [];
    a = parse(a), b = parse(b);
    translate2(a.translateX, a.translateY, b.translateX, b.translateY, s2, q);
    rotate2(a.rotate, b.rotate, s2, q);
    skewX(a.skewX, b.skewX, s2, q);
    scale2(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s2, q);
    a = b = null;
    return function(t2) {
      var i = -1, n2 = q.length, o2;
      while (++i < n2) s2[(o2 = q[i]).i] = o2.x(t2);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var epsilon2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
const interpolateZoom = function zoomRho(rho, rho2, rho4) {
  function zoom2(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t2) {
        return [
          ux0 + t2 * dx,
          uy0 + t2 * dy,
          w0 * Math.exp(rho * t2 * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t2) {
        var s2 = t2 * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s2 + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom2.rho = function(_2) {
    var _1 = Math.max(1e-3, +_2), _22 = _1 * _1, _4 = _22 * _22;
    return zoomRho(_1, _22, _4);
  };
  return zoom2;
}(Math.SQRT2, 2, 4);
var frame = 0, timeout$1 = 0, interval = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t2 = new Timer();
  t2.restart(callback, delay, time);
  return t2;
}
function timerFlush() {
  now();
  ++frame;
  var t2 = taskHead, e2;
  while (t2) {
    if ((e2 = clockNow - t2._time) >= 0) t2._call.call(void 0, e2);
    t2 = t2._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame) return;
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time) {
  var t2 = new Timer();
  delay = delay == null ? 0 : +delay;
  t2.restart((elapsed) => {
    t2.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t2;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node, name, id2, index2, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id2 in schedules) return;
  create(node, id2, {
    name,
    index: index2,
    // For context during callback.
    group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init$1(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > CREATED) throw new Error("too late; already scheduled");
  return schedule2;
}
function set(node, id2) {
  var schedule2 = get(node, id2);
  if (schedule2.state > STARTED) throw new Error("too late; already running");
  return schedule2;
}
function get(node, id2) {
  var schedule2 = node.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2])) throw new Error("transition not found");
  return schedule2;
}
function create(node, id2, self) {
  var schedules = node.__transition, tween;
  schedules[id2] = self;
  self.timer = timer(schedule2, 0, self.time);
  function schedule2(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start2, self.delay, self.time);
    if (self.delay <= elapsed) start2(elapsed - self.delay);
  }
  function start2(elapsed) {
    var i, j, n2, o2;
    if (self.state !== SCHEDULED) return stop();
    for (i in schedules) {
      o2 = schedules[i];
      if (o2.name !== self.name) continue;
      if (o2.state === STARTED) return timeout(start2);
      if (o2.state === RUNNING) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("interrupt", node, node.__data__, o2.index, o2.group);
        delete schedules[i];
      } else if (+i < id2) {
        o2.state = ENDED;
        o2.timer.stop();
        o2.on.call("cancel", node, node.__data__, o2.index, o2.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return;
    self.state = STARTED;
    tween = new Array(n2 = self.tween.length);
    for (i = 0, j = -1; i < n2; ++i) {
      if (o2 = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o2;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t2 = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1), i = -1, n2 = tween.length;
    while (++i < n2) {
      tween[i].call(node, t2);
    }
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }
  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id2];
    for (var i in schedules) return;
    delete node.__transition;
  }
}
function interrupt(node, name) {
  var schedules = node.__transition, schedule2, active, empty2 = true, i;
  if (!schedules) return;
  name = name == null ? null : name + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name) {
      empty2 = false;
      continue;
    }
    active = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2) delete node.__transition;
}
function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}
function tweenRemove(id2, name) {
  var tween0, tween1;
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n2 = tween1.length; i < n2; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function() {
    var schedule2 = set(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t2 = { name, value }, i = 0, n2 = tween1.length; i < n2; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t2;
          break;
        }
      }
      if (i === n2) tween1.push(t2);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name, value) {
  var id2 = this._id;
  name += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i = 0, n2 = tween.length, t2; i < n2; ++i) {
      if ((t2 = tween[i]).name === name) {
        return t2.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name, value));
}
function tweenValue(transition, name, value) {
  var id2 = transition._id;
  transition.each(function() {
    var schedule2 = set(this, id2);
    (schedule2.value || (schedule2.value = {}))[name] = value.apply(this, arguments);
  });
  return function(node) {
    return get(node, id2).value[name];
  };
}
function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c = color(b)) ? (b = c, interpolateRgb) : interpolateString)(a, b);
}
function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}
function attrInterpolate(name, i) {
  return function(t2) {
    this.setAttribute(name, i.call(this, t2));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t2) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t2));
  };
}
function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init$1(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init$1(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function") throw new Error();
  return function() {
    set(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
}
function easeVarying(id2, value) {
  return function() {
    var v2 = value.apply(this, arguments);
    if (typeof v2 !== "function") throw new Error();
    set(this, id2).ease = v2;
  };
}
function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error();
  return this.each(easeVarying(this._id, value));
}
function transition_filter(match) {
  if (typeof match !== "function") match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n2; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error();
  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n2 = group0.length, merge = merges[j] = new Array(n2), node, i = 0; i < n2; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t2) {
    var i = t2.indexOf(".");
    if (i >= 0) t2 = t2.slice(0, i);
    return !t2 || t2 === "start";
  });
}
function onFunction(id2, name, listener) {
  var on0, on1, sit = start(name) ? init$1 : set;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule2.on = on1;
  };
}
function transition_on(name, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name) : this.each(onFunction(id2, name, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id2) return;
    if (parent) parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, subgroup = subgroups[j] = new Array(n2), node, subnode, i = 0; i < n2; ++i) {
      if ((node = group[i]) && (subnode = select2.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id2, i, subgroup, get(node, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name, id2);
}
function transition_selectAll(select2) {
  var name = this._name, id2 = this._id;
  if (typeof select2 !== "function") select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        for (var children2 = select2.call(node, node.__data__, i, group), child, inherit2 = get(node, id2), k = 0, l = children2.length; k < l; ++k) {
          if (child = children2[k]) {
            schedule(child, name, id2, k, children2, inherit2);
          }
        }
        subgroups.push(children2);
        parents.push(node);
      }
    }
  }
  return new Transition(subgroups, parents, name, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}
function styleConstant(name, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name), value1 = value(this), string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove2;
  return function() {
    var schedule2 = set(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name)) : void 0;
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this.styleTween(name, styleNull(name, i)).on("end.style." + name, styleRemove(name)) : typeof value === "function" ? this.styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value))).each(styleMaybeRemove(this._id, name)) : this.styleTween(name, styleConstant(name, i, value), priority).on("end.style." + name, null);
}
function styleInterpolate(name, i, priority) {
  return function(t2) {
    this.style.setProperty(name, i.call(this, t2), priority);
  };
}
function styleTween(name, value, priority) {
  var t2, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t2 = (i0 = i) && styleInterpolate(name, i, priority);
    return t2;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t2) {
    this.textContent = i.call(this, t2);
  };
}
function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        var inherit2 = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end = { value: function() {
      if (--size === 0) resolve();
    } };
    that.each(function() {
      var schedule2 = set(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }
      schedule2.on = on1;
    });
    if (size === 0) resolve();
  });
}
var id = 0;
function Transition(groups, parents, name, id2) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id2;
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};
function cubicInOut(t2) {
  return ((t2 *= 2) <= 1 ? t2 * t2 * t2 : (t2 -= 2) * t2 * t2 + 2) / 2;
}
var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node, id2) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id2])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id2} not found`);
    }
  }
  return timing;
}
function selection_transition(name) {
  var id2, timing;
  if (name instanceof Transition) {
    id2 = name._id, name = name._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n2 = group.length, node, i = 0; i < n2; ++i) {
      if (node = group[i]) {
        schedule(node, name, id2, i, group, timing || inherit(node, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x1, y1, x2, y2) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else if (!(l01_2 > epsilon)) ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
      this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
    } else {
      var x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0) throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._ += "L" + x0 + "," + y0;
    }
    if (!r) return;
    if (da < 0) da = da % tau + tau;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } else if (da > epsilon) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function() {
    return this._;
  }
};
function count$1(node) {
  var sum2 = 0, children2 = node.children, i = children2 && children2.length;
  if (!i) sum2 = 1;
  else while (--i >= 0) sum2 += children2[i].value;
  node.value = sum2;
}
function node_count$1() {
  return this.eachAfter(count$1);
}
function node_each$1(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_eachBefore$1(callback, that) {
  var node = this, nodes = [node], children2, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children2 = node.children) {
      for (i = children2.length - 1; i >= 0; --i) {
        nodes.push(children2[i]);
      }
    }
  }
  return this;
}
function node_eachAfter$1(callback, that) {
  var node = this, nodes = [node], next = [], children2, i, n2, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children2 = node.children) {
      for (i = 0, n2 = children2.length; i < n2; ++i) {
        nodes.push(children2[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_find(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}
function node_sum$1(value) {
  return this.eachAfter(function(node) {
    var sum2 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0) sum2 += children2[i].value;
    node.value = sum2;
  });
}
function node_sort$1(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
function node_path$1(end) {
  var start2 = this, ancestor = leastCommonAncestor$1(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor$1(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}
function node_ancestors$1() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
function node_descendants$1() {
  return Array.from(this);
}
function node_leaves$1() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
function node_links$1() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
function* node_iterator() {
  var node = this, current, next = [node], children2, i, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children2 = node.children) {
        for (i = 0, n2 = children2.length; i < n2; ++i) {
          next.push(children2[i]);
        }
      }
    }
  } while (next.length);
}
function hierarchy$1(data, children2) {
  if (data instanceof Map) {
    data = [void 0, data];
    if (children2 === void 0) children2 = mapChildren;
  } else if (children2 === void 0) {
    children2 = objectChildren;
  }
  var root2 = new Node$1(data), node, nodes = [root2], child, childs, i, n2;
  while (node = nodes.pop()) {
    if ((childs = children2(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n2 - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node$1(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight$1);
}
function node_copy$1() {
  return hierarchy$1(this).eachBefore(copyData$1);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData$1(node) {
  if (node.data.value !== void 0) node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight$1(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node$1(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node$1.prototype = hierarchy$1.prototype = {
  constructor: Node$1,
  count: node_count$1,
  each: node_each$1,
  eachAfter: node_eachAfter$1,
  eachBefore: node_eachBefore$1,
  find: node_find,
  sum: node_sum$1,
  sort: node_sort$1,
  path: node_path$1,
  ancestors: node_ancestors$1,
  descendants: node_descendants$1,
  leaves: node_leaves$1,
  links: node_links$1,
  copy: node_copy$1,
  [Symbol.iterator]: node_iterator
};
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}
var preroot = { depth: -1 }, ambiguous = {}, imputed = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify() {
  var id2 = defaultId, parentId = defaultParentId, path2;
  function stratify2(data) {
    var nodes = Array.from(data), currentId = id2, currentParentId = parentId, n2, d, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    if (path2 != null) {
      const I = nodes.map((d2, i2) => normalize(path2(d2, i2, data)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i2 of P) {
        if (!S.has(i2)) {
          S.add(i2);
          I.push(i2);
          P.push(parentof(i2));
          nodes.push(imputed);
        }
      }
      currentId = (_2, i2) => I[i2];
      currentParentId = (_2, i2) => P[i2];
    }
    for (i = 0, n2 = nodes.length; i < n2; ++i) {
      d = nodes[i], node = nodes[i] = new Node$1(d);
      if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n2; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root2) throw new Error("multiple roots");
        root2 = node;
      }
    }
    if (!root2) throw new Error("no root");
    if (path2 != null) {
      while (root2.data === imputed && root2.children.length === 1) {
        root2 = root2.children[0], --n2;
      }
      for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
        node = nodes[i2];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }
    root2.parent = preroot;
    root2.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n2;
    }).eachBefore(computeHeight$1);
    root2.parent = null;
    if (n2 > 0) throw new Error("cycle");
    return root2;
  }
  stratify2.id = function(x2) {
    return arguments.length ? (id2 = optional(x2), stratify2) : id2;
  };
  stratify2.parentId = function(x2) {
    return arguments.length ? (parentId = optional(x2), stratify2) : parentId;
  };
  stratify2.path = function(x2) {
    return arguments.length ? (path2 = optional(x2), stratify2) : path2;
  };
  return stratify2;
}
function normalize(path2) {
  path2 = `${path2}`;
  let i = path2.length;
  if (slash(path2, i - 1) && !slash(path2, i - 2)) path2 = path2.slice(0, -1);
  return path2[0] === "/" ? path2 : `/${path2}`;
}
function parentof(path2) {
  let i = path2.length;
  if (i < 2) return "";
  while (--i > 1) if (slash(path2, i)) break;
  return path2.slice(0, i);
}
function slash(path2, i) {
  if (path2[i] === "/") {
    let k = 0;
    while (i > 0 && path2[--i] === "\\") ++k;
    if ((k & 1) === 0) return true;
  }
  return false;
}
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v2) {
  var children2 = v2.children;
  return children2 ? children2[0] : v2.t;
}
function nextRight(v2) {
  var children2 = v2.children;
  return children2 ? children2[children2.length - 1] : v2.t;
}
function moveSubtree$1(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v2) {
  var shift = 0, change = 0, children2 = v2.children, i = children2.length, w;
  while (--i >= 0) {
    w = children2[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v2, ancestor) {
  return vim.a.parent === v2.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node$1.prototype);
function treeRoot(root2) {
  var tree2 = new TreeNode(root2, 0), node, nodes = [tree2], child, children2, i, n2;
  while (node = nodes.pop()) {
    if (children2 = node._.children) {
      node.children = new Array(n2 = children2.length);
      for (i = n2 - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children2[i], i));
        child.parent = node;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree2(root2) {
    var t2 = treeRoot(root2);
    t2.eachAfter(firstWalk), t2.parent.m = -t2.z;
    t2.eachBefore(secondWalk);
    if (nodeSize) root2.eachBefore(sizeNode);
    else {
      var left = root2, right = root2, bottom = root2;
      root2.eachBefore(function(node) {
        if (node.x < left.x) left = node;
        if (node.x > right.x) right = node;
        if (node.depth > bottom.depth) bottom = node;
      });
      var s2 = left === right ? 1 : separation(left, right) / 2, tx = s2 - left.x, kx = dx / (right.x + s2 + tx), ky = dy / (bottom.depth || 1);
      root2.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root2;
  }
  function firstWalk(v2) {
    var children2 = v2.children, siblings = v2.parent.children, w = v2.i ? siblings[v2.i - 1] : null;
    if (children2) {
      executeShifts(v2);
      var midpoint = (children2[0].z + children2[children2.length - 1].z) / 2;
      if (w) {
        v2.z = w.z + separation(v2._, w._);
        v2.m = v2.z - midpoint;
      } else {
        v2.z = midpoint;
      }
    } else if (w) {
      v2.z = w.z + separation(v2._, w._);
    }
    v2.parent.A = apportion(v2, w, v2.parent.A || siblings[0]);
  }
  function secondWalk(v2) {
    v2._.x = v2.z + v2.parent.m;
    v2.m += v2.parent.m;
  }
  function apportion(v2, w, ancestor) {
    if (w) {
      var vip = v2, vop = v2, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v2;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree$1(nextAncestor(vim, v2, ancestor), v2, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v2;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree2.separation = function(x2) {
    return arguments.length ? (separation = x2, tree2) : separation;
  };
  tree2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
  };
  tree2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
  };
  return tree2;
}
function constant$1(x2) {
  return function constant2() {
    return x2;
  };
}
var slice$1 = Array.prototype.slice;
function x(p) {
  return p[0];
}
function y(p) {
  return p[1];
}
class Bump {
  constructor(context, x2) {
    this._context = context;
    this._x = x2;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x2, y2);
        else this._context.moveTo(x2, y2);
        break;
      }
      case 1:
        this._point = 2;
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x2) / 2, this._y0, this._x0, y2, x2, y2);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y2) / 2, x2, this._y0, x2, y2);
        break;
      }
    }
    this._x0 = x2, this._y0 = y2;
  }
}
function bumpX(context) {
  return new Bump(context, true);
}
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  let source = linkSource;
  let target = linkTarget;
  let x$1 = x;
  let y$1 = y;
  let context = null;
  let output = null;
  function link2() {
    let buffer;
    const argv = slice$1.call(arguments);
    const s2 = source.apply(this, argv);
    const t2 = target.apply(this, argv);
    if (context == null) output = curve(buffer = path());
    output.lineStart();
    argv[0] = s2, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
    argv[0] = t2, output.point(+x$1.apply(this, argv), +y$1.apply(this, argv));
    output.lineEnd();
    if (buffer) return output = null, buffer + "" || null;
  }
  link2.source = function(_2) {
    return arguments.length ? (source = _2, link2) : source;
  };
  link2.target = function(_2) {
    return arguments.length ? (target = _2, link2) : target;
  };
  link2.x = function(_2) {
    return arguments.length ? (x$1 = typeof _2 === "function" ? _2 : constant$1(+_2), link2) : x$1;
  };
  link2.y = function(_2) {
    return arguments.length ? (y$1 = typeof _2 === "function" ? _2 : constant$1(+_2), link2) : y$1;
  };
  link2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), link2) : context;
  };
  return link2;
}
function linkHorizontal() {
  return link(bumpX);
}
const constant = (x2) => () => x2;
function ZoomEvent(type, {
  sourceEvent: sourceEvent2,
  target,
  transform,
  dispatch: dispatch2
}) {
  Object.defineProperties(this, {
    type: { value: type, enumerable: true, configurable: true },
    sourceEvent: { value: sourceEvent2, enumerable: true, configurable: true },
    target: { value: target, enumerable: true, configurable: true },
    transform: { value: transform, enumerable: true, configurable: true },
    _: { value: dispatch2 }
  });
}
function Transform(k, x2, y2) {
  this.k = k;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
Transform.prototype;
function nopropagation(event) {
  event.stopImmediatePropagation();
}
function noevent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter(event) {
  return (!event.ctrlKey || event.type === "wheel") && !event.button;
}
function defaultExtent() {
  var e2 = this;
  if (e2 instanceof SVGElement) {
    e2 = e2.ownerSVGElement || e2;
    if (e2.hasAttribute("viewBox")) {
      e2 = e2.viewBox.baseVal;
      return [[e2.x, e2.y], [e2.x + e2.width, e2.y + e2.height]];
    }
    return [[0, 0], [e2.width.baseVal.value, e2.height.baseVal.value]];
  }
  return [[0, 0], [e2.clientWidth, e2.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity;
}
function defaultWheelDelta(event) {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3) * (event.ctrlKey ? 10 : 1);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0], dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0], dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1], dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter2 = defaultFilter, extent = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchfirst, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0, tapDistance = 10;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled, { passive: false }).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform, point, event) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule2(collection, transform, point, event);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).event(event).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k, p, event) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    }, p, event);
  };
  zoom2.scaleTo = function(selection2, k, p, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t0 = this.__zoom, p0 = p == null ? centroid(e2) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t0.invert(p0), k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate2(scale2(t0, k1), p0, p1), e2, translateExtent);
    }, p, event);
  };
  zoom2.translateBy = function(selection2, x2, y2, event) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 === "function" ? x2.apply(this, arguments) : x2,
        typeof y2 === "function" ? y2.apply(this, arguments) : y2
      ), extent.apply(this, arguments), translateExtent);
    }, null, event);
  };
  zoom2.translateTo = function(selection2, x2, y2, p, event) {
    zoom2.transform(selection2, function() {
      var e2 = extent.apply(this, arguments), t2 = this.__zoom, p0 = p == null ? centroid(e2) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p0[0], p0[1]).scale(t2.k).translate(
        typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
      ), e2, translateExtent);
    }, p, event);
  };
  function scale2(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);
  }
  function translate2(transform, p0, p1) {
    var x2 = p0[0] - p1[0] * transform.k, y2 = p0[1] - p1[1] * transform.k;
    return x2 === transform.x && y2 === transform.y ? transform : new Transform(transform.k, x2, y2);
  }
  function centroid(extent2) {
    return [(+extent2[0][0] + +extent2[1][0]) / 2, (+extent2[0][1] + +extent2[1][1]) / 2];
  }
  function schedule2(transition, transform, point, event) {
    transition.on("start.zoom", function() {
      gesture(this, arguments).event(event).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).event(event).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args).event(event), e2 = extent.apply(that, args), p = point == null ? centroid(e2) : typeof point === "function" ? point.apply(that, args) : point, w = Math.max(e2[1][0] - e2[0][0], e2[1][1] - e2[0][1]), a = that.__zoom, b = typeof transform === "function" ? transform.apply(that, args) : transform, i = interpolate2(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function(t2) {
        if (t2 === 1) t2 = b;
        else {
          var l = i(t2), k = w / l[2];
          t2 = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
        }
        g.zoom(null, t2);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.sourceEvent = null;
    this.extent = extent.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    event: function(event) {
      if (event) this.sourceEvent = event;
      return this;
    },
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type) {
      var d = select(this.that).datum();
      listeners.call(
        type,
        this.that,
        new ZoomEvent(type, {
          sourceEvent: this.sourceEvent,
          target: zoom2,
          type,
          transform: this.that.__zoom,
          dispatch: listeners
        }),
        d
      );
    }
  };
  function wheeled(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var g = gesture(this, args).event(event), t2 = this.__zoom, k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t2.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = pointer(event);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t2.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t2.k === k) return;
    else {
      g.mouse = [p, t2.invert(p)];
      interrupt(this);
      g.start();
    }
    noevent(event);
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate2(scale2(t2, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned(event, ...args) {
    if (touchending || !filter2.apply(this, arguments)) return;
    var currentTarget = event.currentTarget, g = gesture(this, args, true).event(event), v2 = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = pointer(event, currentTarget), x0 = event.clientX, y0 = event.clientY;
    dragDisable(event.view);
    nopropagation(event);
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();
    function mousemoved(event2) {
      noevent(event2);
      if (!g.moved) {
        var dx = event2.clientX - x0, dy = event2.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.event(event2).zoom("mouse", constrain(translate2(g.that.__zoom, g.mouse[0] = pointer(event2, currentTarget), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped(event2) {
      v2.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event2.view, g.moved);
      noevent(event2);
      g.event(event2).end();
    }
  }
  function dblclicked(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var t0 = this.__zoom, p0 = pointer(event.changedTouches ? event.changedTouches[0] : event, this), p1 = t0.invert(p0), k1 = t0.k * (event.shiftKey ? 0.5 : 2), t1 = constrain(translate2(scale2(t0, k1), p0, p1), extent.apply(this, args), translateExtent);
    noevent(event);
    if (duration > 0) select(this).transition().duration(duration).call(schedule2, t1, p0, event);
    else select(this).call(zoom2.transform, t1, p0, event);
  }
  function touchstarted(event, ...args) {
    if (!filter2.apply(this, arguments)) return;
    var touches = event.touches, n2 = touches.length, g = gesture(this, args, event.changedTouches.length === n2).event(event), started, i, t2, p;
    nopropagation(event);
    for (i = 0; i < n2; ++i) {
      t2 = touches[i], p = pointer(t2, this);
      p = [p, this.__zoom.invert(p), t2.identifier];
      if (!g.touch0) g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2]) g.touch1 = p, g.taps = 0;
    }
    if (touchstarting) touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2) touchfirst = p[0], touchstarting = setTimeout(function() {
        touchstarting = null;
      }, touchDelay);
      interrupt(this);
      g.start();
    }
  }
  function touchmoved(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i, t2, p, l;
    noevent(event);
    for (i = 0; i < n2; ++i) {
      t2 = touches[i], p = pointer(t2, this);
      if (g.touch0 && g.touch0[2] === t2.identifier) g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t2.identifier) g.touch1[0] = p;
    }
    t2 = g.that.__zoom;
    if (g.touch1) {
      var p0 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t2 = scale2(t2, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];
    else return;
    g.zoom("touch", constrain(translate2(t2, p, l), g.extent, translateExtent));
  }
  function touchended(event, ...args) {
    if (!this.__zooming) return;
    var g = gesture(this, args).event(event), touches = event.changedTouches, n2 = touches.length, i, t2;
    nopropagation(event);
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n2; ++i) {
      t2 = touches[i];
      if (g.touch0 && g.touch0[2] === t2.identifier) delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t2.identifier) delete g.touch1;
    }
    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        t2 = pointer(t2, this);
        if (Math.hypot(touchfirst[0] - t2[0], touchfirst[1] - t2[1]) < tapDistance) {
          var p = select(this).on("dblclick.zoom");
          if (p) p.apply(this, arguments);
        }
      }
    }
  }
  zoom2.wheelDelta = function(_2) {
    return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant(+_2), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_2) {
    return arguments.length ? (filter2 = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : filter2;
  };
  zoom2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : touchable;
  };
  zoom2.extent = function(_2) {
    return arguments.length ? (extent = typeof _2 === "function" ? _2 : constant([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent;
  };
  zoom2.scaleExtent = function(_2) {
    return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_2) {
    return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_2) {
    return arguments.length ? (constrain = _2, zoom2) : constrain;
  };
  zoom2.duration = function(_2) {
    return arguments.length ? (duration = +_2, zoom2) : duration;
  };
  zoom2.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, zoom2) : interpolate2;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
  };
  zoom2.tapDistance = function(_2) {
    return arguments.length ? (tapDistance = +_2, zoom2) : tapDistance;
  };
  return zoom2;
}
const _sfc_main$L = {
  name: "ChartTemplate",
  components: {
    Avatar: NcAvatar
  },
  props: {
    data: {
      type: Object,
      default: () => {
      }
    },
    onAvatarClick: {
      type: Function,
      default: () => {
      }
    }
  },
  computed: {
    selectedChart() {
      return this.$route.params.selectedChart;
    }
  }
};
var _sfc_render$L = function render33() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "org-chart-node" }, [_c("div", { staticClass: "inner-box" }, [_c("router-link", { attrs: { "to": {
    name: "contact",
    params: {
      selectedGroup: _vm.selectedChart,
      selectedContact: _vm.data.key
    }
  } } }, [_c("Avatar", { staticClass: "org-chart-node__avatar", attrs: { "disable-tooltip": true, "display-name": _vm.data.fullName, "is-no-user": true, "size": 60, "url": _vm.data.photoUrl } })], 1), _c("div", { staticClass: "panel" }), _c("div", { staticClass: "main-container" }, [_c("h3", { staticClass: "fullName" }, [_vm._v(" " + _vm._s(_vm.data.fullName) + " ")]), _c("h4", { staticClass: "title" }, [_vm._v(" " + _vm._s(_vm.data.title) + " ")])]), _c("div", { staticClass: "description" }, [_vm.data._directSubordinates ? _c("p", [_vm._v(" " + _vm._s(_vm.t("contacts", "Manages")) + ": " + _vm._s(_vm.data._directSubordinates) + " ")]) : _vm._e(), _vm.data._totalSubordinates ? _c("p", [_vm._v(" " + _vm._s(_vm.t("contacts", "Oversees")) + ": " + _vm._s(_vm.data._totalSubordinates) + " ")]) : _vm._e()])], 1)]);
};
var _sfc_staticRenderFns$L = [];
var __component__$L = /* @__PURE__ */ normalizeComponent(
  _sfc_main$L,
  _sfc_render$L,
  _sfc_staticRenderFns$L,
  false,
  null,
  "3b98df70"
);
const ChartTemplate = __component__$L.exports;
function count(node) {
  var sum2 = 0, children2 = node.children, i = children2 && children2.length;
  if (!i) sum2 = 1;
  else while (--i >= 0) sum2 += children2[i].value;
  node.value = sum2;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback) {
  var node = this, current, next = [node], children2, i, n2;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      callback(node), children2 = node.children;
      if (children2) for (i = 0, n2 = children2.length; i < n2; ++i) {
        next.push(children2[i]);
      }
    }
  } while (next.length);
  return this;
}
function node_eachBefore(callback) {
  var node = this, nodes = [node], children2, i;
  while (node = nodes.pop()) {
    callback(node), children2 = node.children;
    if (children2) for (i = children2.length - 1; i >= 0; --i) {
      nodes.push(children2[i]);
    }
  }
  return this;
}
function node_eachAfter(callback) {
  var node = this, nodes = [node], next = [], children2, i, n2;
  while (node = nodes.pop()) {
    next.push(node), children2 = node.children;
    if (children2) for (i = 0, n2 = children2.length; i < n2; ++i) {
      nodes.push(children2[i]);
    }
  }
  while (node = next.pop()) {
    callback(node);
  }
  return this;
}
function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum2 = +value(node.data) || 0, children2 = node.children, i = children2 && children2.length;
    while (--i >= 0) sum2 += children2[i].value;
    node.value = sum2;
  });
}
function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
function node_path(end) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}
function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
function node_descendants() {
  var nodes = [];
  this.each(function(node) {
    nodes.push(node);
  });
  return nodes;
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links = [];
  root2.each(function(node) {
    if (node !== root2) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
function hierarchy(data, children2) {
  var root2 = new Node(data), valued = +data.value && (root2.value = data.value), node, nodes = [root2], child, childs, i, n2;
  if (children2 == null) children2 = defaultChildren;
  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;
    if ((childs = children2(node.data)) && (n2 = childs.length)) {
      node.children = new Array(n2);
      for (i = n2 - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function defaultChildren(d) {
  return d.children;
}
function copyData(node) {
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};
const name$1 = "d3-flextree";
const version$2 = "2.1.2";
const main = "build/d3-flextree.js";
const module = "index";
const author = {
  name: "Chris Maloney",
  url: "http://chrismaloney.org"
};
const description = "Flexible tree layout algorithm that allows for variable node sizes.";
const keywords = [
  "d3",
  "d3-module",
  "layout",
  "tree",
  "hierarchy",
  "d3-hierarchy",
  "plugin",
  "d3-plugin",
  "infovis",
  "visualization",
  "2d"
];
const homepage = "https://github.com/klortho/d3-flextree";
const license = "WTFPL";
const repository = {
  type: "git",
  url: "https://github.com/klortho/d3-flextree.git"
};
const scripts = {
  clean: "rm -rf build demo test",
  "build:demo": "rollup -c --environment BUILD:demo",
  "build:dev": "rollup -c --environment BUILD:dev",
  "build:prod": "rollup -c --environment BUILD:prod",
  "build:test": "rollup -c --environment BUILD:test",
  build: "rollup -c",
  lint: "eslint index.js src",
  "test:main": "node test/bundle.js",
  "test:browser": "node test/browser-tests.js",
  test: "npm-run-all test:*",
  prepare: "npm-run-all clean build lint test"
};
const dependencies = {
  "d3-hierarchy": "^1.1.5"
};
const devDependencies = {
  "babel-plugin-external-helpers": "^6.22.0",
  "babel-preset-es2015-rollup": "^3.0.0",
  d3: "^4.13.0",
  "d3-selection-multi": "^1.0.1",
  eslint: "^4.19.1",
  jsdom: "^11.6.2",
  "npm-run-all": "^4.1.2",
  rollup: "^0.55.3",
  "rollup-plugin-babel": "^2.7.1",
  "rollup-plugin-commonjs": "^8.0.2",
  "rollup-plugin-copy": "^0.2.3",
  "rollup-plugin-json": "^2.3.0",
  "rollup-plugin-node-resolve": "^3.0.2",
  "rollup-plugin-uglify": "^3.0.0",
  "uglify-es": "^3.3.9"
};
const packageInfo = {
  name: name$1,
  version: version$2,
  main,
  module,
  "jsnext:main": "index",
  author,
  description,
  keywords,
  homepage,
  license,
  repository,
  scripts,
  dependencies,
  devDependencies
};
const { version: version$1 } = packageInfo;
const defaults = Object.freeze({
  children: (data) => data.children,
  nodeSize: (node) => node.data.size,
  spacing: 0
});
function flextree(options) {
  const opts = Object.assign({}, defaults, options);
  function accessor(name) {
    const opt = opts[name];
    return typeof opt === "function" ? opt : () => opt;
  }
  function layout(tree2) {
    const wtree = wrap(getWrapper(), tree2, (node) => node.children);
    wtree.update();
    return wtree.data;
  }
  function getFlexNode() {
    const nodeSize = accessor("nodeSize");
    const spacing = accessor("spacing");
    return class FlexNode extends hierarchy.prototype.constructor {
      constructor(data) {
        super(data);
      }
      copy() {
        const c = wrap(this.constructor, this, (node) => node.children);
        c.each((node) => node.data = node.data.data);
        return c;
      }
      get size() {
        return nodeSize(this);
      }
      spacing(oNode) {
        return spacing(this, oNode);
      }
      get nodes() {
        return this.descendants();
      }
      get xSize() {
        return this.size[0];
      }
      get ySize() {
        return this.size[1];
      }
      get top() {
        return this.y;
      }
      get bottom() {
        return this.y + this.ySize;
      }
      get left() {
        return this.x - this.xSize / 2;
      }
      get right() {
        return this.x + this.xSize / 2;
      }
      get root() {
        const ancs = this.ancestors();
        return ancs[ancs.length - 1];
      }
      get numChildren() {
        return this.hasChildren ? this.children.length : 0;
      }
      get hasChildren() {
        return !this.noChildren;
      }
      get noChildren() {
        return this.children === null;
      }
      get firstChild() {
        return this.hasChildren ? this.children[0] : null;
      }
      get lastChild() {
        return this.hasChildren ? this.children[this.numChildren - 1] : null;
      }
      get extents() {
        return (this.children || []).reduce(
          (acc, kid) => FlexNode.maxExtents(acc, kid.extents),
          this.nodeExtents
        );
      }
      get nodeExtents() {
        return {
          top: this.top,
          bottom: this.bottom,
          left: this.left,
          right: this.right
        };
      }
      static maxExtents(e0, e1) {
        return {
          top: Math.min(e0.top, e1.top),
          bottom: Math.max(e0.bottom, e1.bottom),
          left: Math.min(e0.left, e1.left),
          right: Math.max(e0.right, e1.right)
        };
      }
    };
  }
  function getWrapper() {
    const FlexNode = getFlexNode();
    const nodeSize = accessor("nodeSize");
    const spacing = accessor("spacing");
    return class extends FlexNode {
      constructor(data) {
        super(data);
        Object.assign(this, {
          x: 0,
          y: 0,
          relX: 0,
          prelim: 0,
          shift: 0,
          change: 0,
          lExt: this,
          lExtRelX: 0,
          lThr: null,
          rExt: this,
          rExtRelX: 0,
          rThr: null
        });
      }
      get size() {
        return nodeSize(this.data);
      }
      spacing(oNode) {
        return spacing(this.data, oNode.data);
      }
      get x() {
        return this.data.x;
      }
      set x(v2) {
        this.data.x = v2;
      }
      get y() {
        return this.data.y;
      }
      set y(v2) {
        this.data.y = v2;
      }
      update() {
        layoutChildren(this);
        resolveX(this);
        return this;
      }
    };
  }
  function wrap(FlexClass, treeData, children2) {
    const _wrap = (data, parent) => {
      const node = new FlexClass(data);
      Object.assign(node, {
        parent,
        depth: parent === null ? 0 : parent.depth + 1,
        height: 0,
        length: 1
      });
      const kidsData = children2(data) || [];
      node.children = kidsData.length === 0 ? null : kidsData.map((kd) => _wrap(kd, node));
      if (node.children) {
        Object.assign(node, node.children.reduce(
          (hl, kid) => ({
            height: Math.max(hl.height, kid.height + 1),
            length: hl.length + kid.length
          }),
          node
        ));
      }
      return node;
    };
    return _wrap(treeData, null);
  }
  Object.assign(layout, {
    nodeSize(arg) {
      return arguments.length ? (opts.nodeSize = arg, layout) : opts.nodeSize;
    },
    spacing(arg) {
      return arguments.length ? (opts.spacing = arg, layout) : opts.spacing;
    },
    children(arg) {
      return arguments.length ? (opts.children = arg, layout) : opts.children;
    },
    hierarchy(treeData, children2) {
      const kids = typeof children2 === "undefined" ? opts.children : children2;
      return wrap(getFlexNode(), treeData, kids);
    },
    dump(tree2) {
      const nodeSize = accessor("nodeSize");
      const _dump = (i0) => (node) => {
        const i1 = i0 + "  ";
        const i2 = i0 + "    ";
        const { x: x2, y: y2 } = node;
        const size = nodeSize(node);
        const kids = node.children || [];
        const kdumps = kids.length === 0 ? " " : `,${i1}children: [${i2}${kids.map(_dump(i2)).join(i2)}${i1}],${i0}`;
        return `{ size: [${size.join(", ")}],${i1}x: ${x2}, y: ${y2}${kdumps}},`;
      };
      return _dump("\n")(tree2);
    }
  });
  return layout;
}
flextree.version = version$1;
const layoutChildren = (w, y2 = 0) => {
  w.y = y2;
  (w.children || []).reduce((acc, kid) => {
    const [i, lastLows] = acc;
    layoutChildren(kid, w.y + w.ySize);
    const lowY = (i === 0 ? kid.lExt : kid.rExt).bottom;
    if (i !== 0) separate(w, i, lastLows);
    const lows = updateLows(lowY, i, lastLows);
    return [i + 1, lows];
  }, [0, null]);
  shiftChange(w);
  positionRoot(w);
  return w;
};
const resolveX = (w, prevSum, parentX) => {
  if (typeof prevSum === "undefined") {
    prevSum = -w.relX - w.prelim;
    parentX = 0;
  }
  const sum2 = prevSum + w.relX;
  w.relX = sum2 + w.prelim - parentX;
  w.prelim = 0;
  w.x = parentX + w.relX;
  (w.children || []).forEach((k) => resolveX(k, sum2, w.x));
  return w;
};
const shiftChange = (w) => {
  (w.children || []).reduce((acc, child) => {
    const [lastShiftSum, lastChangeSum] = acc;
    const shiftSum = lastShiftSum + child.shift;
    const changeSum = lastChangeSum + shiftSum + child.change;
    child.relX += changeSum;
    return [shiftSum, changeSum];
  }, [0, 0]);
};
const separate = (w, i, lows) => {
  const lSib = w.children[i - 1];
  const curSubtree = w.children[i];
  let rContour = lSib;
  let rSumMods = lSib.relX;
  let lContour = curSubtree;
  let lSumMods = curSubtree.relX;
  let isFirst = true;
  while (rContour && lContour) {
    if (rContour.bottom > lows.lowY) lows = lows.next;
    const dist2 = rSumMods + rContour.prelim - (lSumMods + lContour.prelim) + rContour.xSize / 2 + lContour.xSize / 2 + rContour.spacing(lContour);
    if (dist2 > 0 || dist2 < 0 && isFirst) {
      lSumMods += dist2;
      moveSubtree(curSubtree, dist2);
      distributeExtra(w, i, lows.index, dist2);
    }
    isFirst = false;
    const rightBottom = rContour.bottom;
    const leftBottom = lContour.bottom;
    if (rightBottom <= leftBottom) {
      rContour = nextRContour(rContour);
      if (rContour) rSumMods += rContour.relX;
    }
    if (rightBottom >= leftBottom) {
      lContour = nextLContour(lContour);
      if (lContour) lSumMods += lContour.relX;
    }
  }
  if (!rContour && lContour) setLThr(w, i, lContour, lSumMods);
  else if (rContour && !lContour) setRThr(w, i, rContour, rSumMods);
};
const moveSubtree = (subtree, distance) => {
  subtree.relX += distance;
  subtree.lExtRelX += distance;
  subtree.rExtRelX += distance;
};
const distributeExtra = (w, curSubtreeI, leftSibI, dist2) => {
  const curSubtree = w.children[curSubtreeI];
  const n2 = curSubtreeI - leftSibI;
  if (n2 > 1) {
    const delta = dist2 / n2;
    w.children[leftSibI + 1].shift += delta;
    curSubtree.shift -= delta;
    curSubtree.change -= dist2 - delta;
  }
};
const nextLContour = (w) => {
  return w.hasChildren ? w.firstChild : w.lThr;
};
const nextRContour = (w) => {
  return w.hasChildren ? w.lastChild : w.rThr;
};
const setLThr = (w, i, lContour, lSumMods) => {
  const firstChild = w.firstChild;
  const lExt = firstChild.lExt;
  const curSubtree = w.children[i];
  lExt.lThr = lContour;
  const diff = lSumMods - lContour.relX - firstChild.lExtRelX;
  lExt.relX += diff;
  lExt.prelim -= diff;
  firstChild.lExt = curSubtree.lExt;
  firstChild.lExtRelX = curSubtree.lExtRelX;
};
const setRThr = (w, i, rContour, rSumMods) => {
  const curSubtree = w.children[i];
  const rExt = curSubtree.rExt;
  const lSib = w.children[i - 1];
  rExt.rThr = rContour;
  const diff = rSumMods - rContour.relX - curSubtree.rExtRelX;
  rExt.relX += diff;
  rExt.prelim -= diff;
  curSubtree.rExt = lSib.rExt;
  curSubtree.rExtRelX = lSib.rExtRelX;
};
const positionRoot = (w) => {
  if (w.hasChildren) {
    const k0 = w.firstChild;
    const kf = w.lastChild;
    const prelim = (k0.prelim + k0.relX - k0.xSize / 2 + kf.relX + kf.prelim + kf.xSize / 2) / 2;
    Object.assign(w, {
      prelim,
      lExt: k0.lExt,
      lExtRelX: k0.lExtRelX,
      rExt: kf.rExt,
      rExtRelX: kf.rExtRelX
    });
  }
};
const updateLows = (lowY, index2, lastLows) => {
  while (lastLows !== null && lowY >= lastLows.lowY)
    lastLows = lastLows.next;
  return {
    lowY,
    index: index2,
    next: lastLows
  };
};
const d3 = {
  selection,
  select,
  max,
  min,
  sum,
  cumsum,
  tree,
  stratify,
  zoom,
  zoomIdentity: identity,
  linkHorizontal,
  flextree
};
let OrgChart$1 = class OrgChart {
  constructor() {
    const attrs = {
      /* NOT INTENDED FOR PUBLIC OVERRIDE */
      id: `ID${Math.floor(Math.random() * 1e6)}`,
      // Id for event handlings
      firstDraw: true,
      // Whether chart is drawn for the first time
      ctx: document.createElement("canvas").getContext("2d"),
      initialExpandLevel: 1,
      nodeDefaultBackground: "none",
      lastTransform: { x: 0, y: 0, k: 1 },
      // Panning and zooming values
      allowedNodesCount: {},
      zoomBehavior: null,
      generateRoot: null,
      /*  INTENDED FOR PUBLIC OVERRIDE */
      svgWidth: 800,
      // Configure svg width
      svgHeight: window.innerHeight - 100,
      // Configure svg height
      container: "body",
      // Set parent container, either CSS style selector or DOM element
      data: null,
      // Set data, it must be an array of objects, where hierarchy is clearly defined via id and parent ID (property names are configurable)
      connections: [],
      // Sets connection data, array of objects, SAMPLE:  [{from:"145",to:"201",label:"Conflicts of interest"}]
      defaultFont: "Helvetica",
      // Set default font
      nodeId: (d) => d.nodeId || d.id,
      // Configure accessor for node id, default is either odeId or id
      parentNodeId: (d) => d.parentNodeId || d.parentId,
      // Configure accessor for parent node id, default is either parentNodeId or parentId
      rootMargin: 40,
      // Configure how much root node is offset from top
      nodeWidth: (d3Node) => 250,
      // Configure each node width, use with caution, it is better to have the same value set for all nodes
      nodeHeight: (d) => 150,
      //  Configure each node height, use with caution, it is better to have the same value set for all nodes
      neighbourMargin: (n1, n2) => 80,
      // Configure margin between two nodes, use with caution, it is better to have the same value set for all nodes
      siblingsMargin: (d3Node) => 20,
      // Configure margin between two siblings, use with caution, it is better to have the same value set for all nodes
      childrenMargin: (d) => 60,
      // Configure margin between parent and children, use with caution, it is better to have the same value set for all nodes
      compactMarginPair: (d) => 100,
      // Configure margin between two nodes in compact mode, use with caution, it is better to have the same value set for all nodes
      compactMarginBetween: (d3Node) => 20,
      // Configure margin between two nodes in compact mode, use with caution, it is better to have the same value set for all nodes
      nodeButtonWidth: (d) => 40,
      // Configure expand & collapse button width
      nodeButtonHeight: (d) => 40,
      // Configure expand & collapse button height
      nodeButtonX: (d) => -20,
      // Configure expand & collapse button x position
      nodeButtonY: (d) => -20,
      // Configure expand & collapse button y position
      linkYOffset: 30,
      // When correcting links which is not working for safari
      pagingStep: (d) => 5,
      // Configure how many nodes to show when making new nodes appear
      minPagingVisibleNodes: (d) => 2e3,
      // Configure minimum number of visible nodes , after which paging button appears
      scaleExtent: [1e-3, 20],
      // Configure zoom scale extent , if you don't want any kind of zooming, set it to [1,1]
      duration: 400,
      // Configure duration of transitions
      imageName: "Chart",
      // Configure exported PNG and SVG image name
      setActiveNodeCentered: true,
      // Configure if active node should be centered when expanded and collapsed
      layout: "top",
      // Configure layout direction , possible values are "top", "left", "right", "bottom"
      compact: true,
      // Configure if compact mode is enabled , when enabled, nodes are shown in compact positions, instead of horizontal spread
      createZoom: (d) => d3.zoom(),
      onZoomStart: (e2) => {
      },
      // Callback for zoom & panning start
      onZoom: (e2) => {
      },
      // Callback for zoom & panning 
      onZoomEnd: (e2) => {
      },
      // Callback for zoom & panning end
      onNodeClick: (d) => d,
      // Callback for node click
      onExpandOrCollapse: (d) => d,
      // Callback for node expand or collapse
      /*
                  * Node HTML content generation , remember that you can access some helper methods:
      
                  * node=> node.data - to access node's original data
                  * node=> node.leaves() - to access node's leaves
                  * node=> node.descendants() - to access node's descendants
                  * node=> node.children - to access node's children
                  * node=> node.parent - to access node's parent
                  * node=> node.depth - to access node's depth
                  * node=> node.hierarchyHeight - to access node's hierarchy height ( Height, which d3 assigns to hierarchy nodes)
                  * node=> node.height - to access node's height
                  * node=> node.width - to access node's width
                  * 
                  * You can also access additional properties to style your node:
                  * 
                  * d=>d.data._centeredWithDescendants - when node is centered with descendants
                  * d=>d.data._directSubordinatesPaging - subordinates count in paging mode
                  * d=>d.data._directSubordinates - subordinates count
                  * d=>d.data._totalSubordinates - total subordinates count
                  * d=>d._highlighted - when node is highlighted
                  * d=>d._upToTheRootHighlighted - when node is highlighted up to the root
                  * d=>d._expanded - when node is expanded
                  * d=>d.data._centered - when node is centered
                  */
      nodeContent: (d) => `<div style="padding:5px;font-size:10px;">Sample Node(id=${d.id}), override using <br/> 
            <code>chart.nodeContent({data}=>{ <br/>
             &nbsp;&nbsp;&nbsp;&nbsp;return '' // Custom HTML <br/>
             })</code>
             <br/> 
             Or check different <a href="https://github.com/bumbeishvili/org-chart#jump-to-examples" target="_blank">layout examples</a>
             </div>`,
      /* Node expand & collapse button content and styling. You can access same helper methods as above */
      buttonContent: ({ node, state }) => {
        const icons = {
          "left": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M14.283 3.50094L6.51 11.4749C6.37348 11.615 6.29707 11.8029 6.29707 11.9984C6.29707 12.194 6.37348 12.3819 6.51 12.5219L14.283 20.4989C14.3466 20.5643 14.4226 20.6162 14.5066 20.6516C14.5906 20.6871 14.6808 20.7053 14.772 20.7053C14.8632 20.7053 14.9534 20.6871 15.0374 20.6516C15.1214 20.6162 15.1974 20.5643 15.261 20.4989C15.3918 20.365 15.4651 20.1852 15.4651 19.9979C15.4651 19.8107 15.3918 19.6309 15.261 19.4969L7.9515 11.9984L15.261 4.50144C15.3914 4.36756 15.4643 4.18807 15.4643 4.00119C15.4643 3.81431 15.3914 3.63482 15.261 3.50094C15.1974 3.43563 15.1214 3.38371 15.0374 3.34827C14.9534 3.31282 14.8632 3.29456 14.772 3.29456C14.6808 3.29456 14.5906 3.31282 14.5066 3.34827C14.4226 3.38371 14.3466 3.43563 14.283 3.50094V3.50094Z" fill="#716E7B" stroke="#716E7B"/>
                      </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                          <path d="M7.989 3.49944C7.85817 3.63339 7.78492 3.8132 7.78492 4.00044C7.78492 4.18768 7.85817 4.36749 7.989 4.50144L15.2985 11.9999L7.989 19.4969C7.85817 19.6309 7.78492 19.8107 7.78492 19.9979C7.78492 20.1852 7.85817 20.365 7.989 20.4989C8.05259 20.5643 8.12863 20.6162 8.21261 20.6516C8.2966 20.6871 8.38684 20.7053 8.478 20.7053C8.56916 20.7053 8.6594 20.6871 8.74338 20.6516C8.82737 20.6162 8.90341 20.5643 8.967 20.4989L16.74 12.5234C16.8765 12.3834 16.9529 12.1955 16.9529 11.9999C16.9529 11.8044 16.8765 11.6165 16.74 11.4764L8.967 3.50094C8.90341 3.43563 8.82737 3.38371 8.74338 3.34827C8.6594 3.31282 8.56916 3.29456 8.478 3.29456C8.38684 3.29456 8.2966 3.31282 8.21261 3.34827C8.12863 3.38371 8.05259 3.43563 7.989 3.50094V3.49944Z" fill="#716E7B" stroke="#716E7B"/>
                          </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>`,
          "bottom": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M19.497 7.98903L12 15.297L4.503 7.98903C4.36905 7.85819 4.18924 7.78495 4.002 7.78495C3.81476 7.78495 3.63495 7.85819 3.501 7.98903C3.43614 8.05257 3.38462 8.12842 3.34944 8.21213C3.31427 8.29584 3.29615 8.38573 3.29615 8.47653C3.29615 8.56733 3.31427 8.65721 3.34944 8.74092C3.38462 8.82463 3.43614 8.90048 3.501 8.96403L11.4765 16.74C11.6166 16.8765 11.8044 16.953 12 16.953C12.1956 16.953 12.3834 16.8765 12.5235 16.74L20.499 8.96553C20.5643 8.90193 20.6162 8.8259 20.6517 8.74191C20.6871 8.65792 20.7054 8.56769 20.7054 8.47653C20.7054 8.38537 20.6871 8.29513 20.6517 8.21114C20.6162 8.12715 20.5643 8.05112 20.499 7.98753C20.3651 7.85669 20.1852 7.78345 19.998 7.78345C19.8108 7.78345 19.6309 7.85669 19.497 7.98753V7.98903Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="margin-left:1px;color:#716E7B" >${node.data._directSubordinatesPaging} </span></div>
                       ` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M11.457 8.07005L3.49199 16.4296C3.35903 16.569 3.28485 16.7543 3.28485 16.9471C3.28485 17.1398 3.35903 17.3251 3.49199 17.4646L3.50099 17.4736C3.56545 17.5414 3.64304 17.5954 3.72904 17.6324C3.81504 17.6693 3.90765 17.6883 4.00124 17.6883C4.09483 17.6883 4.18745 17.6693 4.27344 17.6324C4.35944 17.5954 4.43703 17.5414 4.50149 17.4736L12.0015 9.60155L19.4985 17.4736C19.563 17.5414 19.6405 17.5954 19.7265 17.6324C19.8125 17.6693 19.9052 17.6883 19.9987 17.6883C20.0923 17.6883 20.1849 17.6693 20.2709 17.6324C20.3569 17.5954 20.4345 17.5414 20.499 17.4736L20.508 17.4646C20.641 17.3251 20.7151 17.1398 20.7151 16.9471C20.7151 16.7543 20.641 16.569 20.508 16.4296L12.543 8.07005C12.4729 7.99653 12.3887 7.93801 12.2954 7.89801C12.202 7.85802 12.1015 7.8374 12 7.8374C11.8984 7.8374 11.798 7.85802 11.7046 7.89801C11.6113 7.93801 11.527 7.99653 11.457 8.07005Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="margin-left:1px;color:#716E7B" >${node.data._directSubordinatesPaging} </span></div>
                    `,
          "right": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M7.989 3.49944C7.85817 3.63339 7.78492 3.8132 7.78492 4.00044C7.78492 4.18768 7.85817 4.36749 7.989 4.50144L15.2985 11.9999L7.989 19.4969C7.85817 19.6309 7.78492 19.8107 7.78492 19.9979C7.78492 20.1852 7.85817 20.365 7.989 20.4989C8.05259 20.5643 8.12863 20.6162 8.21261 20.6516C8.2966 20.6871 8.38684 20.7053 8.478 20.7053C8.56916 20.7053 8.6594 20.6871 8.74338 20.6516C8.82737 20.6162 8.90341 20.5643 8.967 20.4989L16.74 12.5234C16.8765 12.3834 16.9529 12.1955 16.9529 11.9999C16.9529 11.8044 16.8765 11.6165 16.74 11.4764L8.967 3.50094C8.90341 3.43563 8.82737 3.38371 8.74338 3.34827C8.6594 3.31282 8.56916 3.29456 8.478 3.29456C8.38684 3.29456 8.2966 3.31282 8.21261 3.34827C8.12863 3.38371 8.05259 3.43563 7.989 3.50094V3.49944Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                       <path d="M14.283 3.50094L6.51 11.4749C6.37348 11.615 6.29707 11.8029 6.29707 11.9984C6.29707 12.194 6.37348 12.3819 6.51 12.5219L14.283 20.4989C14.3466 20.5643 14.4226 20.6162 14.5066 20.6516C14.5906 20.6871 14.6808 20.7053 14.772 20.7053C14.8632 20.7053 14.9534 20.6871 15.0374 20.6516C15.1214 20.6162 15.1974 20.5643 15.261 20.4989C15.3918 20.365 15.4651 20.1852 15.4651 19.9979C15.4651 19.8107 15.3918 19.6309 15.261 19.4969L7.9515 11.9984L15.261 4.50144C15.3914 4.36756 15.4643 4.18807 15.4643 4.00119C15.4643 3.81431 15.3914 3.63482 15.261 3.50094C15.1974 3.43563 15.1214 3.38371 15.0374 3.34827C14.9534 3.31282 14.8632 3.29456 14.772 3.29456C14.6808 3.29456 14.5906 3.31282 14.5066 3.34827C14.4226 3.38371 14.3466 3.43563 14.283 3.50094V3.50094Z" fill="#716E7B" stroke="#716E7B"/>
                       </svg></span><span style="color:#716E7B">${node.data._directSubordinatesPaging} </span></div>`,
          "top": (d) => d ? `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M11.457 8.07005L3.49199 16.4296C3.35903 16.569 3.28485 16.7543 3.28485 16.9471C3.28485 17.1398 3.35903 17.3251 3.49199 17.4646L3.50099 17.4736C3.56545 17.5414 3.64304 17.5954 3.72904 17.6324C3.81504 17.6693 3.90765 17.6883 4.00124 17.6883C4.09483 17.6883 4.18745 17.6693 4.27344 17.6324C4.35944 17.5954 4.43703 17.5414 4.50149 17.4736L12.0015 9.60155L19.4985 17.4736C19.563 17.5414 19.6405 17.5954 19.7265 17.6324C19.8125 17.6693 19.9052 17.6883 19.9987 17.6883C20.0923 17.6883 20.1849 17.6693 20.2709 17.6324C20.3569 17.5954 20.4345 17.5414 20.499 17.4736L20.508 17.4646C20.641 17.3251 20.7151 17.1398 20.7151 16.9471C20.7151 16.7543 20.641 16.569 20.508 16.4296L12.543 8.07005C12.4729 7.99653 12.3887 7.93801 12.2954 7.89801C12.202 7.85802 12.1015 7.8374 12 7.8374C11.8984 7.8374 11.798 7.85802 11.7046 7.89801C11.6113 7.93801 11.527 7.99653 11.457 8.07005Z" fill="#716E7B" stroke="#716E7B"/>
                        </svg></span><span style="margin-left:1px;color:#716E7B">${node.data._directSubordinatesPaging} </span></div>
                        ` : `<div style="display:flex;"><span style="align-items:center;display:flex;"><svg width="8" height="8" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M19.497 7.98903L12 15.297L4.503 7.98903C4.36905 7.85819 4.18924 7.78495 4.002 7.78495C3.81476 7.78495 3.63495 7.85819 3.501 7.98903C3.43614 8.05257 3.38462 8.12842 3.34944 8.21213C3.31427 8.29584 3.29615 8.38573 3.29615 8.47653C3.29615 8.56733 3.31427 8.65721 3.34944 8.74092C3.38462 8.82463 3.43614 8.90048 3.501 8.96403L11.4765 16.74C11.6166 16.8765 11.8044 16.953 12 16.953C12.1956 16.953 12.3834 16.8765 12.5235 16.74L20.499 8.96553C20.5643 8.90193 20.6162 8.8259 20.6517 8.74191C20.6871 8.65792 20.7054 8.56769 20.7054 8.47653C20.7054 8.38537 20.6871 8.29513 20.6517 8.21114C20.6162 8.12715 20.5643 8.05112 20.499 7.98753C20.3651 7.85669 20.1852 7.78345 19.998 7.78345C19.8108 7.78345 19.6309 7.85669 19.497 7.98753V7.98903Z" fill="#716E7B" stroke="#716E7B"/>
                        </svg></span><span style="margin-left:1px;color:#716E7B">${node.data._directSubordinatesPaging} </span></div>
                    `
        };
        return `<div style="border:1px solid #E4E2E9;border-radius:3px;padding:3px;font-size:9px;margin:auto auto;background-color:white"> ${icons[state.layout](node.children)}  </div>`;
      },
      /* Node paging button content and styling. You can access same helper methods as above. */
      pagingButton: (d, i, arr, state) => {
        const step = state.pagingStep(d.parent);
        const currentIndex = d.parent.data._pagingStep;
        const diff = d.parent.data._directSubordinatesPaging - currentIndex;
        const min2 = Math.min(diff, step);
        return `
                   <div style="margin-top:90px;">
                      <div style="display:flex;width:170px;border-radius:20px;padding:5px 15px; padding-bottom:4px;;background-color:#E5E9F2">
                      <div><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                      <path d="M5.59 7.41L10.18 12L5.59 16.59L7 18L13 12L7 6L5.59 7.41ZM16 6H18V18H16V6Z" fill="#716E7B" stroke="#716E7B"/>
                      </svg>
                      </div><div style="line-height:2"> Show next ${min2}  nodes </div></div>
                   </div>
                `;
      },
      /* You can access and modify actual node DOM element in runtime using this method. */
      nodeUpdate: function(d, i, arr) {
        d3.select(this).select(".node-rect").attr("stroke", (d2) => d2.data._highlighted || d2.data._upToTheRootHighlighted ? "#E27396" : "none").attr("stroke-width", d.data._highlighted || d.data._upToTheRootHighlighted ? 10 : 1);
      },
      nodeEnter: (d) => d,
      // Custom handling of node update
      nodeExit: (d) => d,
      // Custom handling of exit node
      /* You can access and modify actual link DOM element in runtime using this method. */
      linkUpdate: function(d, i, arr) {
        d3.select(this).attr("stroke", (d2) => d2.data._upToTheRootHighlighted ? "#E27396" : "#E4E2E9").attr("stroke-width", (d2) => d2.data._upToTheRootHighlighted ? 5 : 1);
        if (d.data._upToTheRootHighlighted) {
          d3.select(this).raise();
        }
      },
      /* Horizontal diagonal generation algorithm - https://observablehq.com/@bumbeishvili/curved-edges-compact-horizontal */
      hdiagonal: function(s2, t2, m) {
        const x2 = s2.x;
        const y2 = s2.y;
        const ex = t2.x;
        const ey = t2.y;
        let mx = m && m.x != null ? m.x : x2;
        let my = m && m.y != null ? m.y : y2;
        let xrvs = ex - x2 < 0 ? -1 : 1;
        let yrvs = ey - y2 < 0 ? -1 : 1;
        let rdef = 35;
        let r = Math.abs(ex - x2) / 2 < rdef ? Math.abs(ex - x2) / 2 : rdef;
        r = Math.abs(ey - y2) / 2 < r ? Math.abs(ey - y2) / 2 : r;
        let w = Math.abs(ex - x2) / 2 - r;
        return `
                          M ${mx} ${my}
                          L ${mx} ${y2}
                          L ${x2} ${y2}
                          L ${x2 + w * xrvs} ${y2}
                          C ${x2 + w * xrvs + r * xrvs} ${y2} 
                            ${x2 + w * xrvs + r * xrvs} ${y2} 
                            ${x2 + w * xrvs + r * xrvs} ${y2 + r * yrvs}
                          L ${x2 + w * xrvs + r * xrvs} ${ey - r * yrvs} 
                          C ${x2 + w * xrvs + r * xrvs}  ${ey} 
                            ${x2 + w * xrvs + r * xrvs}  ${ey} 
                            ${ex - w * xrvs}  ${ey}
                          L ${ex} ${ey}
               `;
      },
      /* Vertical diagonal generation algorithm - https://observablehq.com/@bumbeishvili/curved-edges-compacty-vertical */
      diagonal: function(s2, t2, m, offsets = { sy: 0 }) {
        const x2 = s2.x;
        let y2 = s2.y;
        const ex = t2.x;
        const ey = t2.y;
        let mx = m && m.x != null ? m.x : x2;
        let my = m && m.y != null ? m.y : y2;
        let xrvs = ex - x2 < 0 ? -1 : 1;
        let yrvs = ey - y2 < 0 ? -1 : 1;
        y2 += offsets.sy;
        let rdef = 35;
        let r = Math.abs(ex - x2) / 2 < rdef ? Math.abs(ex - x2) / 2 : rdef;
        r = Math.abs(ey - y2) / 2 < r ? Math.abs(ey - y2) / 2 : r;
        let h = Math.abs(ey - y2) / 2 - r;
        let w = Math.abs(ex - x2) - r * 2;
        const path2 = `
                          M ${mx} ${my}
                          L ${x2} ${my}
                          L ${x2} ${y2}
                          L ${x2} ${y2 + h * yrvs}
                          C  ${x2} ${y2 + h * yrvs + r * yrvs} ${x2} ${y2 + h * yrvs + r * yrvs} ${x2 + r * xrvs} ${y2 + h * yrvs + r * yrvs}
                          L ${x2 + w * xrvs + r * xrvs} ${y2 + h * yrvs + r * yrvs}
                          C  ${ex}  ${y2 + h * yrvs + r * yrvs} ${ex}  ${y2 + h * yrvs + r * yrvs} ${ex} ${ey - h * yrvs}
                          L ${ex} ${ey}
               `;
        return path2;
      },
      // Defining arrows with markers for connections
      defs: function(state, visibleConnections) {
        return `<defs>
                    ${visibleConnections.map((conn) => {
          const labelWidth = this.getTextWidth(conn.label, { ctx: state.ctx, fontSize: 2, defaultFont: state.defaultFont });
          return `
                       <marker id="${conn.from + "_" + conn.to}" refX="${conn._source.x < conn._target.x ? -7 : 7}" refY="5" markerWidth="500"  markerHeight="500"  orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
                       <rect rx=0.5 width=${conn.label ? labelWidth + 3 : 0} height=3 y=1  fill="#E27396"></rect>
                       <text font-size="2px" x=1 fill="white" y=3>${conn.label || ""}</text>
                       </marker>

                       <marker id="arrow-${conn.from + "_" + conn.to}"  markerWidth="500"  markerHeight="500"  refY="2"  refX="1" orient="${conn._source.x < conn._target.x ? "auto" : "auto-start-reverse"}" >
                       <path transform="translate(0)" d='M0,0 V4 L2,2 Z' fill='#E27396' />
                       </marker>
                    `;
        }).join("")}
                    </defs>
                    `;
      },
      /* You can update connections with custom styling using this function */
      connectionsUpdate: function(d, i, arr) {
        d3.select(this).attr("stroke", (d2) => "#E27396").attr("stroke-linecap", "round").attr("stroke-width", (d2) => "5").attr("pointer-events", "none").attr("marker-start", (d2) => `url(#${d2.from + "_" + d2.to})`).attr("marker-end", (d2) => `url(#arrow-${d2.from + "_" + d2.to})`);
      },
      // Link generator for connections
      linkGroupArc: d3.linkHorizontal().x((d) => d.x).y((d) => d.y),
      /*
      *   You can customize/offset positions for each node and link by overriding these functions
      *   For example, suppose you want to move link y position 30 px bellow in top layout. You can do it like this:
      *   ```javascript
      *   const layout = chart.layoutBindings();
      *   layout.top.linkY = node => node.y + 30;
      *   chart.layoutBindings(layout);
      *   ```
      */
      layoutBindings: {
        "left": {
          "nodeLeftX": (node) => 0,
          "nodeRightX": (node) => node.width,
          "nodeTopY": (node) => -node.height / 2,
          "nodeBottomY": (node) => node.height / 2,
          "nodeJoinX": (node) => node.x + node.width,
          "nodeJoinY": (node) => node.y - node.height / 2,
          "linkJoinX": (node) => node.x + node.width,
          "linkJoinY": (node) => node.y,
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "linkCompactXStart": (node) => node.x + node.width / 2,
          //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
          "compactLinkMidX": (node, state) => node.firstCompactNode.x,
          // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "linkParentX": (node) => node.parent.x + node.parent.width,
          "linkParentY": (node) => node.parent.y,
          "buttonX": (node) => node.width,
          "buttonY": (node) => node.height / 2,
          "centerTransform": ({ root: root2, rootMargin, centerY, scale: scale2, centerX }) => `translate(${rootMargin},${centerY}) scale(${scale2})`,
          "compactDimension": {
            sizeColumn: (node) => node.height,
            sizeRow: (node) => node.width,
            reverse: (arr) => arr.slice().reverse()
          },
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            return [height + siblingsMargin, width + childrenMargin];
          },
          "zoomTransform": ({ centerY, scale: scale2 }) => `translate(${0},${centerY}) scale(${scale2})`,
          "diagonal": this.hdiagonal.bind(this),
          "swap": (d) => {
            const x2 = d.x;
            d.x = d.y;
            d.y = x2;
          },
          "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2},${y2 - height / 2})`
        },
        "top": {
          "nodeLeftX": (node) => -node.width / 2,
          "nodeRightX": (node) => node.width / 2,
          "nodeTopY": (node) => 0,
          "nodeBottomY": (node) => node.height,
          "nodeJoinX": (node) => node.x - node.width / 2,
          "nodeJoinY": (node) => node.y + node.height,
          "linkJoinX": (node) => node.x,
          "linkJoinY": (node) => node.y + node.height,
          "linkCompactXStart": (node) => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y + node.height / 2,
          "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node) => node.firstCompactNode.y,
          "compactDimension": {
            sizeColumn: (node) => node.width,
            sizeRow: (node) => node.height,
            reverse: (arr) => arr
          },
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "linkParentX": (node) => node.parent.x,
          "linkParentY": (node) => node.parent.y + node.parent.height,
          "buttonX": (node) => node.width / 2,
          "buttonY": (node) => node.height,
          "centerTransform": ({ root: root2, rootMargin, centerY, scale: scale2, centerX }) => `translate(${centerX},${rootMargin}) scale(${scale2})`,
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node, compactViewIndex }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            return [width + siblingsMargin, height + childrenMargin];
          },
          "zoomTransform": ({ centerX, scale: scale2 }) => `translate(${centerX},0}) scale(${scale2})`,
          "diagonal": this.diagonal.bind(this),
          "swap": (d) => {
          },
          "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2 - width / 2},${y2})`
        },
        "bottom": {
          "nodeLeftX": (node) => -node.width / 2,
          "nodeRightX": (node) => node.width / 2,
          "nodeTopY": (node) => -node.height,
          "nodeBottomY": (node) => 0,
          "nodeJoinX": (node) => node.x - node.width / 2,
          "nodeJoinY": (node) => node.y - node.height - node.height,
          "linkJoinX": (node) => node.x,
          "linkJoinY": (node) => node.y - node.height,
          "linkCompactXStart": (node) => node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y - node.height / 2,
          "compactLinkMidX": (node, state) => node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node) => node.firstCompactNode.y,
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "compactDimension": {
            sizeColumn: (node) => node.width,
            sizeRow: (node) => node.height,
            reverse: (arr) => arr
          },
          "linkParentX": (node) => node.parent.x,
          "linkParentY": (node) => node.parent.y - node.parent.height,
          "buttonX": (node) => node.width / 2,
          "buttonY": (node) => 0,
          "centerTransform": ({ root: root2, rootMargin, centerY, scale: scale2, centerX, chartHeight }) => `translate(${centerX},${chartHeight - rootMargin}) scale(${scale2})`,
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            return [width + siblingsMargin, height + childrenMargin];
          },
          "zoomTransform": ({ centerX, scale: scale2 }) => `translate(${centerX},0}) scale(${scale2})`,
          "diagonal": this.diagonal.bind(this),
          "swap": (d) => {
            d.y = -d.y;
          },
          "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2 - width / 2},${y2 - height})`
        },
        "right": {
          "nodeLeftX": (node) => -node.width,
          "nodeRightX": (node) => 0,
          "nodeTopY": (node) => -node.height / 2,
          "nodeBottomY": (node) => node.height / 2,
          "nodeJoinX": (node) => node.x - node.width - node.width,
          "nodeJoinY": (node) => node.y - node.height / 2,
          "linkJoinX": (node) => node.x - node.width,
          "linkJoinY": (node) => node.y,
          "linkX": (node) => node.x,
          "linkY": (node) => node.y,
          "linkParentX": (node) => node.parent.x - node.parent.width,
          "linkParentY": (node) => node.parent.y,
          "buttonX": (node) => 0,
          "buttonY": (node) => node.height / 2,
          "linkCompactXStart": (node) => node.x - node.width / 2,
          //node.x + (node.compactEven ? node.width / 2 : -node.width / 2),
          "linkCompactYStart": (node) => node.y + (node.compactEven ? node.height / 2 : -node.height / 2),
          "compactLinkMidX": (node, state) => node.firstCompactNode.x,
          // node.firstCompactNode.x + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "compactLinkMidY": (node, state) => node.firstCompactNode.y + node.firstCompactNode.flexCompactDim[0] / 4 + state.compactMarginPair(node) / 4,
          "centerTransform": ({ root: root2, rootMargin, centerY, scale: scale2, centerX, chartWidth }) => `translate(${chartWidth - rootMargin},${centerY}) scale(${scale2})`,
          "nodeFlexSize": ({ height, width, siblingsMargin, childrenMargin, state, node }) => {
            if (state.compact && node.flexCompactDim) {
              const result = [node.flexCompactDim[0], node.flexCompactDim[1]];
              return result;
            }
            return [height + siblingsMargin, width + childrenMargin];
          },
          "compactDimension": {
            sizeColumn: (node) => node.height,
            sizeRow: (node) => node.width,
            reverse: (arr) => arr.slice().reverse()
          },
          "zoomTransform": ({ centerY, scale: scale2 }) => `translate(${0},${centerY}) scale(${scale2})`,
          "diagonal": this.hdiagonal.bind(this),
          "swap": (d) => {
            const x2 = d.x;
            d.x = -d.y;
            d.y = x2;
          },
          "nodeUpdateTransform": ({ x: x2, y: y2, width, height }) => `translate(${x2 - width},${y2 - height / 2})`
        }
      }
    };
    this.getChartState = () => attrs;
    Object.keys(attrs).forEach((key) => {
      this[key] = function(_2) {
        if (!arguments.length) {
          return attrs[key];
        } else {
          attrs[key] = _2;
        }
        return this;
      };
    });
    this.initializeEnterExitUpdatePattern();
  }
  initializeEnterExitUpdatePattern() {
    d3.selection.prototype.patternify = function(params) {
      var container = this;
      var selector2 = params.selector;
      var elementTag = params.tag;
      var data = params.data || [selector2];
      var selection2 = container.selectAll("." + selector2).data(data, (d, i) => {
        if (typeof d === "object") {
          if (d.id) {
            return d.id;
          }
        }
        return i;
      });
      selection2.exit().remove();
      selection2 = selection2.enter().append(elementTag).merge(selection2);
      selection2.attr("class", selector2);
      return selection2;
    };
  }
  // This method retrieves passed node's children IDs (including node)
  getNodeChildren({ data, children: children2, _children }, nodeStore) {
    nodeStore.push(data);
    if (children2) {
      children2.forEach((d) => {
        this.getNodeChildren(d, nodeStore);
      });
    }
    if (_children) {
      _children.forEach((d) => {
        this.getNodeChildren(d, nodeStore);
      });
    }
    return nodeStore;
  }
  // This method can be invoked via chart.setZoomFactor API, it zooms to particulat scale
  initialZoom(zoomLevel) {
    const attrs = this.getChartState();
    attrs.lastTransform.k = zoomLevel;
    return this;
  }
  render() {
    const attrs = this.getChartState();
    if (!attrs.data || attrs.data.length == 0) {
      console.log("ORG CHART - Data is empty");
      if (attrs.container) {
        select(attrs.container).select(".nodes-wrapper").remove();
        select(attrs.container).select(".links-wrapper").remove();
        select(attrs.container).select(".connections-wrapper").remove();
      }
      return this;
    }
    const container = d3.select(attrs.container);
    const containerRect = container.node().getBoundingClientRect();
    if (containerRect.width > 0) attrs.svgWidth = containerRect.width;
    const calc = {
      id: `ID${Math.floor(Math.random() * 1e6)}`,
      // id for event handlings,
      chartWidth: attrs.svgWidth,
      chartHeight: attrs.svgHeight
    };
    attrs.calc = calc;
    calc.centerX = calc.chartWidth / 2;
    calc.centerY = calc.chartHeight / 2;
    if (attrs.firstDraw) {
      const behaviors = {
        zoom: null
      };
      behaviors.zoom = attrs.createZoom().clickDistance(10).on("start", (event, d) => attrs.onZoomStart(event)).on("end", (event, d) => attrs.onZoomEnd(event)).on("zoom", (event, d) => {
        attrs.onZoom(event);
        this.zoomed(event, d);
      }).scaleExtent(attrs.scaleExtent);
      attrs.zoomBehavior = behaviors.zoom;
    }
    attrs.flexTreeLayout = flextree({
      nodeSize: (node) => {
        const width = attrs.nodeWidth(node);
        const height = attrs.nodeHeight(node);
        const siblingsMargin = attrs.siblingsMargin(node);
        const childrenMargin = attrs.childrenMargin(node);
        return attrs.layoutBindings[attrs.layout].nodeFlexSize({
          state: attrs,
          node,
          width,
          height,
          siblingsMargin,
          childrenMargin
        });
      }
    }).spacing((nodeA, nodeB) => nodeA.parent == nodeB.parent ? 0 : attrs.neighbourMargin(nodeA, nodeB));
    this.setLayouts({ expandNodesFirst: false });
    const svg = container.patternify({
      tag: "svg",
      selector: "svg-chart-container"
    }).attr("width", attrs.svgWidth).attr("height", attrs.svgHeight).attr("font-family", attrs.defaultFont);
    if (attrs.firstDraw) {
      svg.call(attrs.zoomBehavior).on("dblclick.zoom", null).attr("cursor", "move");
    }
    attrs.svg = svg;
    const chart = svg.patternify({
      tag: "g",
      selector: "chart"
    });
    attrs.centerG = chart.patternify({
      tag: "g",
      selector: "center-group"
    });
    attrs.linksWrapper = attrs.centerG.patternify({
      tag: "g",
      selector: "links-wrapper"
    });
    attrs.nodesWrapper = attrs.centerG.patternify({
      tag: "g",
      selector: "nodes-wrapper"
    });
    attrs.connectionsWrapper = attrs.centerG.patternify({
      tag: "g",
      selector: "connections-wrapper"
    });
    attrs.defsWrapper = svg.patternify({
      tag: "g",
      selector: "defs-wrapper"
    });
    if (attrs.firstDraw) {
      attrs.centerG.attr("transform", () => {
        return attrs.layoutBindings[attrs.layout].centerTransform({
          centerX: calc.centerX,
          centerY: calc.centerY,
          scale: attrs.lastTransform.k,
          rootMargin: attrs.rootMargin,
          root: attrs.root,
          chartHeight: calc.chartHeight,
          chartWidth: calc.chartWidth
        });
      });
    }
    attrs.chart = chart;
    this.update(attrs.root);
    d3.select(window).on(`resize.${attrs.id}`, () => {
      const containerRect2 = d3.select(attrs.container).node().getBoundingClientRect();
      attrs.svg.attr("width", containerRect2.width);
    });
    if (attrs.firstDraw) {
      attrs.firstDraw = false;
    }
    return this;
  }
  // This function can be invoked via chart.addNode API, and it adds node in tree at runtime
  addNode(obj) {
    const attrs = this.getChartState();
    if (obj && (attrs.parentNodeId(obj) == null || attrs.parentNodeId(obj) == attrs.nodeId(obj)) && attrs.data.length == 0) {
      attrs.data.push(obj);
      this.render();
      return this;
    }
    const root2 = attrs.generateRoot(attrs.data);
    const descendants = root2.descendants();
    const nodeFound = descendants.filter(({ data }) => attrs.nodeId(data).toString() === attrs.nodeId(obj).toString())[0];
    descendants.filter(({ data }) => attrs.nodeId(data).toString() === attrs.parentNodeId(obj).toString())[0];
    if (nodeFound) {
      console.log(`ORG CHART - ADD - Node with id "${attrs.nodeId(obj)}" already exists in tree`);
      return this;
    }
    if (obj._centered && !obj._expanded) obj._expanded = true;
    attrs.data.push(obj);
    this.updateNodesState();
    return this;
  }
  // This function can be invoked via chart.removeNode API, and it removes node from tree at runtime
  removeNode(nodeId) {
    const attrs = this.getChartState();
    const root2 = attrs.generateRoot(attrs.data);
    const descendants = root2.descendants();
    const node = descendants.filter(({ data }) => attrs.nodeId(data) == nodeId)[0];
    if (!node) {
      console.log(`ORG CHART - REMOVE - Node with id "${nodeId}" not found in the tree`);
      return this;
    }
    const nodeDescendants = node.descendants();
    nodeDescendants.forEach((d) => d.data._filteredOut = true);
    attrs.data = attrs.data.filter((d) => !d._filteredOut);
    if (attrs.data.length == 0) {
      this.render();
    } else {
      const updateNodesState = this.updateNodesState.bind(this);
      updateNodesState();
    }
    return this;
  }
  groupBy(array2, accessor, aggegator) {
    const grouped = {};
    array2.forEach((item) => {
      const key = accessor(item);
      if (!grouped[key]) {
        grouped[key] = [];
      }
      grouped[key].push(item);
    });
    Object.keys(grouped).forEach((key) => {
      grouped[key] = aggegator(grouped[key]);
    });
    return Object.entries(grouped);
  }
  calculateCompactFlexDimensions(root2) {
    const attrs = this.getChartState();
    root2.eachBefore((node) => {
      node.firstCompact = null;
      node.compactEven = null;
      node.flexCompactDim = null;
      node.firstCompactNode = null;
    });
    root2.eachBefore((node) => {
      if (node.children && node.children.length > 1) {
        const compactChildren = node.children.filter((d) => !d.children);
        if (compactChildren.length < 2) return;
        compactChildren.forEach((child, i) => {
          if (!i) child.firstCompact = true;
          if (i % 2) child.compactEven = false;
          else child.compactEven = true;
          child.row = Math.floor(i / 2);
        });
        const evenMaxColumnDimension = d3.max(compactChildren.filter((d) => d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
        const oddMaxColumnDimension = d3.max(compactChildren.filter((d) => !d.compactEven), attrs.layoutBindings[attrs.layout].compactDimension.sizeColumn);
        const columnSize = Math.max(evenMaxColumnDimension, oddMaxColumnDimension) * 2;
        const rowsMapNew = this.groupBy(compactChildren, (d) => d.row, (reducedGroup) => d3.max(reducedGroup, (d) => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d) + attrs.compactMarginBetween(d)));
        const rowSize = d3.sum(rowsMapNew.map((v2) => v2[1]));
        compactChildren.forEach((node2) => {
          node2.firstCompactNode = compactChildren[0];
          if (node2.firstCompact) {
            node2.flexCompactDim = [
              columnSize + attrs.compactMarginPair(node2),
              rowSize - attrs.compactMarginBetween(node2)
            ];
          } else {
            node2.flexCompactDim = [0, 0];
          }
        });
        node.flexCompactDim = null;
      }
    });
  }
  calculateCompactFlexPositions(root2) {
    const attrs = this.getChartState();
    root2.eachBefore((node) => {
      if (node.children) {
        const compactChildren = node.children.filter((d) => d.flexCompactDim);
        const fch = compactChildren[0];
        if (!fch) return;
        compactChildren.forEach((child, i, arr) => {
          if (i == 0) fch.x -= fch.flexCompactDim[0] / 2;
          if (i & i % 2 - 1) child.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(child) / 4;
          else if (i) child.x = fch.x + fch.flexCompactDim[0] * 0.75 + attrs.compactMarginPair(child) / 4;
        });
        const centerX = fch.x + fch.flexCompactDim[0] * 0.5;
        fch.x = fch.x + fch.flexCompactDim[0] * 0.25 - attrs.compactMarginPair(fch) / 4;
        const offsetX = node.x - centerX;
        if (Math.abs(offsetX) < 10) {
          compactChildren.forEach((d) => d.x += offsetX);
        }
        const rowsMapNew = this.groupBy(compactChildren, (d) => d.row, (reducedGroup) => d3.max(reducedGroup, (d) => attrs.layoutBindings[attrs.layout].compactDimension.sizeRow(d)));
        const cumSum = d3.cumsum(rowsMapNew.map((d) => d[1] + attrs.compactMarginBetween(d)));
        compactChildren.forEach((node2, i) => {
          if (node2.row) {
            node2.y = fch.y + cumSum[node2.row - 1];
          } else {
            node2.y = fch.y;
          }
        });
      }
    });
  }
  // This function basically redraws visible graph, based on nodes state
  update({ x0, y0, x: x2 = 0, y: y2 = 0, width, height }) {
    const attrs = this.getChartState();
    attrs.calc;
    if (attrs.compact) {
      this.calculateCompactFlexDimensions(attrs.root);
    }
    const treeData = attrs.flexTreeLayout(attrs.root);
    if (attrs.compact) {
      this.calculateCompactFlexPositions(attrs.root);
    }
    const nodes = treeData.descendants();
    const links = treeData.descendants().slice(1);
    nodes.forEach(attrs.layoutBindings[attrs.layout].swap);
    const connections = attrs.connections;
    const allNodesMap = {};
    attrs.allNodes.forEach((d) => allNodesMap[attrs.nodeId(d.data)] = d);
    const visibleNodesMap = {};
    nodes.forEach((d) => visibleNodesMap[attrs.nodeId(d.data)] = d);
    connections.forEach((connection) => {
      const source = allNodesMap[connection.from];
      const target = allNodesMap[connection.to];
      connection._source = source;
      connection._target = target;
    });
    const visibleConnections = connections.filter((d) => visibleNodesMap[d.from] && visibleNodesMap[d.to]);
    const defsString = attrs.defs.bind(this)(attrs, visibleConnections);
    const existingString = attrs.defsWrapper.html();
    if (defsString !== existingString) {
      attrs.defsWrapper.html(defsString);
    }
    const linkSelection = attrs.linksWrapper.selectAll("path.link").data(links, (d) => attrs.nodeId(d.data));
    const linkEnter = linkSelection.enter().insert("path", "g").attr("class", "link").attr("d", (d) => {
      const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
      const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
      const o2 = { x: xo, y: yo };
      return attrs.layoutBindings[attrs.layout].diagonal(o2, o2, o2);
    });
    const linkUpdate = linkEnter.merge(linkSelection);
    linkUpdate.attr("fill", "none");
    if (this.isEdge()) {
      linkUpdate.style("display", (d) => {
        const display = d.data._pagingButton ? "none" : "auto";
        return display;
      });
    } else {
      linkUpdate.attr("display", (d) => {
        const display = d.data._pagingButton ? "none" : "auto";
        return display;
      });
    }
    linkUpdate.each(attrs.linkUpdate);
    linkUpdate.transition().duration(attrs.duration).attr("d", (d) => {
      const n2 = attrs.compact && d.flexCompactDim ? {
        x: attrs.layoutBindings[attrs.layout].compactLinkMidX(d, attrs),
        y: attrs.layoutBindings[attrs.layout].compactLinkMidY(d, attrs)
      } : {
        x: attrs.layoutBindings[attrs.layout].linkX(d),
        y: attrs.layoutBindings[attrs.layout].linkY(d)
      };
      const p = {
        x: attrs.layoutBindings[attrs.layout].linkParentX(d),
        y: attrs.layoutBindings[attrs.layout].linkParentY(d)
      };
      const m = attrs.compact && d.flexCompactDim ? {
        x: attrs.layoutBindings[attrs.layout].linkCompactXStart(d),
        y: attrs.layoutBindings[attrs.layout].linkCompactYStart(d)
      } : n2;
      return attrs.layoutBindings[attrs.layout].diagonal(n2, p, m, { sy: attrs.linkYOffset });
    });
    linkSelection.exit().transition().duration(attrs.duration).attr("d", (d) => {
      const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x2, y: y2, width, height });
      const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x2, y: y2, width, height });
      const o2 = { x: xo, y: yo };
      return attrs.layoutBindings[attrs.layout].diagonal(o2, o2, null, { sy: attrs.linkYOffset });
    }).remove();
    const connectionsSel = attrs.connectionsWrapper.selectAll("path.connection").data(visibleConnections);
    const connEnter = connectionsSel.enter().insert("path", "g").attr("class", "connection").attr("d", (d) => {
      const xo = attrs.layoutBindings[attrs.layout].linkJoinX({ x: x0, y: y0, width, height });
      const yo = attrs.layoutBindings[attrs.layout].linkJoinY({ x: x0, y: y0, width, height });
      const o2 = { x: xo, y: yo };
      return attrs.layoutBindings[attrs.layout].diagonal(o2, o2, null, { sy: attrs.linkYOffset });
    });
    const connUpdate = connEnter.merge(connectionsSel);
    connUpdate.attr("fill", "none");
    connUpdate.transition().duration(attrs.duration).attr("d", (d) => {
      const xs = attrs.layoutBindings[attrs.layout].linkX({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
      const ys = attrs.layoutBindings[attrs.layout].linkY({ x: d._source.x, y: d._source.y, width: d._source.width, height: d._source.height });
      const xt = attrs.layoutBindings[attrs.layout].linkJoinX({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
      const yt = attrs.layoutBindings[attrs.layout].linkJoinY({ x: d._target.x, y: d._target.y, width: d._target.width, height: d._target.height });
      return attrs.linkGroupArc({ source: { x: xs, y: ys }, target: { x: xt, y: yt } });
    });
    connUpdate.each(attrs.connectionsUpdate);
    connectionsSel.exit().transition().duration(attrs.duration).attr("opacity", 0).remove();
    const nodesSelection = attrs.nodesWrapper.selectAll("g.node").data(nodes, ({ data }) => attrs.nodeId(data));
    const nodeEnter = nodesSelection.enter().append("g").attr("class", "node").attr("transform", (d) => {
      if (d == attrs.root) return `translate(${x0},${y0})`;
      const xj = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x0, y: y0, width, height });
      const yj = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x0, y: y0, width, height });
      return `translate(${xj},${yj})`;
    }).attr("cursor", "pointer").on("click.node", (event, node) => {
      const { data } = node;
      if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
        return;
      }
      if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
        this.loadPagingNodes(node);
        return;
      }
      if (!data._pagingButton) {
        attrs.onNodeClick(node);
        return;
      }
      console.log("event fired, no handlers");
    }).on("keydown.node", (event, node) => {
      if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
        if ([...event.srcElement.classList].includes("node-button-foreign-object")) {
          return;
        }
        if ([...event.srcElement.classList].includes("paging-button-wrapper")) {
          this.loadPagingNodes(node);
          return;
        }
        if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
          this.onButtonClick(event, node);
        }
      }
    });
    nodeEnter.each(attrs.nodeEnter);
    nodeEnter.patternify({
      tag: "rect",
      selector: "node-rect",
      data: (d) => [d]
    });
    const nodeUpdate = nodeEnter.merge(nodesSelection).style("font", "12px sans-serif");
    const fo = nodeUpdate.patternify({
      tag: "foreignObject",
      selector: "node-foreign-object",
      data: (d) => [d]
    }).style("overflow", "visible");
    fo.patternify({
      tag: "xhtml:div",
      selector: "node-foreign-object-div",
      data: (d) => [d]
    });
    this.restyleForeignObjectElements();
    const nodeButtonGroups = nodeEnter.patternify({
      tag: "g",
      selector: "node-button-g",
      data: (d) => [d]
    }).on("click", (event, d) => this.onButtonClick(event, d)).on("keydown", (event, d) => {
      if (event.key === "Enter" || event.key === " " || event.key === "Spacebar") {
        this.onButtonClick(event, d);
      }
    });
    nodeButtonGroups.patternify({
      tag: "rect",
      selector: "node-button-rect",
      data: (d) => [d]
    }).attr("opacity", 0).attr("pointer-events", "all").attr("width", (d) => attrs.nodeButtonWidth(d)).attr("height", (d) => attrs.nodeButtonHeight(d)).attr("x", (d) => attrs.nodeButtonX(d)).attr("y", (d) => attrs.nodeButtonY(d));
    nodeButtonGroups.patternify({
      tag: "foreignObject",
      selector: "node-button-foreign-object",
      data: (d) => [d]
    }).attr("width", (d) => attrs.nodeButtonWidth(d)).attr("height", (d) => attrs.nodeButtonHeight(d)).attr("x", (d) => attrs.nodeButtonX(d)).attr("y", (d) => attrs.nodeButtonY(d)).style("overflow", "visible").patternify({
      tag: "xhtml:div",
      selector: "node-button-div",
      data: (d) => [d]
    }).style("pointer-events", "none").style("display", "flex").style("width", "100%").style("height", "100%");
    nodeUpdate.transition().attr("opacity", 0).duration(attrs.duration).attr("transform", ({ x: x3, y: y3, width: width2, height: height2 }) => {
      return attrs.layoutBindings[attrs.layout].nodeUpdateTransform({ x: x3, y: y3, width: width2, height: height2 });
    }).attr("opacity", 1);
    nodeUpdate.select(".node-rect").attr("width", ({ width: width2 }) => width2).attr("height", ({ height: height2 }) => height2).attr("x", ({ width: width2 }) => 0).attr("y", ({ height: height2 }) => 0).attr("cursor", "pointer").attr("rx", 3).attr("fill", attrs.nodeDefaultBackground);
    nodeUpdate.select(".node-button-g").attr("transform", ({ data, width: width2, height: height2 }) => {
      const x3 = attrs.layoutBindings[attrs.layout].buttonX({ width: width2, height: height2 });
      const y3 = attrs.layoutBindings[attrs.layout].buttonY({ width: width2, height: height2 });
      return `translate(${x3},${y3})`;
    }).attr("display", ({ data }) => {
      return data._directSubordinates > 0 ? null : "none";
    }).attr("opacity", ({ data, children: children2, _children }) => {
      if (data._pagingButton) {
        return 0;
      }
      if (children2 || _children) {
        return 1;
      }
      return 0;
    });
    nodeUpdate.select(".node-button-foreign-object .node-button-div").html((node) => {
      return attrs.buttonContent({ node, state: attrs });
    });
    nodeUpdate.select(".node-button-text").attr("text-anchor", "middle").attr("alignment-baseline", "middle").attr("font-size", ({ children: children2 }) => {
      if (children2) return 40;
      return 26;
    }).text(({ children: children2 }) => {
      if (children2) return "-";
      return "+";
    }).attr("y", this.isEdge() ? 10 : 0);
    nodeUpdate.each(attrs.nodeUpdate);
    const nodeExitTransition = nodesSelection.exit();
    nodeExitTransition.each(attrs.nodeExit);
    const maxDepthNode = nodeExitTransition.data().reduce((a, b) => a.depth < b.depth ? a : b, { depth: Infinity });
    nodeExitTransition.attr("opacity", 1).transition().duration(attrs.duration).attr("transform", (d) => {
      let { x: x3, y: y3, width: width2, height: height2 } = maxDepthNode.parent || {};
      const ex = attrs.layoutBindings[attrs.layout].nodeJoinX({ x: x3, y: y3, width: width2, height: height2 });
      const ey = attrs.layoutBindings[attrs.layout].nodeJoinY({ x: x3, y: y3, width: width2, height: height2 });
      return `translate(${ex},${ey})`;
    }).on("end", function() {
      d3.select(this).remove();
    }).attr("opacity", 0);
    nodes.forEach((d) => {
      d.x0 = d.x;
      d.y0 = d.y;
    });
    const centeredNode = attrs.allNodes.filter((d) => d.data._centered)[0];
    if (centeredNode) {
      let centeredNodes = [centeredNode];
      if (centeredNode.data._centeredWithDescendants) {
        if (attrs.compact) {
          centeredNodes = centeredNode.descendants().filter((d, i) => i < 7);
        } else {
          centeredNodes = centeredNode.descendants().filter((d, i, arr) => {
            const h = Math.round(arr.length / 2);
            const spread = 2;
            if (arr.length % 2) {
              return i > h - spread && i < h + spread - 1;
            }
            return i > h - spread && i < h + spread;
          });
        }
      }
      centeredNode.data._centeredWithDescendants = null;
      centeredNode.data._centered = null;
      this.fit({
        animate: true,
        scale: false,
        nodes: centeredNodes
      });
    }
  }
  // This function detects whether current browser is edge
  isEdge() {
    return window.navigator.userAgent.includes("Edge");
  }
  // Generate horizontal diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges-horizontal-d3-v3-v4-v5-v6
  hdiagonal(s2, t2, m, offsets) {
    const state = this.getChartState();
    return state.hdiagonal(s2, t2, m, offsets);
  }
  // Generate custom diagonal - play with it here - https://observablehq.com/@bumbeishvili/curved-edges
  diagonal(s2, t2, m, offsets) {
    const state = this.getChartState();
    return state.diagonal(s2, t2, m, offsets);
  }
  restyleForeignObjectElements() {
    const attrs = this.getChartState();
    attrs.svg.selectAll(".node-foreign-object").attr("width", ({ width }) => width).attr("height", ({ height }) => height).attr("x", ({ width }) => 0).attr("y", ({ height }) => 0);
    attrs.svg.selectAll(".node-foreign-object-div").style("width", ({ width }) => `${width}px`).style("height", ({ height }) => `${height}px`).html(function(d, i, arr) {
      if (d.data._pagingButton) {
        return `<div class="paging-button-wrapper"><div style="pointer-events:none">${attrs.pagingButton(d, i, arr, attrs)}</div></div>`;
      }
      return attrs.nodeContent.bind(this)(d, i, arr, attrs);
    });
  }
  // Toggle children on click.
  onButtonClick(event, d) {
    const attrs = this.getChartState();
    if (d.data._pagingButton) {
      return;
    }
    if (attrs.setActiveNodeCentered) {
      d.data._centered = true;
      d.data._centeredWithDescendants = true;
    }
    if (d.children) {
      d._children = d.children;
      d.children = null;
      this.setExpansionFlagToChildren(d, false);
    } else {
      d.children = d._children;
      d._children = null;
      if (d.children) {
        d.children.forEach(({ data }) => data._expanded = true);
      }
    }
    this.update(d);
    event.stopPropagation();
    attrs.onExpandOrCollapse(d);
  }
  // This function changes `expanded` property to descendants
  setExpansionFlagToChildren({ data, children: children2, _children }, flag) {
    data._expanded = flag;
    if (children2) {
      children2.forEach((d) => {
        this.setExpansionFlagToChildren(d, flag);
      });
    }
    if (_children) {
      _children.forEach((d) => {
        this.setExpansionFlagToChildren(d, flag);
      });
    }
  }
  // Method which only expands nodes, which have property set "expanded=true"
  expandSomeNodes(d) {
    if (d.data._expanded) {
      let parent = d.parent;
      while (parent && parent._children) {
        parent.children = parent._children;
        parent._children = null;
        parent = parent.parent;
      }
    }
    if (d._children) {
      d._children.forEach((ch) => this.expandSomeNodes(ch));
    }
    if (d.children) {
      d.children.forEach((ch) => this.expandSomeNodes(ch));
    }
  }
  // This function updates nodes state and redraws graph, usually after data change
  updateNodesState() {
    const attrs = this.getChartState();
    this.setLayouts({ expandNodesFirst: true });
    this.update(attrs.root);
  }
  setLayouts({ expandNodesFirst = true }) {
    const attrs = this.getChartState();
    attrs.generateRoot = d3.stratify().id((d) => attrs.nodeId(d)).parentId((d) => attrs.parentNodeId(d));
    attrs.root = attrs.generateRoot(attrs.data);
    const descendantsBefore = attrs.root.descendants();
    if (attrs.initialExpandLevel > 1 && descendantsBefore.length > 0) {
      descendantsBefore.forEach((d) => {
        if (d.depth <= attrs.initialExpandLevel) {
          d.data._expanded = true;
        }
      });
      attrs.initialExpandLevel = 1;
    }
    const hiddenNodesMap = {};
    attrs.root.descendants().filter((node) => node.children).filter((node) => !node.data._pagingStep).forEach((node) => {
      node.data._pagingStep = attrs.minPagingVisibleNodes(node);
    });
    attrs.root.eachBefore((node, i) => {
      node.data._directSubordinatesPaging = node.children ? node.children.length : 0;
      if (node.children) {
        node.children.forEach((child, j) => {
          child.data._pagingButton = false;
          if (j > node.data._pagingStep) {
            hiddenNodesMap[child.id] = true;
          }
          if (j === node.data._pagingStep && node.children.length - 1 > node.data._pagingStep) {
            child.data._pagingButton = true;
          }
          if (hiddenNodesMap[child.parent.id]) {
            hiddenNodesMap[child.id] = true;
          }
          if (child.data._expanded || child.data._centered || child.data._highlighted || child.data._upToTheRootHighlighted) {
            let localNode = child;
            while (localNode && (hiddenNodesMap[localNode.id] || localNode.data._pagingButton)) {
              hiddenNodesMap[localNode.id] = false;
              if (localNode.data._pagingButton) {
                localNode.data._pagingButton = false;
                localNode.parent.children.forEach((ch) => {
                  ch.data._expanded = true;
                  hiddenNodesMap[ch.id] = false;
                });
              }
              localNode = localNode.parent;
            }
          }
        });
      }
    });
    attrs.root = d3.stratify().id((d) => attrs.nodeId(d)).parentId((d) => attrs.parentNodeId(d))(attrs.data.filter((d) => hiddenNodesMap[d.id] !== true));
    attrs.root.each((node, i, arr) => {
      let _hierarchyHeight = node._hierarchyHeight || node.height;
      let width = attrs.nodeWidth(node);
      let height = attrs.nodeHeight(node);
      Object.assign(node, { width, height, _hierarchyHeight });
    });
    attrs.root.x0 = 0;
    attrs.root.y0 = 0;
    attrs.allNodes = attrs.root.descendants();
    attrs.allNodes.forEach((d) => {
      Object.assign(d.data, {
        _directSubordinates: d.children ? d.children.length : 0,
        _totalSubordinates: d.descendants().length - 1
      });
    });
    if (attrs.root.children) {
      if (expandNodesFirst) {
        attrs.root.children.forEach(this.expand);
      }
      attrs.root.children.forEach((d) => this.collapse(d));
      if (attrs.initialExpandLevel == 0) {
        attrs.root._children = attrs.root.children;
        attrs.root.children = null;
      }
      [attrs.root].forEach((ch) => this.expandSomeNodes(ch));
    }
  }
  // Function which collapses passed node and it's descendants
  collapse(d) {
    if (d.children) {
      d._children = d.children;
      d._children.forEach((ch) => this.collapse(ch));
      d.children = null;
    }
  }
  // Function which expands passed node and it's descendants
  expand(d) {
    if (d._children) {
      d.children = d._children;
      d.children.forEach((ch) => this.expand(ch));
      d._children = null;
    }
  }
  // Zoom handler function
  zoomed(event, d) {
    const attrs = this.getChartState();
    const chart = attrs.chart;
    const transform = event.transform;
    attrs.lastTransform = transform;
    chart.attr("transform", transform);
    if (this.isEdge()) {
      this.restyleForeignObjectElements();
    }
  }
  zoomTreeBounds({ x0, x1, y0, y1, params = { animate: true, scale: true, onCompleted: () => {
  } } }) {
    const { centerG, svgWidth: w, svgHeight: h, svg, zoomBehavior, duration, lastTransform } = this.getChartState();
    let scaleVal = Math.min(8, 0.9 / Math.max((x1 - x0) / w, (y1 - y0) / h));
    let identity2 = d3.zoomIdentity.translate(w / 2, h / 2);
    identity2 = identity2.scale(params.scale ? scaleVal : lastTransform.k);
    identity2 = identity2.translate(-(x0 + x1) / 2, -(y0 + y1) / 2);
    svg.transition().duration(params.animate ? duration : 0).call(zoomBehavior.transform, identity2);
    centerG.transition().duration(params.animate ? duration : 0).attr("transform", "translate(0,0)").on("end", function() {
      if (params.onCompleted) {
        params.onCompleted();
      }
    });
  }
  fit({ animate = true, nodes, scale: scale2 = true, onCompleted = () => {
  } } = {}) {
    const attrs = this.getChartState();
    const { root: root2 } = attrs;
    let descendants = nodes ? nodes : root2.descendants();
    const minX = d3.min(descendants, (d) => d.x + attrs.layoutBindings[attrs.layout].nodeLeftX(d));
    const maxX = d3.max(descendants, (d) => d.x + attrs.layoutBindings[attrs.layout].nodeRightX(d));
    const minY = d3.min(descendants, (d) => d.y + attrs.layoutBindings[attrs.layout].nodeTopY(d));
    const maxY = d3.max(descendants, (d) => d.y + attrs.layoutBindings[attrs.layout].nodeBottomY(d));
    this.zoomTreeBounds({
      params: { animate, scale: scale2, onCompleted },
      x0: minX - 50,
      x1: maxX + 50,
      y0: minY - 50,
      y1: maxY + 50
    });
    return this;
  }
  // Load Paging Nodes
  loadPagingNodes(node) {
    const attrs = this.getChartState();
    node.data._pagingButton = false;
    const current = node.parent.data._pagingStep;
    const step = attrs.pagingStep(node.parent);
    const newPagingIndex = current + step;
    node.parent.data._pagingStep = newPagingIndex;
    this.updateNodesState();
  }
  // This function can be invoked via chart.setExpanded API, it expands or collapses particular node
  setExpanded(id2, expandedFlag = true) {
    const attrs = this.getChartState();
    const node = attrs.allNodes.filter(({ data }) => attrs.nodeId(data) == id2)[0];
    if (!node) {
      console.log(`ORG CHART - ${expandedFlag ? "EXPAND" : "COLLAPSE"} - Node with id (${id2})  not found in the tree`);
      return this;
    }
    node.data._expanded = expandedFlag;
    if (expandedFlag == false) {
      const parent = node.parent || { descendants: () => [] };
      const descendants = parent.descendants().filter((d) => d != parent);
      descendants.forEach((d) => d.data._expanded = false);
    }
    return this;
  }
  setCentered(nodeId) {
    const attrs = this.getChartState();
    const root2 = attrs.generateRoot(attrs.data);
    const descendants = root2.descendants();
    const node = descendants.filter(({ data }) => attrs.nodeId(data).toString() == nodeId.toString())[0];
    if (!node) {
      console.log(`ORG CHART - CENTER - Node with id (${nodeId}) not found in the tree`);
      return this;
    }
    const ancestors = node.ancestors();
    ancestors.forEach((d) => d.data._expanded = true);
    node.data._centered = true;
    node.data._expanded = true;
    return this;
  }
  setHighlighted(nodeId) {
    const attrs = this.getChartState();
    const root2 = attrs.generateRoot(attrs.data);
    const descendants = root2.descendants();
    const node = descendants.filter((d) => attrs.nodeId(d.data).toString() === nodeId.toString())[0];
    if (!node) {
      console.log(`ORG CHART - HIGHLIGHT - Node with id (${nodeId})  not found in the tree`);
      return this;
    }
    const ancestors = node.ancestors();
    ancestors.forEach((d) => d.data._expanded = true);
    node.data._highlighted = true;
    node.data._expanded = true;
    node.data._centered = true;
    return this;
  }
  setUpToTheRootHighlighted(nodeId) {
    const attrs = this.getChartState();
    const root2 = attrs.generateRoot(attrs.data);
    const descendants = root2.descendants();
    const node = descendants.filter((d) => attrs.nodeId(d.data).toString() === nodeId.toString())[0];
    if (!node) {
      console.log(`ORG CHART - HIGHLIGHTROOT - Node with id (${nodeId}) not found in the tree`);
      return this;
    }
    const ancestors = node.ancestors();
    ancestors.forEach((d) => d.data._expanded = true);
    node.data._upToTheRootHighlighted = true;
    node.data._expanded = true;
    node.ancestors().forEach((d) => d.data._upToTheRootHighlighted = true);
    return this;
  }
  clearHighlighting() {
    const attrs = this.getChartState();
    attrs.allNodes.forEach((d) => {
      d.data._highlighted = false;
      d.data._upToTheRootHighlighted = false;
    });
    this.update(attrs.root);
    return this;
  }
  // It can take selector which would go fullscreen
  fullscreen(elem) {
    const attrs = this.getChartState();
    const el = d3.select(elem || attrs.container).node();
    d3.select(document).on("fullscreenchange." + attrs.id, function(d) {
      const fsElement = document.fullscreenElement || document.mozFullscreenElement || document.webkitFullscreenElement;
      if (fsElement == el) {
        setTimeout((d2) => {
          attrs.svg.attr("height", window.innerHeight - 40);
        }, 500);
      } else {
        attrs.svg.attr("height", attrs.svgHeight);
      }
    });
    if (el.requestFullscreen) {
      el.requestFullscreen();
    } else if (el.mozRequestFullScreen) {
      el.mozRequestFullScreen();
    } else if (el.webkitRequestFullscreen) {
      el.webkitRequestFullscreen();
    } else if (el.msRequestFullscreen) {
      el.msRequestFullscreen();
    }
  }
  // Zoom in exposed method
  zoomIn() {
    const { svg, zoomBehavior } = this.getChartState();
    svg.transition().call(zoomBehavior.scaleBy, 1.3);
  }
  // Zoom out exposed method
  zoomOut() {
    const { svg, zoomBehavior } = this.getChartState();
    svg.transition().call(zoomBehavior.scaleBy, 0.78);
  }
  toDataURL(url, callback) {
    var xhr = new XMLHttpRequest();
    xhr.onload = function() {
      var reader = new FileReader();
      reader.onloadend = function() {
        callback(reader.result);
      };
      reader.readAsDataURL(xhr.response);
    };
    xhr.open("GET", url);
    xhr.responseType = "blob";
    xhr.send();
  }
  exportImg({ full = false, scale: scale2 = 3, onLoad = (d) => d, save = true, backgroundColor = "#FAFAFA" } = {}) {
    const that = this;
    const attrs = this.getChartState();
    const { svg: svgImg, root: root2 } = attrs;
    let count2 = 0;
    const selection2 = svgImg.selectAll("img");
    let total = selection2.size();
    const exportImage = () => {
      JSON.parse(JSON.stringify(that.lastTransform()));
      const duration = that.duration();
      if (full) {
        that.fit();
      }
      const { svg } = that.getChartState();
      setTimeout((d) => {
        that.downloadImage({
          node: svg.node(),
          scale: scale2,
          isSvg: false,
          backgroundColor,
          onAlreadySerialized: (d2) => {
            that.update(root2);
          },
          imageName: attrs.imageName,
          onLoad,
          save
        });
      }, full ? duration + 10 : 0);
    };
    if (total > 0) {
      selection2.each(function() {
        that.toDataURL(this.src, (dataUrl) => {
          this.src = dataUrl;
          if (++count2 == total) {
            exportImage();
          }
        });
      });
    } else {
      exportImage();
    }
  }
  exportSvg() {
    const { svg, imageName } = this.getChartState();
    this.downloadImage({ imageName, node: svg.node(), scale: 3, isSvg: true });
    return this;
  }
  expandAll() {
    const { allNodes, root: root2, data } = this.getChartState();
    data.forEach((d) => d._expanded = true);
    this.render();
    return this;
  }
  collapseAll() {
    const { allNodes, root: root2 } = this.getChartState();
    allNodes.forEach((d) => d.data._expanded = false);
    this.initialExpandLevel(0);
    this.render();
    return this;
  }
  downloadImage({ node, scale: scale2 = 2, imageName = "graph", isSvg = false, save = true, backgroundColor = "#FAFAFA", onAlreadySerialized = (d) => {
  }, onLoad = (d) => {
  } }) {
    const svgNode2 = node;
    function saveAs(uri, filename) {
      var link2 = document.createElement("a");
      if (typeof link2.download === "string") {
        document.body.appendChild(link2);
        link2.download = filename;
        link2.href = uri;
        link2.click();
        document.body.removeChild(link2);
      } else {
        location.replace(uri);
      }
    }
    function serializeString(svg) {
      const xmlns = "http://www.w3.org/2000/xmlns/";
      const xlinkns = "http://www.w3.org/1999/xlink";
      const svgns = "http://www.w3.org/2000/svg";
      svg = svg.cloneNode(true);
      const fragment = window.location.href + "#";
      const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT, null, false);
      while (walker.nextNode()) {
        for (const attr of walker.currentNode.attributes) {
          if (attr.value.includes(fragment)) {
            attr.value = attr.value.replace(fragment, "#");
          }
        }
      }
      svg.setAttributeNS(xmlns, "xmlns", svgns);
      svg.setAttributeNS(xmlns, "xmlns:xlink", xlinkns);
      const serializer = new XMLSerializer();
      const string = serializer.serializeToString(svg);
      return string;
    }
    if (isSvg) {
      let source = serializeString(svgNode2);
      source = '<?xml version="1.0" standalone="no"?>\r\n' + source;
      var url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
      saveAs(url, imageName + ".svg");
      onAlreadySerialized();
      return;
    }
    const quality = scale2;
    const image = document.createElement("img");
    image.onload = function() {
      const canvas = document.createElement("canvas");
      const rect = svgNode2.getBoundingClientRect();
      canvas.width = rect.width * quality;
      canvas.height = rect.height * quality;
      const context = canvas.getContext("2d");
      context.fillStyle = backgroundColor;
      context.fillRect(0, 0, rect.width * quality, rect.height * quality);
      context.drawImage(image, 0, 0, rect.width * quality, rect.height * quality);
      let dt = canvas.toDataURL("image/png");
      if (onLoad) {
        onLoad(dt);
      }
      if (save) {
        saveAs(dt, imageName + ".png");
      }
    };
    var url = "data:image/svg+xml; charset=utf8, " + encodeURIComponent(serializeString(svgNode2));
    onAlreadySerialized();
    image.src = url;
  }
  // Calculate what size text will take
  getTextWidth(text, {
    fontSize = 14,
    fontWeight = 400,
    defaultFont = "Helvetice",
    ctx
  } = {}) {
    ctx.font = `${fontWeight || ""} ${fontSize}px ${defaultFont} `;
    const measurement = ctx.measureText(text);
    return measurement.width;
  }
  // Clear after moving off from the page
  clear() {
    const attrs = this.getChartState();
    d3.select(window).on(`resize.${attrs.id}`, null);
    attrs.svg && attrs.svg.selectAll("*").remove();
  }
};
const _sfc_main$K = {
  name: "OrgChart",
  components: {
    NcSelect
  },
  props: {
    data: {
      type: Array,
      default: () => []
    }
  },
  data() {
    return {
      chartReference: null,
      chart: 0
    };
  },
  computed: {
    charts() {
      return this.data.map((nodes, index2) => {
        const head = nodes.find((node) => node.parentNodeId === null);
        return {
          id: index2,
          label: head.org ? `${head.org} (${head.fullName})` : head.fullName
        };
      }).sort((a, b) => {
        return a.label.localeCompare(
          b.label,
          getLocale$1().replace("_", "-"),
          { sensitivity: "base" }
        );
      });
    },
    placeholder() {
      return t("contacts", "Select chart ");
    }
  },
  watch: {
    data() {
      if (this.data[this.chart]?.length) {
        this.renderChart(this.data[this.chart]);
      }
    }
  },
  mounted() {
    if (this.data[this.chart]?.length) {
      this.renderChart(this.data[this.chart]);
    }
  },
  methods: {
    chartChanged(inputProps) {
      this.renderChart(this.data[inputProps.id]);
    },
    goToContact(key) {
      this.$router.push({
        name: "contact",
        params: {
          selectedGroup: this.$route.params.selectedChart,
          selectedContact: key
        }
      });
    },
    renderChart(data) {
      const that = this;
      if (!this.chartReference) {
        this.chartReference = new OrgChart$1();
      }
      this.chartReference.container(this.$refs.svgElementContainer).data(data).nodeWidth(() => 250).initialZoom(1).nodeHeight(() => 200).childrenMargin(() => 70).compactMarginBetween(() => 15).compactMarginPair(() => 80).nodeContent(() => {
        return "";
      }).nodeUpdate(function(d) {
        const containerHTMLElement = this.querySelector(".node-foreign-object-div");
        if (containerHTMLElement) {
          if (d.data.rendered) {
            containerHTMLElement.appendChild(d.data.rendered);
          } else {
            const ComponentClass = Vue.extend(ChartTemplate);
            const instance = new ComponentClass({
              propsData: {
                data: d.data,
                onAvatarClick: (uid) => that.goToContact(uid)
              },
              router
            }).$mount();
            d.data.rendered = instance.$el;
            containerHTMLElement.appendChild(instance.$el);
          }
        }
        select(this).select(".inner-box").attr("class", (dRect) => dRect.data._highlighted || dRect.data._upToTheRootHighlighted ? "inner-box inner-box-highlight" : "inner-box");
      }).linkUpdate(function(d) {
        select(this).attr("stroke", () => "var(--color-primary-element)").attr(
          "stroke-width",
          (dRect) => dRect.data._upToTheRootHighlighted ? 2 : 1
        );
        if (d.data._upToTheRootHighlighted) {
          select(this).raise();
        }
      }).onNodeClick((d) => {
        if (!this.chartReference.data().filter((item) => item.nodeId === d)[0]._upToTheRootHighlighted) {
          this.chartReference.clearHighlighting();
          this.chartReference.setUpToTheRootHighlighted(d).render();
        } else {
          this.chartReference.clearHighlighting();
        }
      }).render();
    }
  }
};
var _sfc_render$K = function render34() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "org-chart" }, [_vm.data.length > 1 ? _c("div", { staticClass: "org-chart__menu" }, [_c("h3", [_vm._v(" " + _vm._s(_vm.t("contacts", "Chart")) + ": ")]), _c("NcSelect", { staticClass: "chart-selection", attrs: { "disabled": _vm.data.length === 1, "options": _vm.charts, "allow-empty": false, "searchable": false, "placeholder": _vm.placeholder, "input-id": "select-chart-input", "label": "label" }, on: { "input": _vm.chartChanged }, model: { value: _vm.chart, callback: function($$v) {
    _vm.chart = $$v;
  }, expression: "chart" } })], 1) : _vm._e(), _c("div", { ref: "svgElementContainer", staticClass: "org-chart__container" })]);
};
var _sfc_staticRenderFns$K = [];
var __component__$K = /* @__PURE__ */ normalizeComponent(
  _sfc_main$K,
  _sfc_render$K,
  _sfc_staticRenderFns$K,
  false,
  null,
  null
);
const OrgChart2 = __component__$K.exports;
const _sfc_main$J = {
  name: "ChartContent",
  components: {
    AppContent: NcAppContent,
    OrgChart: OrgChart2
  },
  props: {
    contactsList: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      data: [],
      searchQuery: ""
    };
  },
  computed: {
    transformData() {
      const contactsByUid = {};
      const contacts = Object.keys(this.contactsList).map((key) => {
        const [uid, addressbook] = key.split("~");
        if (!contactsByUid[addressbook]) {
          contactsByUid[addressbook] = {};
        }
        return contactsByUid[addressbook][uid] = this.contactsList[key];
      });
      const headManagers = [];
      const tempContacts = contacts.filter((contact) => contact.managersName).reduce((prev, contact) => {
        prev.push(transformNode(contact));
        const manager = contactsByUid[contact.addressbook.id][contact.managersName];
        if (manager && !manager.managersName && !headManagers.some((m) => m.nodeId === manager.uid)) {
          prev.push(transformNode(manager));
          headManagers.push(transformNode(manager));
        }
        return prev;
      }, []);
      const charts = headManagers.map((managerNode) => getChart(tempContacts, managerNode));
      console.debug("Org charts", charts.map((nodes, index2) => nodes.map((n2) => `list ${index2} ${n2.nodeId} (${n2.fullName}) -> ${n2.parentNodeId}`)));
      return charts;
    }
  }
};
var _sfc_render$J = function render35() {
  var _vm = this, _c = _vm._self._c;
  return _c("AppContent", [_c("OrgChart", { attrs: { "data": _vm.transformData } })], 1);
};
var _sfc_staticRenderFns$J = [];
var __component__$J = /* @__PURE__ */ normalizeComponent(
  _sfc_main$J,
  _sfc_render$J,
  _sfc_staticRenderFns$J,
  false,
  null,
  null
);
const ChartContent = __component__$J.exports;
const enc = new TextEncoder();
const dec = new TextDecoder();
function encode$1(inData, parse_url) {
  let str;
  let data;
  if (typeof inData === "string" || typeof inData === "number") {
    str = `${inData}`;
    data = enc.encode(str);
  } else if (typeof Buffer !== "undefined" && Buffer.isBuffer(data)) {
    str = inData.toString();
  } else if (Array.isArray(inData)) {
    data = new Uint8Array(inData);
    str = dec.decode(inData);
  } else {
    throw new Error("Bad data: " + typeof inData);
  }
  if (/^[0-9]+$/.test(str)) {
    if (data.byteLength > 7089) {
      throw new Error("Too much data");
    }
    return encode_numeric(str);
  }
  if (/^[0-9A-Z \$%\*\+\.\/\:\-]+$/.test(str)) {
    if (data.byteLength > 4296) {
      throw new Error("Too much data");
    }
    return encode_alphanum(str);
  }
  if (parse_url && /^https?:/i.test(str)) {
    return encode_url(str);
  }
  if (data.byteLength > 2953) {
    throw new Error("Too much data");
  }
  return encode_8bit(new Uint8Array(data));
}
function pushBits(arr, n2, value) {
  for (let bit = 1 << n2 - 1; bit; bit >>>= 1) {
    arr.push(bit & value ? 1 : 0);
  }
}
function encode_8bit(data) {
  const len = data.byteLength;
  const bits = [];
  for (let i = 0; i < len; i++) {
    pushBits(bits, 8, data[i]);
  }
  const res = {};
  let d = [0, 1, 0, 0];
  pushBits(d, 16, len);
  res.data10 = res.data27 = d.concat(bits);
  if (len < 256) {
    let d2 = [0, 1, 0, 0];
    pushBits(d2, 8, len);
    res.data1 = d2.concat(bits);
  }
  return res;
}
const ALPHANUM = function(s2) {
  const res = {};
  for (let i = 0; i < s2.length; i++) {
    res[s2[i]] = i;
  }
  return res;
}("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:");
function encode_alphanum(str) {
  const len = str.length;
  const bits = [];
  for (let i = 0; i < len; i += 2) {
    let b = 6;
    let n2 = ALPHANUM[str[i]];
    if (str[i + 1]) {
      b = 11;
      n2 = n2 * 45 + ALPHANUM[str[i + 1]];
    }
    pushBits(bits, b, n2);
  }
  const res = {};
  let d = [0, 0, 1, 0];
  pushBits(d, 13, len);
  res.data27 = d.concat(bits);
  if (len < 2048) {
    let d2 = [0, 0, 1, 0];
    pushBits(d2, 11, len);
    res.data10 = d2.concat(bits);
  }
  if (len < 512) {
    let d2 = [0, 0, 1, 0];
    pushBits(d2, 9, len);
    res.data1 = d2.concat(bits);
  }
  return res;
}
function encode_numeric(str) {
  const len = str.length;
  const bits = [];
  for (let i = 0; i < len; i += 3) {
    const s2 = str.substr(i, 3);
    const b = Math.ceil(s2.length * 10 / 3);
    pushBits(bits, b, parseInt(s2, 10));
  }
  const res = {};
  let d = [0, 0, 0, 1];
  pushBits(d, 14, len);
  res.data27 = d.concat(bits);
  if (len < 4096) {
    let d2 = [0, 0, 0, 1];
    pushBits(d2, 12, len);
    res.data10 = d2.concat(bits);
  }
  if (len < 1024) {
    let d2 = [0, 0, 0, 1];
    pushBits(d2, 10, len);
    res.data1 = d2.concat(bits);
  }
  return res;
}
function encode_url(str) {
  const slash2 = str.indexOf("/", 8) + 1 || str.length;
  const res = encode$1(str.slice(0, slash2).toUpperCase(), false);
  if (slash2 >= str.length) {
    return res;
  }
  const path_res = encode$1(str.slice(slash2), false);
  res.data27 = res.data27.concat(path_res.data27);
  if (res.data10 && path_res.data10) {
    res.data10 = res.data10.concat(path_res.data10);
  }
  if (res.data1 && path_res.data1) {
    res.data1 = res.data1.concat(path_res.data1);
  }
  return res;
}
function calculateEC(msg, ec_len) {
  msg = [].slice.call(msg);
  const poly = generatorPolynomial(ec_len);
  for (let i = 0; i < ec_len; i++)
    msg.push(0);
  while (msg.length > ec_len) {
    if (!msg[0]) {
      msg.shift();
      continue;
    }
    const log_k = log(msg[0]);
    for (let i = 0; i <= ec_len; i++) {
      msg[i] = msg[i] ^ exp(poly[i] + log_k);
    }
    msg.shift();
  }
  return new Uint8Array(msg);
}
const GF256_BASE = 285;
const EXP_TABLE = [1];
const LOG_TABLE = [];
for (let i = 1; i < 256; i++) {
  let n2 = EXP_TABLE[i - 1] << 1;
  if (n2 > 255)
    n2 ^= GF256_BASE;
  EXP_TABLE[i] = n2;
}
for (let i = 0; i < 255; i++) {
  LOG_TABLE[EXP_TABLE[i]] = i;
}
function exp(k) {
  while (k < 0)
    k += 255;
  while (k > 255)
    k -= 255;
  return EXP_TABLE[k];
}
function log(k) {
  if (k < 1 || k > 255) {
    throw Error(`Bad log(${k})`);
  }
  return LOG_TABLE[k];
}
const POLYNOMIALS = [
  [0],
  [0, 0],
  [0, 25, 1]
];
function generatorPolynomial(num) {
  if (POLYNOMIALS[num]) {
    return POLYNOMIALS[num];
  }
  const prev = generatorPolynomial(num - 1);
  const res = [];
  res[0] = prev[0];
  for (let i = 1; i <= num; i++) {
    res[i] = log(exp(prev[i]) ^ exp(prev[i - 1] + num - 1));
  }
  POLYNOMIALS[num] = res;
  return res;
}
function init(version2) {
  const N = (version2 << 2) + 17;
  const matrix = [];
  let zeros = Array(N).fill(0);
  for (let i = 0; i < N; i++) {
    matrix[i] = [...zeros];
  }
  return matrix;
}
function fillFinders(matrix) {
  const N = matrix.length;
  for (var i = -3; i <= 3; i++) {
    for (let j = -3; j <= 3; j++) {
      const max2 = Math.max(i, j);
      const min2 = Math.min(i, j);
      const pixel = max2 == 2 && min2 >= -2 || min2 == -2 && max2 <= 2 ? 128 : 129;
      matrix[3 + i][3 + j] = pixel;
      matrix[3 + i][N - 4 + j] = pixel;
      matrix[N - 4 + i][3 + j] = pixel;
    }
  }
  for (var i = 0; i < 8; i++) {
    matrix[7][i] = matrix[i][7] = matrix[7][N - i - 1] = matrix[i][N - 8] = matrix[N - 8][i] = matrix[N - 1 - i][7] = 128;
  }
}
function fillAlignAndTiming(matrix) {
  const N = matrix.length;
  if (N > 21) {
    const len = N - 13;
    let delta = Math.round(len / Math.ceil(len / 28));
    if (delta % 2)
      delta++;
    const res = [];
    for (let p = len + 6; p > 10; p -= delta) {
      res.unshift(p);
    }
    res.unshift(6);
    for (var i = 0; i < res.length; i++) {
      for (let j = 0; j < res.length; j++) {
        const x2 = res[i];
        const y2 = res[j];
        if (matrix[x2][y2])
          continue;
        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            const max2 = Math.max(r, c);
            const min2 = Math.min(r, c);
            const pixel = max2 == 1 && min2 >= -1 || min2 == -1 && max2 <= 1 ? 128 : 129;
            matrix[x2 + r][y2 + c] = pixel;
          }
        }
      }
    }
  }
  for (var i = 8; i < N - 8; i++) {
    matrix[6][i] = matrix[i][6] = i % 2 ? 128 : 129;
  }
}
function fillStub(matrix) {
  const N = matrix.length;
  for (var i = 0; i < 8; i++) {
    if (i != 6) {
      matrix[8][i] = matrix[i][8] = 128;
    }
    matrix[8][N - 1 - i] = 128;
    matrix[N - 1 - i][8] = 128;
  }
  matrix[8][8] = 128;
  matrix[N - 8][8] = 129;
  if (N < 45)
    return;
  for (var i = N - 11; i < N - 8; i++) {
    for (let j = 0; j < 6; j++) {
      matrix[i][j] = matrix[j][i] = 128;
    }
  }
}
const fillReserved = function() {
  const FORMATS = Array(32);
  const VERSIONS = Array(40);
  const gf15 = 1335;
  const gf18 = 7973;
  const formats_mask = 21522;
  for (let format = 0; format < 32; format++) {
    let res = format << 10;
    for (let i = 5; i > 0; i--) {
      if (res >>> 9 + i) {
        res ^= gf15 << i - 1;
      }
    }
    FORMATS[format] = (res | format << 10) ^ formats_mask;
  }
  for (let version2 = 7; version2 <= 40; version2++) {
    let res = version2 << 12;
    for (let i = 6; i > 0; i--) {
      if (res >>> 11 + i) {
        res ^= gf18 << i - 1;
      }
    }
    VERSIONS[version2] = res | version2 << 12;
  }
  const EC_LEVELS2 = {
    L: 1,
    M: 0,
    Q: 3,
    H: 2
  };
  return function fillReserved2(matrix, ec_level, mask) {
    const N = matrix.length;
    const format = FORMATS[EC_LEVELS2[ec_level] << 3 | mask];
    function F(k) {
      return format >> k & 1 ? 129 : 128;
    }
    for (var i = 0; i < 8; i++) {
      matrix[8][N - 1 - i] = F(i);
      if (i < 6)
        matrix[i][8] = F(i);
    }
    for (var i = 8; i < 15; i++) {
      matrix[N - 15 + i][8] = F(i);
      if (i > 8)
        matrix[8][14 - i] = F(i);
    }
    matrix[7][8] = F(6);
    matrix[8][8] = F(7);
    matrix[8][7] = F(8);
    const version2 = VERSIONS[(N - 17) / 4];
    if (!version2) {
      return;
    }
    function V(k) {
      return version2 >> k & 1 ? 129 : 128;
    }
    for (var i = 0; i < 6; i++) {
      for (let j = 0; j < 3; j++) {
        matrix[N - 11 + j][i] = matrix[i][N - 11 + j] = V(i * 3 + j);
      }
    }
  };
}();
const fillData = /* @__PURE__ */ function() {
  const MASK_FUNCTIONS = [
    (i, j) => (i + j) % 2 == 0,
    (i, j) => i % 2 == 0,
    (i, j) => j % 3 == 0,
    (i, j) => (i + j) % 3 == 0,
    (i, j) => (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0,
    (i, j) => i * j % 2 + i * j % 3 == 0,
    (i, j) => (i * j % 2 + i * j % 3) % 2 == 0,
    (i, j) => (i * j % 3 + (i + j) % 2) % 2 == 0
  ];
  return function fillData2(matrix, data, mask) {
    const N = matrix.length;
    let row;
    let col;
    let dir = -1;
    row = col = N - 1;
    const mask_fn = MASK_FUNCTIONS[mask];
    let len = data.blocks[data.blocks.length - 1].length;
    for (var i = 0; i < len; i++) {
      for (var b = 0; b < data.blocks.length; b++) {
        if (data.blocks[b].length <= i) {
          continue;
        }
        put(data.blocks[b][i]);
      }
    }
    len = data.ec_len;
    for (var i = 0; i < len; i++) {
      for (var b = 0; b < data.ec.length; b++) {
        put(data.ec[b][i]);
      }
    }
    if (col > -1) {
      do {
        matrix[row][col] = mask_fn(row, col) ? 1 : 0;
      } while (next());
    }
    function put(byte) {
      for (let mask2 = 128; mask2; mask2 >>= 1) {
        let pixel = !!(mask2 & byte);
        if (mask_fn(row, col))
          pixel = !pixel;
        matrix[row][col] = pixel ? 1 : 0;
        next();
      }
    }
    function next() {
      do {
        if (col % 2 ^ Number(col < 6)) {
          if (dir < 0 && row == 0 || dir > 0 && row == N - 1) {
            col--;
            dir = -dir;
          } else {
            col++;
            row += dir;
          }
        } else {
          col--;
        }
        if (col == 6) {
          col--;
        }
        if (col < 0) {
          return false;
        }
      } while (matrix[row][col] & 240);
      return true;
    }
  };
}();
function calculatePenalty(matrix) {
  const N = matrix.length;
  let penalty = 0;
  for (var i = 0; i < N; i++) {
    var pixel = matrix[i][0] & 1;
    var len = 1;
    for (var j = 1; j < N; j++) {
      var p = matrix[i][j] & 1;
      if (p == pixel) {
        len++;
        continue;
      }
      if (len >= 5) {
        penalty += len - 2;
      }
      pixel = p;
      len = 1;
    }
    if (len >= 5) {
      penalty += len - 2;
    }
  }
  for (var j = 0; j < N; j++) {
    var pixel = matrix[0][j] & 1;
    var len = 1;
    for (var i = 1; i < N; i++) {
      var p = matrix[i][j] & 1;
      if (p == pixel) {
        len++;
        continue;
      }
      if (len >= 5) {
        penalty += len - 2;
      }
      pixel = p;
      len = 1;
    }
    if (len >= 5) {
      penalty += len - 2;
    }
  }
  for (var i = 0; i < N - 1; i++) {
    for (var j = 0; j < N - 1; j++) {
      const s2 = matrix[i][j] + matrix[i][j + 1] + matrix[i + 1][j] + matrix[i + 1][j + 1] & 7;
      if (s2 == 0 || s2 == 4) {
        penalty += 3;
      }
    }
  }
  function I(k) {
    return matrix[i][j + k] & 1;
  }
  function J(k) {
    return matrix[i + k][j] & 1;
  }
  for (var i = 0; i < N; i++) {
    for (var j = 0; j < N; j++) {
      if (j < N - 6 && I(0) && !I(1) && I(2) && I(3) && I(4) && !I(5) && I(6)) {
        if (j >= 4 && !(I(-4) || I(-3) || I(-2) || I(-1))) {
          penalty += 40;
        }
        if (j < N - 10 && !(I(7) || I(8) || I(9) || I(10))) {
          penalty += 40;
        }
      }
      if (i < N - 6 && J(0) && !J(1) && J(2) && J(3) && J(4) && !J(5) && J(6)) {
        if (i >= 4 && !(J(-4) || J(-3) || J(-2) || J(-1))) {
          penalty += 40;
        }
        if (i < N - 10 && !(J(7) || J(8) || J(9) || J(10))) {
          penalty += 40;
        }
      }
    }
  }
  let numDark = 0;
  for (var i = 0; i < N; i++) {
    for (var j = 0; j < N; j++) {
      if (matrix[i][j] & 1)
        numDark++;
    }
  }
  penalty += 10 * Math.floor(Math.abs(10 - 20 * numDark / (N * N)));
  return penalty;
}
function getMatrix(data) {
  const matrix = init(data.version);
  fillFinders(matrix);
  fillAlignAndTiming(matrix);
  fillStub(matrix);
  let penalty = Infinity;
  let bestMask = 0;
  for (let mask = 0; mask < 8; mask++) {
    fillData(matrix, data, mask);
    fillReserved(matrix, data.ec_level, mask);
    const p = calculatePenalty(matrix);
    if (p < penalty) {
      penalty = p;
      bestMask = mask;
    }
  }
  fillData(matrix, data, bestMask);
  fillReserved(matrix, data.ec_level, bestMask);
  return matrix.map((row) => row.map((cell) => cell & 1));
}
const EC_LEVELS = ["L", "M", "Q", "H"];
function getTemplate(message, ec_level) {
  let i = 1;
  let len;
  if (message.data1) {
    len = Math.ceil(message.data1.length / 8);
  } else {
    i = 10;
  }
  for (; i < 10; i++) {
    let version2 = mappedVersions[i][ec_level];
    if (version2.data_len >= len) {
      return deepCopy(version2);
    }
  }
  if (message.data10) {
    len = Math.ceil(message.data10.length / 8);
  } else {
    i = 27;
  }
  for (; i < 27; i++) {
    let version2 = mappedVersions[i][ec_level];
    if (version2.data_len >= len) {
      return deepCopy(version2);
    }
  }
  len = Math.ceil(message.data27.length / 8);
  for (; i < 41; i++) {
    let version2 = mappedVersions[i][ec_level];
    if (version2.data_len >= len) {
      return deepCopy(version2);
    }
  }
  throw new Error("Too much data");
}
function fillTemplate(message, template) {
  const blocks = new Uint8Array(template.data_len);
  let messageUpdated;
  if (template.version < 10) {
    messageUpdated = message.data1;
  } else if (template.version < 27) {
    messageUpdated = message.data10;
  } else {
    messageUpdated = message.data27;
  }
  const len = messageUpdated.length;
  for (let i = 0; i < len; i += 8) {
    let b = 0;
    for (let j = 0; j < 8; j++) {
      b = b << 1 | (messageUpdated[i + j] ? 1 : 0);
    }
    blocks[i / 8] = b;
  }
  let pad = 236;
  for (let i = Math.ceil((len + 4) / 8); i < blocks.length; i++) {
    blocks[i] = pad;
    pad = pad == 236 ? 17 : 236;
  }
  let offset = 0;
  template.blocks = template.blocks.map((n2) => {
    const b = blocks.slice(offset, offset + n2);
    offset += n2;
    template.ec.push(calculateEC(b, template.ec_len));
    return b;
  });
  return template;
}
function QR(text, ec_level, parse_url) {
  ec_level = EC_LEVELS.includes(ec_level) ? ec_level : "M";
  const message = encode$1(text, parse_url);
  const data = fillTemplate(message, getTemplate(message, ec_level));
  return getMatrix(data);
}
const deepCopy = typeof structuredClone !== "undefined" ? structuredClone : (obj) => JSON.parse(JSON.stringify(obj));
const versions = [
  [],
  [26, 7, 1, 10, 1, 13, 1, 17, 1],
  [44, 10, 1, 16, 1, 22, 1, 28, 1],
  [70, 15, 1, 26, 1, 36, 2, 44, 2],
  [100, 20, 1, 36, 2, 52, 2, 64, 4],
  [134, 26, 1, 48, 2, 72, 4, 88, 4],
  [172, 36, 2, 64, 4, 96, 4, 112, 4],
  [196, 40, 2, 72, 4, 108, 6, 130, 5],
  [242, 48, 2, 88, 4, 132, 6, 156, 6],
  [292, 60, 2, 110, 5, 160, 8, 192, 8],
  [346, 72, 4, 130, 5, 192, 8, 224, 8],
  [404, 80, 4, 150, 5, 224, 8, 264, 11],
  [466, 96, 4, 176, 8, 260, 10, 308, 11],
  [532, 104, 4, 198, 9, 288, 12, 352, 16],
  [581, 120, 4, 216, 9, 320, 16, 384, 16],
  [655, 132, 6, 240, 10, 360, 12, 432, 18],
  [733, 144, 6, 280, 10, 408, 17, 480, 16],
  [815, 168, 6, 308, 11, 448, 16, 532, 19],
  [901, 180, 6, 338, 13, 504, 18, 588, 21],
  [991, 196, 7, 364, 14, 546, 21, 650, 25],
  [1085, 224, 8, 416, 16, 600, 20, 700, 25],
  [1156, 224, 8, 442, 17, 644, 23, 750, 25],
  [1258, 252, 9, 476, 17, 690, 23, 816, 34],
  [1364, 270, 9, 504, 18, 750, 25, 900, 30],
  [1474, 300, 10, 560, 20, 810, 27, 960, 32],
  [1588, 312, 12, 588, 21, 870, 29, 1050, 35],
  [1706, 336, 12, 644, 23, 952, 34, 1110, 37],
  [1828, 360, 12, 700, 25, 1020, 34, 1200, 40],
  [1921, 390, 13, 728, 26, 1050, 35, 1260, 42],
  [2051, 420, 14, 784, 28, 1140, 38, 1350, 45],
  [2185, 450, 15, 812, 29, 1200, 40, 1440, 48],
  [2323, 480, 16, 868, 31, 1290, 43, 1530, 51],
  [2465, 510, 17, 924, 33, 1350, 45, 1620, 54],
  [2611, 540, 18, 980, 35, 1440, 48, 1710, 57],
  [2761, 570, 19, 1036, 37, 1530, 51, 1800, 60],
  [2876, 570, 19, 1064, 38, 1590, 53, 1890, 63],
  [3034, 600, 20, 1120, 40, 1680, 56, 1980, 66],
  [3196, 630, 21, 1204, 43, 1770, 59, 2100, 70],
  [3362, 660, 22, 1260, 45, 1860, 62, 2220, 74],
  [3532, 720, 24, 1316, 47, 1950, 65, 2310, 77],
  [3706, 750, 25, 1372, 49, 2040, 68, 2430, 81]
];
const mappedVersions = versions.map((el, index2) => {
  if (!index2) {
    return /* @__PURE__ */ Object.create(null);
  }
  const res = /* @__PURE__ */ Object.create(null);
  for (let i = 1; i < 8; i += 2) {
    const length = el[0] - el[i];
    const num_template = el[i + 1];
    const ec_level = EC_LEVELS[i / 2 | 0];
    const level = {
      version: index2,
      ec_level,
      data_len: length,
      ec_len: el[i] / num_template,
      blocks: [],
      ec: []
    };
    for (let k = num_template, n2 = length; k > 0; k--) {
      const block = n2 / k | 0;
      level.blocks.push(block);
      n2 -= block;
    }
    res[ec_level] = level;
  }
  return res;
});
var colorString$1 = { exports: {} };
var colorName = {
  "aliceblue": [240, 248, 255],
  "antiquewhite": [250, 235, 215],
  "aqua": [0, 255, 255],
  "aquamarine": [127, 255, 212],
  "azure": [240, 255, 255],
  "beige": [245, 245, 220],
  "bisque": [255, 228, 196],
  "black": [0, 0, 0],
  "blanchedalmond": [255, 235, 205],
  "blue": [0, 0, 255],
  "blueviolet": [138, 43, 226],
  "brown": [165, 42, 42],
  "burlywood": [222, 184, 135],
  "cadetblue": [95, 158, 160],
  "chartreuse": [127, 255, 0],
  "chocolate": [210, 105, 30],
  "coral": [255, 127, 80],
  "cornflowerblue": [100, 149, 237],
  "cornsilk": [255, 248, 220],
  "crimson": [220, 20, 60],
  "cyan": [0, 255, 255],
  "darkblue": [0, 0, 139],
  "darkcyan": [0, 139, 139],
  "darkgoldenrod": [184, 134, 11],
  "darkgray": [169, 169, 169],
  "darkgreen": [0, 100, 0],
  "darkgrey": [169, 169, 169],
  "darkkhaki": [189, 183, 107],
  "darkmagenta": [139, 0, 139],
  "darkolivegreen": [85, 107, 47],
  "darkorange": [255, 140, 0],
  "darkorchid": [153, 50, 204],
  "darkred": [139, 0, 0],
  "darksalmon": [233, 150, 122],
  "darkseagreen": [143, 188, 143],
  "darkslateblue": [72, 61, 139],
  "darkslategray": [47, 79, 79],
  "darkslategrey": [47, 79, 79],
  "darkturquoise": [0, 206, 209],
  "darkviolet": [148, 0, 211],
  "deeppink": [255, 20, 147],
  "deepskyblue": [0, 191, 255],
  "dimgray": [105, 105, 105],
  "dimgrey": [105, 105, 105],
  "dodgerblue": [30, 144, 255],
  "firebrick": [178, 34, 34],
  "floralwhite": [255, 250, 240],
  "forestgreen": [34, 139, 34],
  "fuchsia": [255, 0, 255],
  "gainsboro": [220, 220, 220],
  "ghostwhite": [248, 248, 255],
  "gold": [255, 215, 0],
  "goldenrod": [218, 165, 32],
  "gray": [128, 128, 128],
  "green": [0, 128, 0],
  "greenyellow": [173, 255, 47],
  "grey": [128, 128, 128],
  "honeydew": [240, 255, 240],
  "hotpink": [255, 105, 180],
  "indianred": [205, 92, 92],
  "indigo": [75, 0, 130],
  "ivory": [255, 255, 240],
  "khaki": [240, 230, 140],
  "lavender": [230, 230, 250],
  "lavenderblush": [255, 240, 245],
  "lawngreen": [124, 252, 0],
  "lemonchiffon": [255, 250, 205],
  "lightblue": [173, 216, 230],
  "lightcoral": [240, 128, 128],
  "lightcyan": [224, 255, 255],
  "lightgoldenrodyellow": [250, 250, 210],
  "lightgray": [211, 211, 211],
  "lightgreen": [144, 238, 144],
  "lightgrey": [211, 211, 211],
  "lightpink": [255, 182, 193],
  "lightsalmon": [255, 160, 122],
  "lightseagreen": [32, 178, 170],
  "lightskyblue": [135, 206, 250],
  "lightslategray": [119, 136, 153],
  "lightslategrey": [119, 136, 153],
  "lightsteelblue": [176, 196, 222],
  "lightyellow": [255, 255, 224],
  "lime": [0, 255, 0],
  "limegreen": [50, 205, 50],
  "linen": [250, 240, 230],
  "magenta": [255, 0, 255],
  "maroon": [128, 0, 0],
  "mediumaquamarine": [102, 205, 170],
  "mediumblue": [0, 0, 205],
  "mediumorchid": [186, 85, 211],
  "mediumpurple": [147, 112, 219],
  "mediumseagreen": [60, 179, 113],
  "mediumslateblue": [123, 104, 238],
  "mediumspringgreen": [0, 250, 154],
  "mediumturquoise": [72, 209, 204],
  "mediumvioletred": [199, 21, 133],
  "midnightblue": [25, 25, 112],
  "mintcream": [245, 255, 250],
  "mistyrose": [255, 228, 225],
  "moccasin": [255, 228, 181],
  "navajowhite": [255, 222, 173],
  "navy": [0, 0, 128],
  "oldlace": [253, 245, 230],
  "olive": [128, 128, 0],
  "olivedrab": [107, 142, 35],
  "orange": [255, 165, 0],
  "orangered": [255, 69, 0],
  "orchid": [218, 112, 214],
  "palegoldenrod": [238, 232, 170],
  "palegreen": [152, 251, 152],
  "paleturquoise": [175, 238, 238],
  "palevioletred": [219, 112, 147],
  "papayawhip": [255, 239, 213],
  "peachpuff": [255, 218, 185],
  "peru": [205, 133, 63],
  "pink": [255, 192, 203],
  "plum": [221, 160, 221],
  "powderblue": [176, 224, 230],
  "purple": [128, 0, 128],
  "rebeccapurple": [102, 51, 153],
  "red": [255, 0, 0],
  "rosybrown": [188, 143, 143],
  "royalblue": [65, 105, 225],
  "saddlebrown": [139, 69, 19],
  "salmon": [250, 128, 114],
  "sandybrown": [244, 164, 96],
  "seagreen": [46, 139, 87],
  "seashell": [255, 245, 238],
  "sienna": [160, 82, 45],
  "silver": [192, 192, 192],
  "skyblue": [135, 206, 235],
  "slateblue": [106, 90, 205],
  "slategray": [112, 128, 144],
  "slategrey": [112, 128, 144],
  "snow": [255, 250, 250],
  "springgreen": [0, 255, 127],
  "steelblue": [70, 130, 180],
  "tan": [210, 180, 140],
  "teal": [0, 128, 128],
  "thistle": [216, 191, 216],
  "tomato": [255, 99, 71],
  "turquoise": [64, 224, 208],
  "violet": [238, 130, 238],
  "wheat": [245, 222, 179],
  "white": [255, 255, 255],
  "whitesmoke": [245, 245, 245],
  "yellow": [255, 255, 0],
  "yellowgreen": [154, 205, 50]
};
var simpleSwizzle = { exports: {} };
var isArrayish$1 = function isArrayish(obj) {
  if (!obj || typeof obj === "string") {
    return false;
  }
  return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
};
var isArrayish2 = isArrayish$1;
var concat = Array.prototype.concat;
var slice = Array.prototype.slice;
var swizzle$1 = simpleSwizzle.exports = function swizzle(args) {
  var results = [];
  for (var i = 0, len = args.length; i < len; i++) {
    var arg = args[i];
    if (isArrayish2(arg)) {
      results = concat.call(results, slice.call(arg));
    } else {
      results.push(arg);
    }
  }
  return results;
};
swizzle$1.wrap = function(fn) {
  return function() {
    return fn(swizzle$1(arguments));
  };
};
var simpleSwizzleExports = simpleSwizzle.exports;
var colorNames = colorName;
var swizzle2 = simpleSwizzleExports;
var hasOwnProperty = Object.hasOwnProperty;
var reverseNames = /* @__PURE__ */ Object.create(null);
for (var name in colorNames) {
  if (hasOwnProperty.call(colorNames, name)) {
    reverseNames[colorNames[name]] = name;
  }
}
var cs = colorString$1.exports = {
  to: {},
  get: {}
};
cs.get = function(string) {
  var prefix = string.substring(0, 3).toLowerCase();
  var val;
  var model;
  switch (prefix) {
    case "hsl":
      val = cs.get.hsl(string);
      model = "hsl";
      break;
    case "hwb":
      val = cs.get.hwb(string);
      model = "hwb";
      break;
    default:
      val = cs.get.rgb(string);
      model = "rgb";
      break;
  }
  if (!val) {
    return null;
  }
  return { model, value: val };
};
cs.get.rgb = function(string) {
  if (!string) {
    return null;
  }
  var abbr = /^#([a-f0-9]{3,4})$/i;
  var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
  var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
  var keyword = /^(\w+)$/;
  var rgb2 = [0, 0, 0, 1];
  var match;
  var i;
  var hexAlpha;
  if (match = string.match(hex2)) {
    hexAlpha = match[2];
    match = match[1];
    for (i = 0; i < 3; i++) {
      var i2 = i * 2;
      rgb2[i] = parseInt(match.slice(i2, i2 + 2), 16);
    }
    if (hexAlpha) {
      rgb2[3] = parseInt(hexAlpha, 16) / 255;
    }
  } else if (match = string.match(abbr)) {
    match = match[1];
    hexAlpha = match[3];
    for (i = 0; i < 3; i++) {
      rgb2[i] = parseInt(match[i] + match[i], 16);
    }
    if (hexAlpha) {
      rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    }
  } else if (match = string.match(rgba2)) {
    for (i = 0; i < 3; i++) {
      rgb2[i] = parseInt(match[i + 1], 0);
    }
    if (match[4]) {
      if (match[5]) {
        rgb2[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb2[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(per)) {
    for (i = 0; i < 3; i++) {
      rgb2[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
    }
    if (match[4]) {
      if (match[5]) {
        rgb2[3] = parseFloat(match[4]) * 0.01;
      } else {
        rgb2[3] = parseFloat(match[4]);
      }
    }
  } else if (match = string.match(keyword)) {
    if (match[1] === "transparent") {
      return [0, 0, 0, 0];
    }
    if (!hasOwnProperty.call(colorNames, match[1])) {
      return null;
    }
    rgb2 = colorNames[match[1]];
    rgb2[3] = 1;
    return rgb2;
  } else {
    return null;
  }
  for (i = 0; i < 3; i++) {
    rgb2[i] = clamp(rgb2[i], 0, 255);
  }
  rgb2[3] = clamp(rgb2[3], 0, 1);
  return rgb2;
};
cs.get.hsl = function(string) {
  if (!string) {
    return null;
  }
  var hsl2 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hsl2);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var s2 = clamp(parseFloat(match[2]), 0, 100);
    var l = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, s2, l, a];
  }
  return null;
};
cs.get.hwb = function(string) {
  if (!string) {
    return null;
  }
  var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
  var match = string.match(hwb);
  if (match) {
    var alpha = parseFloat(match[4]);
    var h = (parseFloat(match[1]) % 360 + 360) % 360;
    var w = clamp(parseFloat(match[2]), 0, 100);
    var b = clamp(parseFloat(match[3]), 0, 100);
    var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    return [h, w, b, a];
  }
  return null;
};
cs.to.hex = function() {
  var rgba2 = swizzle2(arguments);
  return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
};
cs.to.rgb = function() {
  var rgba2 = swizzle2(arguments);
  return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
};
cs.to.rgb.percent = function() {
  var rgba2 = swizzle2(arguments);
  var r = Math.round(rgba2[0] / 255 * 100);
  var g = Math.round(rgba2[1] / 255 * 100);
  var b = Math.round(rgba2[2] / 255 * 100);
  return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba2[3] + ")";
};
cs.to.hsl = function() {
  var hsla2 = swizzle2(arguments);
  return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
};
cs.to.hwb = function() {
  var hwba = swizzle2(arguments);
  var a = "";
  if (hwba.length >= 4 && hwba[3] !== 1) {
    a = ", " + hwba[3];
  }
  return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
};
cs.to.keyword = function(rgb2) {
  return reverseNames[rgb2.slice(0, 3)];
};
function clamp(num, min2, max2) {
  return Math.min(Math.max(min2, num), max2);
}
function hexDouble(num) {
  var str = Math.round(num).toString(16).toUpperCase();
  return str.length < 2 ? "0" + str : str;
}
var colorStringExports = colorString$1.exports;
const colorString = /* @__PURE__ */ getDefaultExportFromCjs(colorStringExports);
function getOptions(inOptions) {
  const type = inOptions?.type ?? "png";
  const defaults2 = type === "png" ? BITMAP_OPTIONS : VECTOR_OPTIONS;
  return { ...defaults2, ...inOptions };
}
function colorToHex(color2) {
  if (typeof color2 === "string") {
    return colorString.to.hex(colorString.get.rgb(color2));
  }
  return `#${(color2 >>> 8).toString(16).padStart(6, "0")}`;
}
function getSVGPath(matrix, size, margin = 0, borderRadius = 0) {
  let rectangles = [];
  for (let x2 = 0; x2 < matrix.length; x2++) {
    const column = matrix[x2];
    for (let y2 = 0; y2 < column.length; y2++) {
      if (column[y2]) {
        const leftX = x2 * size + margin;
        const rightX = (x2 + 1) * size + margin;
        const topY = y2 * size + margin;
        const bottomY = (y2 + 1) * size + margin;
        const rectangle = [];
        rectangle.push(`M ${leftX} ${topY + borderRadius}`);
        rectangle.push(`L ${leftX} ${bottomY - borderRadius}`);
        if (borderRadius > 0) {
          rectangle.push(`A ${borderRadius} ${borderRadius} 0 0 0 ${leftX + borderRadius} ${bottomY} `);
        }
        rectangle.push(`L ${rightX - borderRadius} ${bottomY}`);
        if (borderRadius > 0) {
          rectangle.push(`A ${borderRadius} ${borderRadius} 0 0 0 ${rightX} ${bottomY - borderRadius}`);
        }
        rectangle.push(`L ${rightX} ${topY + borderRadius}`);
        if (borderRadius > 0) {
          rectangle.push(`A ${borderRadius} ${borderRadius} 0 0 0 ${rightX - borderRadius} ${topY}`);
        }
        rectangle.push(`L ${leftX + borderRadius} ${topY}`);
        if (borderRadius > 0) {
          rectangle.push(`A ${borderRadius} ${borderRadius} 0 0 0 ${leftX} ${topY + borderRadius}`);
        }
        rectangle.push(`z`);
        rectangles.push(rectangle.join(" "));
      }
    }
  }
  return rectangles.join(" ");
}
const commonOptions = {
  type: "png",
  parse_url: false,
  ec_level: "M",
  logo: void 0,
  logoWidth: 20,
  logoHeight: 20,
  bgColor: 4294967295,
  color: 255
};
const BITMAP_OPTIONS = {
  ...commonOptions,
  margin: 1,
  size: 5
};
const VECTOR_OPTIONS = {
  ...commonOptions,
  margin: 1,
  size: 0
};
const version = "3.7.7";
const VERSION = version;
const _hasBuffer = typeof Buffer === "function";
const _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
const _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
const b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
const b64chs = Array.prototype.slice.call(b64ch);
const b64tab = ((a) => {
  let tab = {};
  a.forEach((c, i) => tab[c] = i);
  return tab;
})(b64chs);
const b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
const _fromCC = String.fromCharCode.bind(String);
const _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
const _mkUriSafe = (src) => src.replace(/=/g, "").replace(/[+\/]/g, (m0) => m0 == "+" ? "-" : "_");
const _tidyB64 = (s2) => s2.replace(/[^A-Za-z0-9\+\/]/g, "");
const btoaPolyfill = (bin) => {
  let u32, c0, c1, c2, asc = "";
  const pad = bin.length % 3;
  for (let i = 0; i < bin.length; ) {
    if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
      throw new TypeError("invalid character found");
    u32 = c0 << 16 | c1 << 8 | c2;
    asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
  }
  return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
};
const _btoa = typeof btoa === "function" ? (bin) => btoa(bin) : _hasBuffer ? (bin) => Buffer.from(bin, "binary").toString("base64") : btoaPolyfill;
const _fromUint8Array = _hasBuffer ? (u8a) => Buffer.from(u8a).toString("base64") : (u8a) => {
  const maxargs = 4096;
  let strs = [];
  for (let i = 0, l = u8a.length; i < l; i += maxargs) {
    strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
  }
  return _btoa(strs.join(""));
};
const fromUint8Array = (u8a, urlsafe = false) => urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
const cb_utob = (c) => {
  if (c.length < 2) {
    var cc = c.charCodeAt(0);
    return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  } else {
    var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
    return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
  }
};
const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
const utob = (u) => u.replace(re_utob, cb_utob);
const _encode = _hasBuffer ? (s2) => Buffer.from(s2, "utf8").toString("base64") : _TE ? (s2) => _fromUint8Array(_TE.encode(s2)) : (s2) => _btoa(utob(s2));
const encode = (src, urlsafe = false) => urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
const encodeURI$1 = (src) => encode(src, true);
const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
const cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
const btou = (b) => b.replace(re_btou, cb_btou);
const atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r2;
  for (let i = 0; i < asc.length; ) {
    u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
const _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
const _toUint8Array = _hasBuffer ? (a) => _U8Afrom(Buffer.from(a, "base64")) : (a) => _U8Afrom(_atob(a).split("").map((c) => c.charCodeAt(0)));
const toUint8Array = (a) => _toUint8Array(_unURI(a));
const _decode = _hasBuffer ? (a) => Buffer.from(a, "base64").toString("utf8") : _TD ? (a) => _TD.decode(_toUint8Array(a)) : (a) => btou(_atob(a));
const _unURI = (a) => _tidyB64(a.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
const decode = (src) => _decode(_unURI(src));
const isValid = (src) => {
  if (typeof src !== "string")
    return false;
  const s2 = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
  return !/[^\s0-9a-zA-Z\+/]/.test(s2) || !/[^\s0-9a-zA-Z\-_]/.test(s2);
};
const _noEnum = (v2) => {
  return {
    value: v2,
    enumerable: false,
    writable: true,
    configurable: true
  };
};
const extendString = function() {
  const _add = (name, body) => Object.defineProperty(String.prototype, name, _noEnum(body));
  _add("fromBase64", function() {
    return decode(this);
  });
  _add("toBase64", function(urlsafe) {
    return encode(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return encode(this, true);
  });
  _add("toBase64URL", function() {
    return encode(this, true);
  });
  _add("toUint8Array", function() {
    return toUint8Array(this);
  });
};
const extendUint8Array = function() {
  const _add = (name, body) => Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
  _add("toBase64", function(urlsafe) {
    return fromUint8Array(this, urlsafe);
  });
  _add("toBase64URI", function() {
    return fromUint8Array(this, true);
  });
  _add("toBase64URL", function() {
    return fromUint8Array(this, true);
  });
};
const extendBuiltins = () => {
  extendString();
  extendUint8Array();
};
const gBase64 = {
  version,
  VERSION,
  atob: _atob,
  atobPolyfill,
  btoa: _btoa,
  btoaPolyfill,
  fromBase64: decode,
  toBase64: encode,
  encode,
  encodeURI: encodeURI$1,
  encodeURL: encodeURI$1,
  utob,
  btou,
  decode,
  isValid,
  fromUint8Array,
  toUint8Array,
  extendString,
  extendUint8Array,
  extendBuiltins
};
async function getSVG(text, inOptions = {}) {
  const options = getOptions({ ...inOptions, type: "svg" });
  const matrix = QR(text, options.ec_level, options.parse_url);
  return createSVG({ matrix, ...options });
}
const te = new TextEncoder();
async function createSVG({ matrix, margin, size, logo, logoWidth, logoHeight, color: color2, bgColor, imageWidth, imageHeight, borderRadius }) {
  const actualSize = size || 9;
  const X = matrix.length + 2 * margin;
  const XY = X * (actualSize || 1);
  const imageWidthStr = imageWidth ? ` width="${imageWidth}"` : "";
  const imageHeightStr = imageHeight ? `height="${imageWidth}" ` : "";
  const xmlTag = `<?xml version="1.0" encoding="utf-8"?>`;
  const svgOpeningTag = `<svg xmlns="http://www.w3.org/2000/svg" version="1.1" xmlns:xlink="http://www.w3.org/1999/xlink"${imageWidthStr} ${imageHeightStr}viewBox="0 0 ${XY} ${XY}">`;
  const svgBody = getSVGBody(matrix, {
    color: color2,
    bgColor,
    size: XY,
    margin,
    blockSize: actualSize,
    borderRadius
  });
  const svgEndTag = "</svg>";
  const logoImage = logo ? getLogoImage(logo, XY, logoWidth, logoHeight) : "";
  return te.encode(xmlTag + svgOpeningTag + svgBody + logoImage + svgEndTag);
}
function getSVGBody(matrix, options) {
  const path2 = getSVGPath(matrix, options.blockSize, options.margin * options.blockSize, options.borderRadius);
  let svgBody = `<rect width="${options.size}" height="${options.size}" fill="${colorToHex(options.bgColor)}"></rect>`;
  svgBody += '<path shape-rendering="geometricPrecision" d="' + path2 + '" fill="' + colorToHex(options.color) + '"/>';
  return svgBody;
}
function getLogoImage(logo, XY, logoWidth, logoHeight) {
  const imageBase64 = `data:image/png;base64,${typeof Buffer !== "undefined" && Buffer.isBuffer(logo) ? logo.toString("base64") : gBase64.fromUint8Array(new Uint8Array(logo))}`;
  return `<image width="${logoWidth / 100 * XY}" height="${logoHeight / 100 * XY}" xlink:href="${imageBase64}" x="${XY / 2 - logoWidth / 100 * XY / 2}" y="${XY / 2 - logoHeight / 100 * XY / 2}"></image>`;
}
const _sfc_main$I = {
  name: "DownloadIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$I = function render36() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon download-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$I = [];
var __component__$I = /* @__PURE__ */ normalizeComponent(
  _sfc_main$I,
  _sfc_render$I,
  _sfc_staticRenderFns$I,
  false,
  null,
  null
);
const IconDownload = __component__$I.exports;
const _sfc_main$H = {
  name: "QrcodeIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$H = function render37() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon qrcode-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M3,11H5V13H3V11M11,5H13V9H11V5M9,11H13V15H11V13H9V11M15,11H17V13H19V11H21V13H19V15H21V19H19V21H17V19H13V21H11V17H15V15H17V13H15V11M19,19V15H17V19H19M15,3H21V9H15V3M17,5V7H19V5H17M3,3H9V9H3V3M5,5V7H7V5H5M3,15H9V21H3V15M5,17V19H7V17H5Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$H = [];
var __component__$H = /* @__PURE__ */ normalizeComponent(
  _sfc_main$H,
  _sfc_render$H,
  _sfc_staticRenderFns$H,
  false,
  null,
  null
);
const IconQr = __component__$H.exports;
const _sfc_main$G = {
  name: "CakeIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$G = function render38() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon cake-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M11.5,0.5C12,0.75 13,2.4 13,3.5C13,4.6 12.33,5 11.5,5C10.67,5 10,4.85 10,3.75C10,2.65 11,2 11.5,0.5M18.5,9C21,9 23,11 23,13.5C23,15.06 22.21,16.43 21,17.24V23H12L3,23V17.24C1.79,16.43 1,15.06 1,13.5C1,11 3,9 5.5,9H10V6H13V9H18.5M12,16A2.5,2.5 0 0,0 14.5,13.5H16A2.5,2.5 0 0,0 18.5,16A2.5,2.5 0 0,0 21,13.5A2.5,2.5 0 0,0 18.5,11H5.5A2.5,2.5 0 0,0 3,13.5A2.5,2.5 0 0,0 5.5,16A2.5,2.5 0 0,0 8,13.5H9.5A2.5,2.5 0 0,0 12,16Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$G = [];
var __component__$G = /* @__PURE__ */ normalizeComponent(
  _sfc_main$G,
  _sfc_render$G,
  _sfc_staticRenderFns$G,
  false,
  null,
  null
);
const CakeIcon = __component__$G.exports;
const _sfc_main$F = {
  name: "EyeCircleIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$F = function render39() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon eye-circle-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,9.5A2.5,2.5 0 0,0 9.5,12A2.5,2.5 0 0,0 12,14.5A2.5,2.5 0 0,0 14.5,12A2.5,2.5 0 0,0 12,9.5M12,13A1,1 0 0,1 11,12A1,1 0 0,1 12,11A1,1 0 0,1 13,12A1,1 0 0,1 12,13M12,9.5A2.5,2.5 0 0,0 9.5,12A2.5,2.5 0 0,0 12,14.5A2.5,2.5 0 0,0 14.5,12A2.5,2.5 0 0,0 12,9.5M12,13A1,1 0 0,1 11,12A1,1 0 0,1 12,11A1,1 0 0,1 13,12A1,1 0 0,1 12,13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,16C9.37,16 7,14.43 6,12C7.38,8.69 11.19,7.12 14.5,8.5C16.08,9.16 17.34,10.42 18,12C17,14.43 14.63,16 12,16M12,9.5A2.5,2.5 0 0,0 9.5,12A2.5,2.5 0 0,0 12,14.5A2.5,2.5 0 0,0 14.5,12A2.5,2.5 0 0,0 12,9.5M12,13A1,1 0 0,1 11,12A1,1 0 0,1 12,11A1,1 0 0,1 13,12A1,1 0 0,1 12,13Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$F = [];
var __component__$F = /* @__PURE__ */ normalizeComponent(
  _sfc_main$F,
  _sfc_render$F,
  _sfc_staticRenderFns$F,
  false,
  null,
  null
);
const EyeCircleIcon = __component__$F.exports;
const _sfc_main$E = {
  name: "FolderMultipleImageIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$E = function render40() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon folder-multiple-image-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M7,15L11.5,9L15,13.5L17.5,10.5L21,15M22,4H14L12,2H6A2,2 0 0,0 4,4V16A2,2 0 0,0 6,18H22A2,2 0 0,0 24,16V6A2,2 0 0,0 22,4M2,6H0V11H0V20A2,2 0 0,0 2,22H20V20H2V6Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$E = [];
var __component__$E = /* @__PURE__ */ normalizeComponent(
  _sfc_main$E,
  _sfc_render$E,
  _sfc_staticRenderFns$E,
  false,
  null,
  null
);
const FolderMultipleImage = __component__$E.exports;
const _sfc_main$D = {
  name: "ChevronLeftIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$D = function render41() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon chevron-left-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$D = [];
var __component__$D = /* @__PURE__ */ normalizeComponent(
  _sfc_main$D,
  _sfc_render$D,
  _sfc_staticRenderFns$D,
  false,
  null,
  null
);
const ChevronLeft = __component__$D.exports;
const _sfc_main$C = {
  name: "DotsHorizontalIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$C = function render42() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon dots-horizontal-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M16,12A2,2 0 0,1 18,10A2,2 0 0,1 20,12A2,2 0 0,1 18,14A2,2 0 0,1 16,12M10,12A2,2 0 0,1 12,10A2,2 0 0,1 14,12A2,2 0 0,1 12,14A2,2 0 0,1 10,12M4,12A2,2 0 0,1 6,10A2,2 0 0,1 8,12A2,2 0 0,1 6,14A2,2 0 0,1 4,12Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$C = [];
var __component__$C = /* @__PURE__ */ normalizeComponent(
  _sfc_main$C,
  _sfc_render$C,
  _sfc_staticRenderFns$C,
  false,
  null,
  null
);
const DotsHorizontalIcon = __component__$C.exports;
const _sfc_main$B = {
  name: "ContactDetailsAddNewProp",
  components: {
    IconAdd,
    PropertyTitleIcon,
    Actions: NcActions,
    ActionButton: NcActionButton,
    ChevronLeft,
    DotsHorizontalIcon
  },
  mixins: [
    OrgChartsMixin
  ],
  props: {
    contact: {
      type: Contact,
      default: null
    },
    bus: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      moreActionsOpen: false
    };
  },
  computed: {
    /**
     * Rfc props
     *
     * @return {object}
     */
    properties() {
      return rfcProps.properties;
    },
    /**
     * Rfc props
     *
     * @return string[]
     */
    propertiesOrder() {
      return rfcProps.fieldOrder;
    },
    /**
     * List of properties that the contact already have
     *
     * @return {string[]}
     */
    usedProperties() {
      return this.contact.jCal[1].map((prop) => prop[0]);
    },
    /**
     * List of every primary properties you are allowed to add
     * on this contact
     *
     * @return {object[]}
     */
    availablePrimaryProperties() {
      return Object.keys(this.properties).filter((key) => this.properties[key].primary).map((key) => {
        return {
          id: key,
          name: this.properties[key].readableName,
          icon: this.properties[key].icon
        };
      }).sort((a, b) => this.propertiesOrder.indexOf(a.id) - this.propertiesOrder.indexOf(b.id));
    },
    /**
     * List of every secondary properties you are allowed to add
     * on this contact
     *
     * @return {object[]}
     */
    availableSecondaryProperties() {
      return Object.keys(this.properties).filter((key) => !this.properties[key].primary).map((key) => {
        return {
          id: key,
          name: this.properties[key].readableName,
          icon: this.properties[key].icon
        };
      }).sort((a, b) => a.name.localeCompare(b.name));
    }
  },
  created() {
    this.bus.on("add-prop", this.addProp);
  },
  destroyed() {
    this.bus.off("add-prop", this.addProp);
  },
  methods: {
    /**
     * Add a new prop to the contact
     *
     * @param {string} id the id of the property. e.g fn
     */
    async addProp(id2) {
      if (this.usedProperties.includes(id2) && !this.properties[id2].multiple) {
        this.bus.emit("focus-prop", id2);
        return;
      }
      if (id2 === "x-managersname") {
        const others = this.otherContacts(this.contact);
        if (others.length === 1) {
          await this.contact.vCard.addPropertyWithValue(id2, others[0].key);
          await this.$store.dispatch("updateContact", this.contact);
        } else {
          await this.contact.vCard.addPropertyWithValue(id2, "");
        }
      } else if (this.properties[id2] && this.properties[id2].defaultjCal && this.properties[id2].defaultjCal[this.contact.version]) {
        const defaultjCal = this.properties[id2].defaultjCal[this.contact.version];
        const property = new ICALmodule.Property([id2, ...defaultjCal]);
        await this.contact.vCard.addProperty(property);
      } else {
        const defaultData = this.properties[id2].defaultValue;
        let defaultValue = defaultData ? defaultData.value : "";
        if (Array.isArray(defaultValue)) {
          defaultValue = [...defaultValue];
        }
        const property = await this.contact.vCard.addPropertyWithValue(id2, defaultValue);
        if (defaultData && defaultData.type) {
          property.setParameter("type", defaultData.type);
        }
      }
      this.moreActionsOpen = false;
      this.bus.emit("focus-prop", id2);
    }
  }
};
var _sfc_render$B = function render43() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "property__row" }, [_c("div", { staticClass: "property__label" }), _c("div", { staticClass: "property__value" }, [_c("Actions", { attrs: { "menu-align": "right", "event": "", "type": "secondary", "menu-name": _vm.t("contacts", "Add more info") }, nativeOn: { "click": function($event) {
    $event.preventDefault();
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconAdd", { attrs: { "size": 20 } })];
  }, proxy: true }]) }, [!_vm.moreActionsOpen ? [_vm._l(_vm.availablePrimaryProperties, function(option) {
    return _c("ActionButton", { key: option.id, staticClass: "action--primary", attrs: { "close-after-click": true }, on: { "click": function($event) {
      $event.preventDefault();
      return _vm.addProp(option.id);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("PropertyTitleIcon", { attrs: { "icon": option.icon } })];
    }, proxy: true }], null, true) }, [_vm._v(" " + _vm._s(option.name) + " ")]);
  }), _c("ActionButton", { attrs: { "close-after-click": false }, on: { "click": function($event) {
    _vm.moreActionsOpen = true;
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("DotsHorizontalIcon", { attrs: { "title": _vm.t("contacts", "More fields"), "size": 20 } })];
  }, proxy: true }], null, false, 1229943913) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "More fields")) + " ")])] : _vm._e(), _vm.moreActionsOpen ? [_c("ActionButton", { attrs: { "close-after-click": false }, on: { "click": function($event) {
    _vm.moreActionsOpen = false;
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("ChevronLeft", { attrs: { "title": _vm.t("contacts", "More fields"), "size": 20 } }), _vm._v(" " + _vm._s(_vm.t("contacts", "More fields")) + " ")];
  }, proxy: true }], null, false, 1205835463) }), _vm._l(_vm.availableSecondaryProperties, function(option) {
    return _c("ActionButton", { key: option.id, staticClass: "action--primary", attrs: { "close-after-click": true }, on: { "click": function($event) {
      $event.preventDefault();
      return _vm.addProp(option.id);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("PropertyTitleIcon", { attrs: { "icon": option.icon } })];
    }, proxy: true }], null, true) }, [_vm._v(" " + _vm._s(option.name) + " ")]);
  })] : _vm._e()], 2)], 1), _c("div", { staticClass: "property__actions" })]);
};
var _sfc_staticRenderFns$B = [];
var __component__$B = /* @__PURE__ */ normalizeComponent(
  _sfc_main$B,
  _sfc_render$B,
  _sfc_staticRenderFns$B,
  false,
  null,
  null
);
const AddNewProp = __component__$B.exports;
const _sfc_main$A = {
  name: "CloudDownloadIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$A = function render44() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon cloud-download-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M6.5 20Q4.22 20 2.61 18.43 1 16.85 1 14.58 1 12.63 2.17 11.1 3.35 9.57 5.25 9.15 5.83 7.13 7.39 5.75 8.95 4.38 11 4.08V12.15L9.4 10.6L8 12L12 16L16 12L14.6 10.6L13 12.15V4.08Q15.58 4.43 17.29 6.39 19 8.35 19 11 20.73 11.2 21.86 12.5 23 13.78 23 15.5 23 17.38 21.69 18.69 20.38 20 18.5 20Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$A = [];
var __component__$A = /* @__PURE__ */ normalizeComponent(
  _sfc_main$A,
  _sfc_render$A,
  _sfc_staticRenderFns$A,
  false,
  null,
  null
);
const IconCloudDownload = __component__$A.exports;
const _sfc_main$z = {
  name: "UploadIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$z = function render45() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon upload-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M9,16V10H5L12,3L19,10H15V16H9M5,20V18H19V20H5Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$z = [];
var __component__$z = /* @__PURE__ */ normalizeComponent(
  _sfc_main$z,
  _sfc_render$z,
  _sfc_staticRenderFns$z,
  false,
  null,
  null
);
const IconUpload = __component__$z.exports;
const _sfc_main$y = {
  name: "FolderIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$y = function render46() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon folder-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M10,4H4C2.89,4 2,4.89 2,6V18A2,2 0 0,0 4,20H20A2,2 0 0,0 22,18V8C22,6.89 21.1,6 20,6H12L10,4Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$y = [];
var __component__$y = /* @__PURE__ */ normalizeComponent(
  _sfc_main$y,
  _sfc_render$y,
  _sfc_staticRenderFns$y,
  false,
  null,
  null
);
const IconFolder = __component__$y.exports;
const _sfc_main$x = {
  name: "ImageIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$x = function render47() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon image-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M8.5,13.5L11,16.5L14.5,12L19,18H5M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$x = [];
var __component__$x = /* @__PURE__ */ normalizeComponent(
  _sfc_main$x,
  _sfc_render$x,
  _sfc_staticRenderFns$x,
  false,
  null,
  null
);
const IconImage = __component__$x.exports;
var VueCropper = {};
var cropper = { exports: {} };
/*!
 * Cropper.js v1.5.13
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2022-11-20T05:30:46.114Z
 */
(function(module2, exports) {
  (function(global, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
    }
    function _unsupportedIterableToArray(o2, minLen) {
      if (!o2) return;
      if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
      var n2 = Object.prototype.toString.call(o2).slice(8, -1);
      if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
      if (n2 === "Map" || n2 === "Set") return Array.from(o2);
      if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var IS_BROWSER = typeof window !== "undefined" && typeof window.document !== "undefined";
    var WINDOW = IS_BROWSER ? window : {};
    var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? "ontouchstart" in WINDOW.document.documentElement : false;
    var HAS_POINTER_EVENT = IS_BROWSER ? "PointerEvent" in WINDOW : false;
    var NAMESPACE = "cropper";
    var ACTION_ALL = "all";
    var ACTION_CROP = "crop";
    var ACTION_MOVE = "move";
    var ACTION_ZOOM = "zoom";
    var ACTION_EAST = "e";
    var ACTION_WEST = "w";
    var ACTION_SOUTH = "s";
    var ACTION_NORTH = "n";
    var ACTION_NORTH_EAST = "ne";
    var ACTION_NORTH_WEST = "nw";
    var ACTION_SOUTH_EAST = "se";
    var ACTION_SOUTH_WEST = "sw";
    var CLASS_CROP = "".concat(NAMESPACE, "-crop");
    var CLASS_DISABLED = "".concat(NAMESPACE, "-disabled");
    var CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden");
    var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
    var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
    var CLASS_MODAL = "".concat(NAMESPACE, "-modal");
    var CLASS_MOVE = "".concat(NAMESPACE, "-move");
    var DATA_ACTION = "".concat(NAMESPACE, "Action");
    var DATA_PREVIEW = "".concat(NAMESPACE, "Preview");
    var DRAG_MODE_CROP = "crop";
    var DRAG_MODE_MOVE = "move";
    var DRAG_MODE_NONE = "none";
    var EVENT_CROP = "crop";
    var EVENT_CROP_END = "cropend";
    var EVENT_CROP_MOVE = "cropmove";
    var EVENT_CROP_START = "cropstart";
    var EVENT_DBLCLICK = "dblclick";
    var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? "touchstart" : "mousedown";
    var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? "touchmove" : "mousemove";
    var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? "touchend touchcancel" : "mouseup";
    var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? "pointerdown" : EVENT_TOUCH_START;
    var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? "pointermove" : EVENT_TOUCH_MOVE;
    var EVENT_POINTER_UP = HAS_POINTER_EVENT ? "pointerup pointercancel" : EVENT_TOUCH_END;
    var EVENT_READY = "ready";
    var EVENT_RESIZE = "resize";
    var EVENT_WHEEL = "wheel";
    var EVENT_ZOOM = "zoom";
    var MIME_TYPE_JPEG = "image/jpeg";
    var REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/;
    var REGEXP_DATA_URL = /^data:/;
    var REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/;
    var REGEXP_TAG_NAME = /^img|canvas$/i;
    var MIN_CONTAINER_WIDTH = 200;
    var MIN_CONTAINER_HEIGHT = 100;
    var DEFAULTS = {
      // Define the view mode of the cropper
      viewMode: 0,
      // 0, 1, 2, 3
      // Define the dragging mode of the cropper
      dragMode: DRAG_MODE_CROP,
      // 'crop', 'move' or 'none'
      // Define the initial aspect ratio of the crop box
      initialAspectRatio: NaN,
      // Define the aspect ratio of the crop box
      aspectRatio: NaN,
      // An object with the previous cropping result data
      data: null,
      // A selector for adding extra containers to preview
      preview: "",
      // Re-render the cropper when resize the window
      responsive: true,
      // Restore the cropped area after resize the window
      restore: true,
      // Check if the current image is a cross-origin image
      checkCrossOrigin: true,
      // Check the current image's Exif Orientation information
      checkOrientation: true,
      // Show the black modal
      modal: true,
      // Show the dashed lines for guiding
      guides: true,
      // Show the center indicator for guiding
      center: true,
      // Show the white modal to highlight the crop box
      highlight: true,
      // Show the grid background
      background: true,
      // Enable to crop the image automatically when initialize
      autoCrop: true,
      // Define the percentage of automatic cropping area when initializes
      autoCropArea: 0.8,
      // Enable to move the image
      movable: true,
      // Enable to rotate the image
      rotatable: true,
      // Enable to scale the image
      scalable: true,
      // Enable to zoom the image
      zoomable: true,
      // Enable to zoom the image by dragging touch
      zoomOnTouch: true,
      // Enable to zoom the image by wheeling mouse
      zoomOnWheel: true,
      // Define zoom ratio when zoom the image by wheeling mouse
      wheelZoomRatio: 0.1,
      // Enable to move the crop box
      cropBoxMovable: true,
      // Enable to resize the crop box
      cropBoxResizable: true,
      // Toggle drag mode between "crop" and "move" when click twice on the cropper
      toggleDragModeOnDblclick: true,
      // Size limitation
      minCanvasWidth: 0,
      minCanvasHeight: 0,
      minCropBoxWidth: 0,
      minCropBoxHeight: 0,
      minContainerWidth: MIN_CONTAINER_WIDTH,
      minContainerHeight: MIN_CONTAINER_HEIGHT,
      // Shortcuts of events
      ready: null,
      cropstart: null,
      cropmove: null,
      cropend: null,
      crop: null,
      zoom: null
    };
    var TEMPLATE = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>';
    var isNaN2 = Number.isNaN || WINDOW.isNaN;
    function isNumber(value) {
      return typeof value === "number" && !isNaN2(value);
    }
    var isPositiveNumber = function isPositiveNumber2(value) {
      return value > 0 && value < Infinity;
    };
    function isUndefined(value) {
      return typeof value === "undefined";
    }
    function isObject(value) {
      return _typeof(value) === "object" && value !== null;
    }
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function isPlainObject(value) {
      if (!isObject(value)) {
        return false;
      }
      try {
        var _constructor = value.constructor;
        var prototype = _constructor.prototype;
        return _constructor && prototype && hasOwnProperty2.call(prototype, "isPrototypeOf");
      } catch (error) {
        return false;
      }
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    var slice2 = Array.prototype.slice;
    function toArray(value) {
      return Array.from ? Array.from(value) : slice2.call(value);
    }
    function forEach(data, callback) {
      if (data && isFunction(callback)) {
        if (Array.isArray(data) || isNumber(data.length)) {
          toArray(data).forEach(function(value, key) {
            callback.call(data, value, key, data);
          });
        } else if (isObject(data)) {
          Object.keys(data).forEach(function(key) {
            callback.call(data, data[key], key, data);
          });
        }
      }
      return data;
    }
    var assign = Object.assign || function assign2(target) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (isObject(target) && args.length > 0) {
        args.forEach(function(arg) {
          if (isObject(arg)) {
            Object.keys(arg).forEach(function(key) {
              target[key] = arg[key];
            });
          }
        });
      }
      return target;
    };
    var REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/;
    function normalizeDecimalNumber(value) {
      var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11;
      return REGEXP_DECIMALS.test(value) ? Math.round(value * times) / times : value;
    }
    var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/;
    function setStyle(element, styles) {
      var style = element.style;
      forEach(styles, function(value, property) {
        if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
          value = "".concat(value, "px");
        }
        style[property] = value;
      });
    }
    function hasClass(element, value) {
      return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
    }
    function addClass(element, value) {
      if (!value) {
        return;
      }
      if (isNumber(element.length)) {
        forEach(element, function(elem) {
          addClass(elem, value);
        });
        return;
      }
      if (element.classList) {
        element.classList.add(value);
        return;
      }
      var className = element.className.trim();
      if (!className) {
        element.className = value;
      } else if (className.indexOf(value) < 0) {
        element.className = "".concat(className, " ").concat(value);
      }
    }
    function removeClass(element, value) {
      if (!value) {
        return;
      }
      if (isNumber(element.length)) {
        forEach(element, function(elem) {
          removeClass(elem, value);
        });
        return;
      }
      if (element.classList) {
        element.classList.remove(value);
        return;
      }
      if (element.className.indexOf(value) >= 0) {
        element.className = element.className.replace(value, "");
      }
    }
    function toggleClass(element, value, added) {
      if (!value) {
        return;
      }
      if (isNumber(element.length)) {
        forEach(element, function(elem) {
          toggleClass(elem, value, added);
        });
        return;
      }
      if (added) {
        addClass(element, value);
      } else {
        removeClass(element, value);
      }
    }
    var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g;
    function toParamCase(value) {
      return value.replace(REGEXP_CAMEL_CASE, "$1-$2").toLowerCase();
    }
    function getData2(element, name) {
      if (isObject(element[name])) {
        return element[name];
      }
      if (element.dataset) {
        return element.dataset[name];
      }
      return element.getAttribute("data-".concat(toParamCase(name)));
    }
    function setData2(element, name, data) {
      if (isObject(data)) {
        element[name] = data;
      } else if (element.dataset) {
        element.dataset[name] = data;
      } else {
        element.setAttribute("data-".concat(toParamCase(name)), data);
      }
    }
    function removeData(element, name) {
      if (isObject(element[name])) {
        try {
          delete element[name];
        } catch (error) {
          element[name] = void 0;
        }
      } else if (element.dataset) {
        try {
          delete element.dataset[name];
        } catch (error) {
          element.dataset[name] = void 0;
        }
      } else {
        element.removeAttribute("data-".concat(toParamCase(name)));
      }
    }
    var REGEXP_SPACES = /\s\s*/;
    var onceSupported = function() {
      var supported = false;
      if (IS_BROWSER) {
        var once = false;
        var listener = function listener2() {
        };
        var options = Object.defineProperty({}, "once", {
          get: function get2() {
            supported = true;
            return once;
          },
          /**
           * This setter can fix a `TypeError` in strict mode
           * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
           * @param {boolean} value - The value to set
           */
          set: function set2(value) {
            once = value;
          }
        });
        WINDOW.addEventListener("test", listener, options);
        WINDOW.removeEventListener("test", listener, options);
      }
      return supported;
    }();
    function removeListener(element, type, listener) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var handler = listener;
      type.trim().split(REGEXP_SPACES).forEach(function(event) {
        if (!onceSupported) {
          var listeners = element.listeners;
          if (listeners && listeners[event] && listeners[event][listener]) {
            handler = listeners[event][listener];
            delete listeners[event][listener];
            if (Object.keys(listeners[event]).length === 0) {
              delete listeners[event];
            }
            if (Object.keys(listeners).length === 0) {
              delete element.listeners;
            }
          }
        }
        element.removeEventListener(event, handler, options);
      });
    }
    function addListener(element, type, listener) {
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var _handler = listener;
      type.trim().split(REGEXP_SPACES).forEach(function(event) {
        if (options.once && !onceSupported) {
          var _element$listeners = element.listeners, listeners = _element$listeners === void 0 ? {} : _element$listeners;
          _handler = function handler() {
            delete listeners[event][listener];
            element.removeEventListener(event, _handler, options);
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }
            listener.apply(element, args);
          };
          if (!listeners[event]) {
            listeners[event] = {};
          }
          if (listeners[event][listener]) {
            element.removeEventListener(event, listeners[event][listener], options);
          }
          listeners[event][listener] = _handler;
          element.listeners = listeners;
        }
        element.addEventListener(event, _handler, options);
      });
    }
    function dispatchEvent2(element, type, data) {
      var event;
      if (isFunction(Event) && isFunction(CustomEvent)) {
        event = new CustomEvent(type, {
          detail: data,
          bubbles: true,
          cancelable: true
        });
      } else {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(type, true, true, data);
      }
      return element.dispatchEvent(event);
    }
    function getOffset(element) {
      var box = element.getBoundingClientRect();
      return {
        left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
        top: box.top + (window.pageYOffset - document.documentElement.clientTop)
      };
    }
    var location2 = WINDOW.location;
    var REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i;
    function isCrossOriginURL(url) {
      var parts = url.match(REGEXP_ORIGINS);
      return parts !== null && (parts[1] !== location2.protocol || parts[2] !== location2.hostname || parts[3] !== location2.port);
    }
    function addTimestamp(url) {
      var timestamp = "timestamp=".concat((/* @__PURE__ */ new Date()).getTime());
      return url + (url.indexOf("?") === -1 ? "?" : "&") + timestamp;
    }
    function getTransforms(_ref) {
      var rotate2 = _ref.rotate, scaleX2 = _ref.scaleX, scaleY2 = _ref.scaleY, translateX = _ref.translateX, translateY = _ref.translateY;
      var values = [];
      if (isNumber(translateX) && translateX !== 0) {
        values.push("translateX(".concat(translateX, "px)"));
      }
      if (isNumber(translateY) && translateY !== 0) {
        values.push("translateY(".concat(translateY, "px)"));
      }
      if (isNumber(rotate2) && rotate2 !== 0) {
        values.push("rotate(".concat(rotate2, "deg)"));
      }
      if (isNumber(scaleX2) && scaleX2 !== 1) {
        values.push("scaleX(".concat(scaleX2, ")"));
      }
      if (isNumber(scaleY2) && scaleY2 !== 1) {
        values.push("scaleY(".concat(scaleY2, ")"));
      }
      var transform = values.length ? values.join(" ") : "none";
      return {
        WebkitTransform: transform,
        msTransform: transform,
        transform
      };
    }
    function getMaxZoomRatio(pointers) {
      var pointers2 = _objectSpread2({}, pointers);
      var maxRatio = 0;
      forEach(pointers, function(pointer2, pointerId) {
        delete pointers2[pointerId];
        forEach(pointers2, function(pointer22) {
          var x1 = Math.abs(pointer2.startX - pointer22.startX);
          var y1 = Math.abs(pointer2.startY - pointer22.startY);
          var x2 = Math.abs(pointer2.endX - pointer22.endX);
          var y2 = Math.abs(pointer2.endY - pointer22.endY);
          var z1 = Math.sqrt(x1 * x1 + y1 * y1);
          var z2 = Math.sqrt(x2 * x2 + y2 * y2);
          var ratio = (z2 - z1) / z1;
          if (Math.abs(ratio) > Math.abs(maxRatio)) {
            maxRatio = ratio;
          }
        });
      });
      return maxRatio;
    }
    function getPointer(_ref2, endOnly) {
      var pageX = _ref2.pageX, pageY = _ref2.pageY;
      var end = {
        endX: pageX,
        endY: pageY
      };
      return endOnly ? end : _objectSpread2({
        startX: pageX,
        startY: pageY
      }, end);
    }
    function getPointersCenter(pointers) {
      var pageX = 0;
      var pageY = 0;
      var count2 = 0;
      forEach(pointers, function(_ref3) {
        var startX = _ref3.startX, startY = _ref3.startY;
        pageX += startX;
        pageY += startY;
        count2 += 1;
      });
      pageX /= count2;
      pageY /= count2;
      return {
        pageX,
        pageY
      };
    }
    function getAdjustedSizes(_ref4) {
      var aspectRatio = _ref4.aspectRatio, height = _ref4.height, width = _ref4.width;
      var type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain";
      var isValidWidth = isPositiveNumber(width);
      var isValidHeight = isPositiveNumber(height);
      if (isValidWidth && isValidHeight) {
        var adjustedWidth = height * aspectRatio;
        if (type === "contain" && adjustedWidth > width || type === "cover" && adjustedWidth < width) {
          height = width / aspectRatio;
        } else {
          width = height * aspectRatio;
        }
      } else if (isValidWidth) {
        height = width / aspectRatio;
      } else if (isValidHeight) {
        width = height * aspectRatio;
      }
      return {
        width,
        height
      };
    }
    function getRotatedSizes(_ref5) {
      var width = _ref5.width, height = _ref5.height, degree = _ref5.degree;
      degree = Math.abs(degree) % 180;
      if (degree === 90) {
        return {
          width: height,
          height: width
        };
      }
      var arc = degree % 90 * Math.PI / 180;
      var sinArc = Math.sin(arc);
      var cosArc = Math.cos(arc);
      var newWidth = width * cosArc + height * sinArc;
      var newHeight = width * sinArc + height * cosArc;
      return degree > 90 ? {
        width: newHeight,
        height: newWidth
      } : {
        width: newWidth,
        height: newHeight
      };
    }
    function getSourceCanvas(image, _ref6, _ref7, _ref8) {
      var imageAspectRatio = _ref6.aspectRatio, imageNaturalWidth = _ref6.naturalWidth, imageNaturalHeight = _ref6.naturalHeight, _ref6$rotate = _ref6.rotate, rotate2 = _ref6$rotate === void 0 ? 0 : _ref6$rotate, _ref6$scaleX = _ref6.scaleX, scaleX2 = _ref6$scaleX === void 0 ? 1 : _ref6$scaleX, _ref6$scaleY = _ref6.scaleY, scaleY2 = _ref6$scaleY === void 0 ? 1 : _ref6$scaleY;
      var aspectRatio = _ref7.aspectRatio, naturalWidth = _ref7.naturalWidth, naturalHeight = _ref7.naturalHeight;
      var _ref8$fillColor = _ref8.fillColor, fillColor = _ref8$fillColor === void 0 ? "transparent" : _ref8$fillColor, _ref8$imageSmoothingE = _ref8.imageSmoothingEnabled, imageSmoothingEnabled = _ref8$imageSmoothingE === void 0 ? true : _ref8$imageSmoothingE, _ref8$imageSmoothingQ = _ref8.imageSmoothingQuality, imageSmoothingQuality = _ref8$imageSmoothingQ === void 0 ? "low" : _ref8$imageSmoothingQ, _ref8$maxWidth = _ref8.maxWidth, maxWidth = _ref8$maxWidth === void 0 ? Infinity : _ref8$maxWidth, _ref8$maxHeight = _ref8.maxHeight, maxHeight = _ref8$maxHeight === void 0 ? Infinity : _ref8$maxHeight, _ref8$minWidth = _ref8.minWidth, minWidth = _ref8$minWidth === void 0 ? 0 : _ref8$minWidth, _ref8$minHeight = _ref8.minHeight, minHeight = _ref8$minHeight === void 0 ? 0 : _ref8$minHeight;
      var canvas = document.createElement("canvas");
      var context = canvas.getContext("2d");
      var maxSizes = getAdjustedSizes({
        aspectRatio,
        width: maxWidth,
        height: maxHeight
      });
      var minSizes = getAdjustedSizes({
        aspectRatio,
        width: minWidth,
        height: minHeight
      }, "cover");
      var width = Math.min(maxSizes.width, Math.max(minSizes.width, naturalWidth));
      var height = Math.min(maxSizes.height, Math.max(minSizes.height, naturalHeight));
      var destMaxSizes = getAdjustedSizes({
        aspectRatio: imageAspectRatio,
        width: maxWidth,
        height: maxHeight
      });
      var destMinSizes = getAdjustedSizes({
        aspectRatio: imageAspectRatio,
        width: minWidth,
        height: minHeight
      }, "cover");
      var destWidth = Math.min(destMaxSizes.width, Math.max(destMinSizes.width, imageNaturalWidth));
      var destHeight = Math.min(destMaxSizes.height, Math.max(destMinSizes.height, imageNaturalHeight));
      var params = [-destWidth / 2, -destHeight / 2, destWidth, destHeight];
      canvas.width = normalizeDecimalNumber(width);
      canvas.height = normalizeDecimalNumber(height);
      context.fillStyle = fillColor;
      context.fillRect(0, 0, width, height);
      context.save();
      context.translate(width / 2, height / 2);
      context.rotate(rotate2 * Math.PI / 180);
      context.scale(scaleX2, scaleY2);
      context.imageSmoothingEnabled = imageSmoothingEnabled;
      context.imageSmoothingQuality = imageSmoothingQuality;
      context.drawImage.apply(context, [image].concat(_toConsumableArray(params.map(function(param) {
        return Math.floor(normalizeDecimalNumber(param));
      }))));
      context.restore();
      return canvas;
    }
    var fromCharCode = String.fromCharCode;
    function getStringFromCharCode(dataView, start2, length) {
      var str = "";
      length += start2;
      for (var i = start2; i < length; i += 1) {
        str += fromCharCode(dataView.getUint8(i));
      }
      return str;
    }
    var REGEXP_DATA_URL_HEAD = /^data:.*,/;
    function dataURLToArrayBuffer(dataURL) {
      var base64 = dataURL.replace(REGEXP_DATA_URL_HEAD, "");
      var binary = atob(base64);
      var arrayBuffer = new ArrayBuffer(binary.length);
      var uint8 = new Uint8Array(arrayBuffer);
      forEach(uint8, function(value, i) {
        uint8[i] = binary.charCodeAt(i);
      });
      return arrayBuffer;
    }
    function arrayBufferToDataURL(arrayBuffer, mimeType) {
      var chunks = [];
      var chunkSize = 8192;
      var uint8 = new Uint8Array(arrayBuffer);
      while (uint8.length > 0) {
        chunks.push(fromCharCode.apply(null, toArray(uint8.subarray(0, chunkSize))));
        uint8 = uint8.subarray(chunkSize);
      }
      return "data:".concat(mimeType, ";base64,").concat(btoa(chunks.join("")));
    }
    function resetAndGetOrientation(arrayBuffer) {
      var dataView = new DataView(arrayBuffer);
      var orientation;
      try {
        var littleEndian;
        var app1Start;
        var ifdStart;
        if (dataView.getUint8(0) === 255 && dataView.getUint8(1) === 216) {
          var length = dataView.byteLength;
          var offset = 2;
          while (offset + 1 < length) {
            if (dataView.getUint8(offset) === 255 && dataView.getUint8(offset + 1) === 225) {
              app1Start = offset;
              break;
            }
            offset += 1;
          }
        }
        if (app1Start) {
          var exifIDCode = app1Start + 4;
          var tiffOffset = app1Start + 10;
          if (getStringFromCharCode(dataView, exifIDCode, 4) === "Exif") {
            var endianness = dataView.getUint16(tiffOffset);
            littleEndian = endianness === 18761;
            if (littleEndian || endianness === 19789) {
              if (dataView.getUint16(tiffOffset + 2, littleEndian) === 42) {
                var firstIFDOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
                if (firstIFDOffset >= 8) {
                  ifdStart = tiffOffset + firstIFDOffset;
                }
              }
            }
          }
        }
        if (ifdStart) {
          var _length = dataView.getUint16(ifdStart, littleEndian);
          var _offset;
          var i;
          for (i = 0; i < _length; i += 1) {
            _offset = ifdStart + i * 12 + 2;
            if (dataView.getUint16(_offset, littleEndian) === 274) {
              _offset += 8;
              orientation = dataView.getUint16(_offset, littleEndian);
              dataView.setUint16(_offset, 1, littleEndian);
              break;
            }
          }
        }
      } catch (error) {
        orientation = 1;
      }
      return orientation;
    }
    function parseOrientation(orientation) {
      var rotate2 = 0;
      var scaleX2 = 1;
      var scaleY2 = 1;
      switch (orientation) {
        case 2:
          scaleX2 = -1;
          break;
        case 3:
          rotate2 = -180;
          break;
        case 4:
          scaleY2 = -1;
          break;
        case 5:
          rotate2 = 90;
          scaleY2 = -1;
          break;
        case 6:
          rotate2 = 90;
          break;
        case 7:
          rotate2 = 90;
          scaleX2 = -1;
          break;
        case 8:
          rotate2 = -90;
          break;
      }
      return {
        rotate: rotate2,
        scaleX: scaleX2,
        scaleY: scaleY2
      };
    }
    var render82 = {
      render: function render83() {
        this.initContainer();
        this.initCanvas();
        this.initCropBox();
        this.renderCanvas();
        if (this.cropped) {
          this.renderCropBox();
        }
      },
      initContainer: function initContainer() {
        var element = this.element, options = this.options, container = this.container, cropper2 = this.cropper;
        var minWidth = Number(options.minContainerWidth);
        var minHeight = Number(options.minContainerHeight);
        addClass(cropper2, CLASS_HIDDEN);
        removeClass(element, CLASS_HIDDEN);
        var containerData = {
          width: Math.max(container.offsetWidth, minWidth >= 0 ? minWidth : MIN_CONTAINER_WIDTH),
          height: Math.max(container.offsetHeight, minHeight >= 0 ? minHeight : MIN_CONTAINER_HEIGHT)
        };
        this.containerData = containerData;
        setStyle(cropper2, {
          width: containerData.width,
          height: containerData.height
        });
        addClass(element, CLASS_HIDDEN);
        removeClass(cropper2, CLASS_HIDDEN);
      },
      // Canvas (image wrapper)
      initCanvas: function initCanvas() {
        var containerData = this.containerData, imageData = this.imageData;
        var viewMode = this.options.viewMode;
        var rotated = Math.abs(imageData.rotate) % 180 === 90;
        var naturalWidth = rotated ? imageData.naturalHeight : imageData.naturalWidth;
        var naturalHeight = rotated ? imageData.naturalWidth : imageData.naturalHeight;
        var aspectRatio = naturalWidth / naturalHeight;
        var canvasWidth = containerData.width;
        var canvasHeight = containerData.height;
        if (containerData.height * aspectRatio > containerData.width) {
          if (viewMode === 3) {
            canvasWidth = containerData.height * aspectRatio;
          } else {
            canvasHeight = containerData.width / aspectRatio;
          }
        } else if (viewMode === 3) {
          canvasHeight = containerData.width / aspectRatio;
        } else {
          canvasWidth = containerData.height * aspectRatio;
        }
        var canvasData = {
          aspectRatio,
          naturalWidth,
          naturalHeight,
          width: canvasWidth,
          height: canvasHeight
        };
        this.canvasData = canvasData;
        this.limited = viewMode === 1 || viewMode === 2;
        this.limitCanvas(true, true);
        canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
        canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
        canvasData.left = (containerData.width - canvasData.width) / 2;
        canvasData.top = (containerData.height - canvasData.height) / 2;
        canvasData.oldLeft = canvasData.left;
        canvasData.oldTop = canvasData.top;
        this.initialCanvasData = assign({}, canvasData);
      },
      limitCanvas: function limitCanvas(sizeLimited, positionLimited) {
        var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
        var viewMode = options.viewMode;
        var aspectRatio = canvasData.aspectRatio;
        var cropped = this.cropped && cropBoxData;
        if (sizeLimited) {
          var minCanvasWidth = Number(options.minCanvasWidth) || 0;
          var minCanvasHeight = Number(options.minCanvasHeight) || 0;
          if (viewMode > 1) {
            minCanvasWidth = Math.max(minCanvasWidth, containerData.width);
            minCanvasHeight = Math.max(minCanvasHeight, containerData.height);
            if (viewMode === 3) {
              if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                minCanvasWidth = minCanvasHeight * aspectRatio;
              } else {
                minCanvasHeight = minCanvasWidth / aspectRatio;
              }
            }
          } else if (viewMode > 0) {
            if (minCanvasWidth) {
              minCanvasWidth = Math.max(minCanvasWidth, cropped ? cropBoxData.width : 0);
            } else if (minCanvasHeight) {
              minCanvasHeight = Math.max(minCanvasHeight, cropped ? cropBoxData.height : 0);
            } else if (cropped) {
              minCanvasWidth = cropBoxData.width;
              minCanvasHeight = cropBoxData.height;
              if (minCanvasHeight * aspectRatio > minCanvasWidth) {
                minCanvasWidth = minCanvasHeight * aspectRatio;
              } else {
                minCanvasHeight = minCanvasWidth / aspectRatio;
              }
            }
          }
          var _getAdjustedSizes = getAdjustedSizes({
            aspectRatio,
            width: minCanvasWidth,
            height: minCanvasHeight
          });
          minCanvasWidth = _getAdjustedSizes.width;
          minCanvasHeight = _getAdjustedSizes.height;
          canvasData.minWidth = minCanvasWidth;
          canvasData.minHeight = minCanvasHeight;
          canvasData.maxWidth = Infinity;
          canvasData.maxHeight = Infinity;
        }
        if (positionLimited) {
          if (viewMode > (cropped ? 0 : 1)) {
            var newCanvasLeft = containerData.width - canvasData.width;
            var newCanvasTop = containerData.height - canvasData.height;
            canvasData.minLeft = Math.min(0, newCanvasLeft);
            canvasData.minTop = Math.min(0, newCanvasTop);
            canvasData.maxLeft = Math.max(0, newCanvasLeft);
            canvasData.maxTop = Math.max(0, newCanvasTop);
            if (cropped && this.limited) {
              canvasData.minLeft = Math.min(cropBoxData.left, cropBoxData.left + (cropBoxData.width - canvasData.width));
              canvasData.minTop = Math.min(cropBoxData.top, cropBoxData.top + (cropBoxData.height - canvasData.height));
              canvasData.maxLeft = cropBoxData.left;
              canvasData.maxTop = cropBoxData.top;
              if (viewMode === 2) {
                if (canvasData.width >= containerData.width) {
                  canvasData.minLeft = Math.min(0, newCanvasLeft);
                  canvasData.maxLeft = Math.max(0, newCanvasLeft);
                }
                if (canvasData.height >= containerData.height) {
                  canvasData.minTop = Math.min(0, newCanvasTop);
                  canvasData.maxTop = Math.max(0, newCanvasTop);
                }
              }
            }
          } else {
            canvasData.minLeft = -canvasData.width;
            canvasData.minTop = -canvasData.height;
            canvasData.maxLeft = containerData.width;
            canvasData.maxTop = containerData.height;
          }
        }
      },
      renderCanvas: function renderCanvas(changed, transformed) {
        var canvasData = this.canvasData, imageData = this.imageData;
        if (transformed) {
          var _getRotatedSizes = getRotatedSizes({
            width: imageData.naturalWidth * Math.abs(imageData.scaleX || 1),
            height: imageData.naturalHeight * Math.abs(imageData.scaleY || 1),
            degree: imageData.rotate || 0
          }), naturalWidth = _getRotatedSizes.width, naturalHeight = _getRotatedSizes.height;
          var width = canvasData.width * (naturalWidth / canvasData.naturalWidth);
          var height = canvasData.height * (naturalHeight / canvasData.naturalHeight);
          canvasData.left -= (width - canvasData.width) / 2;
          canvasData.top -= (height - canvasData.height) / 2;
          canvasData.width = width;
          canvasData.height = height;
          canvasData.aspectRatio = naturalWidth / naturalHeight;
          canvasData.naturalWidth = naturalWidth;
          canvasData.naturalHeight = naturalHeight;
          this.limitCanvas(true, false);
        }
        if (canvasData.width > canvasData.maxWidth || canvasData.width < canvasData.minWidth) {
          canvasData.left = canvasData.oldLeft;
        }
        if (canvasData.height > canvasData.maxHeight || canvasData.height < canvasData.minHeight) {
          canvasData.top = canvasData.oldTop;
        }
        canvasData.width = Math.min(Math.max(canvasData.width, canvasData.minWidth), canvasData.maxWidth);
        canvasData.height = Math.min(Math.max(canvasData.height, canvasData.minHeight), canvasData.maxHeight);
        this.limitCanvas(false, true);
        canvasData.left = Math.min(Math.max(canvasData.left, canvasData.minLeft), canvasData.maxLeft);
        canvasData.top = Math.min(Math.max(canvasData.top, canvasData.minTop), canvasData.maxTop);
        canvasData.oldLeft = canvasData.left;
        canvasData.oldTop = canvasData.top;
        setStyle(this.canvas, assign({
          width: canvasData.width,
          height: canvasData.height
        }, getTransforms({
          translateX: canvasData.left,
          translateY: canvasData.top
        })));
        this.renderImage(changed);
        if (this.cropped && this.limited) {
          this.limitCropBox(true, true);
        }
      },
      renderImage: function renderImage(changed) {
        var canvasData = this.canvasData, imageData = this.imageData;
        var width = imageData.naturalWidth * (canvasData.width / canvasData.naturalWidth);
        var height = imageData.naturalHeight * (canvasData.height / canvasData.naturalHeight);
        assign(imageData, {
          width,
          height,
          left: (canvasData.width - width) / 2,
          top: (canvasData.height - height) / 2
        });
        setStyle(this.image, assign({
          width: imageData.width,
          height: imageData.height
        }, getTransforms(assign({
          translateX: imageData.left,
          translateY: imageData.top
        }, imageData))));
        if (changed) {
          this.output();
        }
      },
      initCropBox: function initCropBox() {
        var options = this.options, canvasData = this.canvasData;
        var aspectRatio = options.aspectRatio || options.initialAspectRatio;
        var autoCropArea = Number(options.autoCropArea) || 0.8;
        var cropBoxData = {
          width: canvasData.width,
          height: canvasData.height
        };
        if (aspectRatio) {
          if (canvasData.height * aspectRatio > canvasData.width) {
            cropBoxData.height = cropBoxData.width / aspectRatio;
          } else {
            cropBoxData.width = cropBoxData.height * aspectRatio;
          }
        }
        this.cropBoxData = cropBoxData;
        this.limitCropBox(true, true);
        cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
        cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
        cropBoxData.width = Math.max(cropBoxData.minWidth, cropBoxData.width * autoCropArea);
        cropBoxData.height = Math.max(cropBoxData.minHeight, cropBoxData.height * autoCropArea);
        cropBoxData.left = canvasData.left + (canvasData.width - cropBoxData.width) / 2;
        cropBoxData.top = canvasData.top + (canvasData.height - cropBoxData.height) / 2;
        cropBoxData.oldLeft = cropBoxData.left;
        cropBoxData.oldTop = cropBoxData.top;
        this.initialCropBoxData = assign({}, cropBoxData);
      },
      limitCropBox: function limitCropBox(sizeLimited, positionLimited) {
        var options = this.options, containerData = this.containerData, canvasData = this.canvasData, cropBoxData = this.cropBoxData, limited = this.limited;
        var aspectRatio = options.aspectRatio;
        if (sizeLimited) {
          var minCropBoxWidth = Number(options.minCropBoxWidth) || 0;
          var minCropBoxHeight = Number(options.minCropBoxHeight) || 0;
          var maxCropBoxWidth = limited ? Math.min(containerData.width, canvasData.width, canvasData.width + canvasData.left, containerData.width - canvasData.left) : containerData.width;
          var maxCropBoxHeight = limited ? Math.min(containerData.height, canvasData.height, canvasData.height + canvasData.top, containerData.height - canvasData.top) : containerData.height;
          minCropBoxWidth = Math.min(minCropBoxWidth, containerData.width);
          minCropBoxHeight = Math.min(minCropBoxHeight, containerData.height);
          if (aspectRatio) {
            if (minCropBoxWidth && minCropBoxHeight) {
              if (minCropBoxHeight * aspectRatio > minCropBoxWidth) {
                minCropBoxHeight = minCropBoxWidth / aspectRatio;
              } else {
                minCropBoxWidth = minCropBoxHeight * aspectRatio;
              }
            } else if (minCropBoxWidth) {
              minCropBoxHeight = minCropBoxWidth / aspectRatio;
            } else if (minCropBoxHeight) {
              minCropBoxWidth = minCropBoxHeight * aspectRatio;
            }
            if (maxCropBoxHeight * aspectRatio > maxCropBoxWidth) {
              maxCropBoxHeight = maxCropBoxWidth / aspectRatio;
            } else {
              maxCropBoxWidth = maxCropBoxHeight * aspectRatio;
            }
          }
          cropBoxData.minWidth = Math.min(minCropBoxWidth, maxCropBoxWidth);
          cropBoxData.minHeight = Math.min(minCropBoxHeight, maxCropBoxHeight);
          cropBoxData.maxWidth = maxCropBoxWidth;
          cropBoxData.maxHeight = maxCropBoxHeight;
        }
        if (positionLimited) {
          if (limited) {
            cropBoxData.minLeft = Math.max(0, canvasData.left);
            cropBoxData.minTop = Math.max(0, canvasData.top);
            cropBoxData.maxLeft = Math.min(containerData.width, canvasData.left + canvasData.width) - cropBoxData.width;
            cropBoxData.maxTop = Math.min(containerData.height, canvasData.top + canvasData.height) - cropBoxData.height;
          } else {
            cropBoxData.minLeft = 0;
            cropBoxData.minTop = 0;
            cropBoxData.maxLeft = containerData.width - cropBoxData.width;
            cropBoxData.maxTop = containerData.height - cropBoxData.height;
          }
        }
      },
      renderCropBox: function renderCropBox() {
        var options = this.options, containerData = this.containerData, cropBoxData = this.cropBoxData;
        if (cropBoxData.width > cropBoxData.maxWidth || cropBoxData.width < cropBoxData.minWidth) {
          cropBoxData.left = cropBoxData.oldLeft;
        }
        if (cropBoxData.height > cropBoxData.maxHeight || cropBoxData.height < cropBoxData.minHeight) {
          cropBoxData.top = cropBoxData.oldTop;
        }
        cropBoxData.width = Math.min(Math.max(cropBoxData.width, cropBoxData.minWidth), cropBoxData.maxWidth);
        cropBoxData.height = Math.min(Math.max(cropBoxData.height, cropBoxData.minHeight), cropBoxData.maxHeight);
        this.limitCropBox(false, true);
        cropBoxData.left = Math.min(Math.max(cropBoxData.left, cropBoxData.minLeft), cropBoxData.maxLeft);
        cropBoxData.top = Math.min(Math.max(cropBoxData.top, cropBoxData.minTop), cropBoxData.maxTop);
        cropBoxData.oldLeft = cropBoxData.left;
        cropBoxData.oldTop = cropBoxData.top;
        if (options.movable && options.cropBoxMovable) {
          setData2(this.face, DATA_ACTION, cropBoxData.width >= containerData.width && cropBoxData.height >= containerData.height ? ACTION_MOVE : ACTION_ALL);
        }
        setStyle(this.cropBox, assign({
          width: cropBoxData.width,
          height: cropBoxData.height
        }, getTransforms({
          translateX: cropBoxData.left,
          translateY: cropBoxData.top
        })));
        if (this.cropped && this.limited) {
          this.limitCanvas(true, true);
        }
        if (!this.disabled) {
          this.output();
        }
      },
      output: function output() {
        this.preview();
        dispatchEvent2(this.element, EVENT_CROP, this.getData());
      }
    };
    var preview = {
      initPreview: function initPreview() {
        var element = this.element, crossOrigin = this.crossOrigin;
        var preview2 = this.options.preview;
        var url = crossOrigin ? this.crossOriginUrl : this.url;
        var alt = element.alt || "The image to preview";
        var image = document.createElement("img");
        if (crossOrigin) {
          image.crossOrigin = crossOrigin;
        }
        image.src = url;
        image.alt = alt;
        this.viewBox.appendChild(image);
        this.viewBoxImage = image;
        if (!preview2) {
          return;
        }
        var previews = preview2;
        if (typeof preview2 === "string") {
          previews = element.ownerDocument.querySelectorAll(preview2);
        } else if (preview2.querySelector) {
          previews = [preview2];
        }
        this.previews = previews;
        forEach(previews, function(el) {
          var img = document.createElement("img");
          setData2(el, DATA_PREVIEW, {
            width: el.offsetWidth,
            height: el.offsetHeight,
            html: el.innerHTML
          });
          if (crossOrigin) {
            img.crossOrigin = crossOrigin;
          }
          img.src = url;
          img.alt = alt;
          img.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"';
          el.innerHTML = "";
          el.appendChild(img);
        });
      },
      resetPreview: function resetPreview() {
        forEach(this.previews, function(element) {
          var data = getData2(element, DATA_PREVIEW);
          setStyle(element, {
            width: data.width,
            height: data.height
          });
          element.innerHTML = data.html;
          removeData(element, DATA_PREVIEW);
        });
      },
      preview: function preview2() {
        var imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
        var cropBoxWidth = cropBoxData.width, cropBoxHeight = cropBoxData.height;
        var width = imageData.width, height = imageData.height;
        var left = cropBoxData.left - canvasData.left - imageData.left;
        var top = cropBoxData.top - canvasData.top - imageData.top;
        if (!this.cropped || this.disabled) {
          return;
        }
        setStyle(this.viewBoxImage, assign({
          width,
          height
        }, getTransforms(assign({
          translateX: -left,
          translateY: -top
        }, imageData))));
        forEach(this.previews, function(element) {
          var data = getData2(element, DATA_PREVIEW);
          var originalWidth = data.width;
          var originalHeight = data.height;
          var newWidth = originalWidth;
          var newHeight = originalHeight;
          var ratio = 1;
          if (cropBoxWidth) {
            ratio = originalWidth / cropBoxWidth;
            newHeight = cropBoxHeight * ratio;
          }
          if (cropBoxHeight && newHeight > originalHeight) {
            ratio = originalHeight / cropBoxHeight;
            newWidth = cropBoxWidth * ratio;
            newHeight = originalHeight;
          }
          setStyle(element, {
            width: newWidth,
            height: newHeight
          });
          setStyle(element.getElementsByTagName("img")[0], assign({
            width: width * ratio,
            height: height * ratio
          }, getTransforms(assign({
            translateX: -left * ratio,
            translateY: -top * ratio
          }, imageData))));
        });
      }
    };
    var events = {
      bind: function bind() {
        var element = this.element, options = this.options, cropper2 = this.cropper;
        if (isFunction(options.cropstart)) {
          addListener(element, EVENT_CROP_START, options.cropstart);
        }
        if (isFunction(options.cropmove)) {
          addListener(element, EVENT_CROP_MOVE, options.cropmove);
        }
        if (isFunction(options.cropend)) {
          addListener(element, EVENT_CROP_END, options.cropend);
        }
        if (isFunction(options.crop)) {
          addListener(element, EVENT_CROP, options.crop);
        }
        if (isFunction(options.zoom)) {
          addListener(element, EVENT_ZOOM, options.zoom);
        }
        addListener(cropper2, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this));
        if (options.zoomable && options.zoomOnWheel) {
          addListener(cropper2, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
            passive: false,
            capture: true
          });
        }
        if (options.toggleDragModeOnDblclick) {
          addListener(cropper2, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
        }
        addListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this));
        addListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this));
        if (options.responsive) {
          addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
        }
      },
      unbind: function unbind() {
        var element = this.element, options = this.options, cropper2 = this.cropper;
        if (isFunction(options.cropstart)) {
          removeListener(element, EVENT_CROP_START, options.cropstart);
        }
        if (isFunction(options.cropmove)) {
          removeListener(element, EVENT_CROP_MOVE, options.cropmove);
        }
        if (isFunction(options.cropend)) {
          removeListener(element, EVENT_CROP_END, options.cropend);
        }
        if (isFunction(options.crop)) {
          removeListener(element, EVENT_CROP, options.crop);
        }
        if (isFunction(options.zoom)) {
          removeListener(element, EVENT_ZOOM, options.zoom);
        }
        removeListener(cropper2, EVENT_POINTER_DOWN, this.onCropStart);
        if (options.zoomable && options.zoomOnWheel) {
          removeListener(cropper2, EVENT_WHEEL, this.onWheel, {
            passive: false,
            capture: true
          });
        }
        if (options.toggleDragModeOnDblclick) {
          removeListener(cropper2, EVENT_DBLCLICK, this.onDblclick);
        }
        removeListener(element.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove);
        removeListener(element.ownerDocument, EVENT_POINTER_UP, this.onCropEnd);
        if (options.responsive) {
          removeListener(window, EVENT_RESIZE, this.onResize);
        }
      }
    };
    var handlers = {
      resize: function resize() {
        if (this.disabled) {
          return;
        }
        var options = this.options, container = this.container, containerData = this.containerData;
        var ratioX = container.offsetWidth / containerData.width;
        var ratioY = container.offsetHeight / containerData.height;
        var ratio = Math.abs(ratioX - 1) > Math.abs(ratioY - 1) ? ratioX : ratioY;
        if (ratio !== 1) {
          var canvasData;
          var cropBoxData;
          if (options.restore) {
            canvasData = this.getCanvasData();
            cropBoxData = this.getCropBoxData();
          }
          this.render();
          if (options.restore) {
            this.setCanvasData(forEach(canvasData, function(n2, i) {
              canvasData[i] = n2 * ratio;
            }));
            this.setCropBoxData(forEach(cropBoxData, function(n2, i) {
              cropBoxData[i] = n2 * ratio;
            }));
          }
        }
      },
      dblclick: function dblclick() {
        if (this.disabled || this.options.dragMode === DRAG_MODE_NONE) {
          return;
        }
        this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP);
      },
      wheel: function wheel(event) {
        var _this = this;
        var ratio = Number(this.options.wheelZoomRatio) || 0.1;
        var delta = 1;
        if (this.disabled) {
          return;
        }
        event.preventDefault();
        if (this.wheeling) {
          return;
        }
        this.wheeling = true;
        setTimeout(function() {
          _this.wheeling = false;
        }, 50);
        if (event.deltaY) {
          delta = event.deltaY > 0 ? 1 : -1;
        } else if (event.wheelDelta) {
          delta = -event.wheelDelta / 120;
        } else if (event.detail) {
          delta = event.detail > 0 ? 1 : -1;
        }
        this.zoom(-delta * ratio, event);
      },
      cropStart: function cropStart(event) {
        var buttons = event.buttons, button = event.button;
        if (this.disabled || (event.type === "mousedown" || event.type === "pointerdown" && event.pointerType === "mouse") && // No primary button (Usually the left button)
        (isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0 || event.ctrlKey)) {
          return;
        }
        var options = this.options, pointers = this.pointers;
        var action;
        if (event.changedTouches) {
          forEach(event.changedTouches, function(touch) {
            pointers[touch.identifier] = getPointer(touch);
          });
        } else {
          pointers[event.pointerId || 0] = getPointer(event);
        }
        if (Object.keys(pointers).length > 1 && options.zoomable && options.zoomOnTouch) {
          action = ACTION_ZOOM;
        } else {
          action = getData2(event.target, DATA_ACTION);
        }
        if (!REGEXP_ACTIONS.test(action)) {
          return;
        }
        if (dispatchEvent2(this.element, EVENT_CROP_START, {
          originalEvent: event,
          action
        }) === false) {
          return;
        }
        event.preventDefault();
        this.action = action;
        this.cropping = false;
        if (action === ACTION_CROP) {
          this.cropping = true;
          addClass(this.dragBox, CLASS_MODAL);
        }
      },
      cropMove: function cropMove(event) {
        var action = this.action;
        if (this.disabled || !action) {
          return;
        }
        var pointers = this.pointers;
        event.preventDefault();
        if (dispatchEvent2(this.element, EVENT_CROP_MOVE, {
          originalEvent: event,
          action
        }) === false) {
          return;
        }
        if (event.changedTouches) {
          forEach(event.changedTouches, function(touch) {
            assign(pointers[touch.identifier] || {}, getPointer(touch, true));
          });
        } else {
          assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
        }
        this.change(event);
      },
      cropEnd: function cropEnd(event) {
        if (this.disabled) {
          return;
        }
        var action = this.action, pointers = this.pointers;
        if (event.changedTouches) {
          forEach(event.changedTouches, function(touch) {
            delete pointers[touch.identifier];
          });
        } else {
          delete pointers[event.pointerId || 0];
        }
        if (!action) {
          return;
        }
        event.preventDefault();
        if (!Object.keys(pointers).length) {
          this.action = "";
        }
        if (this.cropping) {
          this.cropping = false;
          toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal);
        }
        dispatchEvent2(this.element, EVENT_CROP_END, {
          originalEvent: event,
          action
        });
      }
    };
    var change = {
      change: function change2(event) {
        var options = this.options, canvasData = this.canvasData, containerData = this.containerData, cropBoxData = this.cropBoxData, pointers = this.pointers;
        var action = this.action;
        var aspectRatio = options.aspectRatio;
        var left = cropBoxData.left, top = cropBoxData.top, width = cropBoxData.width, height = cropBoxData.height;
        var right = left + width;
        var bottom = top + height;
        var minLeft = 0;
        var minTop = 0;
        var maxWidth = containerData.width;
        var maxHeight = containerData.height;
        var renderable = true;
        var offset;
        if (!aspectRatio && event.shiftKey) {
          aspectRatio = width && height ? width / height : 1;
        }
        if (this.limited) {
          minLeft = cropBoxData.minLeft;
          minTop = cropBoxData.minTop;
          maxWidth = minLeft + Math.min(containerData.width, canvasData.width, canvasData.left + canvasData.width);
          maxHeight = minTop + Math.min(containerData.height, canvasData.height, canvasData.top + canvasData.height);
        }
        var pointer2 = pointers[Object.keys(pointers)[0]];
        var range = {
          x: pointer2.endX - pointer2.startX,
          y: pointer2.endY - pointer2.startY
        };
        var check = function check2(side) {
          switch (side) {
            case ACTION_EAST:
              if (right + range.x > maxWidth) {
                range.x = maxWidth - right;
              }
              break;
            case ACTION_WEST:
              if (left + range.x < minLeft) {
                range.x = minLeft - left;
              }
              break;
            case ACTION_NORTH:
              if (top + range.y < minTop) {
                range.y = minTop - top;
              }
              break;
            case ACTION_SOUTH:
              if (bottom + range.y > maxHeight) {
                range.y = maxHeight - bottom;
              }
              break;
          }
        };
        switch (action) {
          case ACTION_ALL:
            left += range.x;
            top += range.y;
            break;
          case ACTION_EAST:
            if (range.x >= 0 && (right >= maxWidth || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
              renderable = false;
              break;
            }
            check(ACTION_EAST);
            width += range.x;
            if (width < 0) {
              action = ACTION_WEST;
              width = -width;
              left -= width;
            }
            if (aspectRatio) {
              height = width / aspectRatio;
              top += (cropBoxData.height - height) / 2;
            }
            break;
          case ACTION_NORTH:
            if (range.y <= 0 && (top <= minTop || aspectRatio && (left <= minLeft || right >= maxWidth))) {
              renderable = false;
              break;
            }
            check(ACTION_NORTH);
            height -= range.y;
            top += range.y;
            if (height < 0) {
              action = ACTION_SOUTH;
              height = -height;
              top -= height;
            }
            if (aspectRatio) {
              width = height * aspectRatio;
              left += (cropBoxData.width - width) / 2;
            }
            break;
          case ACTION_WEST:
            if (range.x <= 0 && (left <= minLeft || aspectRatio && (top <= minTop || bottom >= maxHeight))) {
              renderable = false;
              break;
            }
            check(ACTION_WEST);
            width -= range.x;
            left += range.x;
            if (width < 0) {
              action = ACTION_EAST;
              width = -width;
              left -= width;
            }
            if (aspectRatio) {
              height = width / aspectRatio;
              top += (cropBoxData.height - height) / 2;
            }
            break;
          case ACTION_SOUTH:
            if (range.y >= 0 && (bottom >= maxHeight || aspectRatio && (left <= minLeft || right >= maxWidth))) {
              renderable = false;
              break;
            }
            check(ACTION_SOUTH);
            height += range.y;
            if (height < 0) {
              action = ACTION_NORTH;
              height = -height;
              top -= height;
            }
            if (aspectRatio) {
              width = height * aspectRatio;
              left += (cropBoxData.width - width) / 2;
            }
            break;
          case ACTION_NORTH_EAST:
            if (aspectRatio) {
              if (range.y <= 0 && (top <= minTop || right >= maxWidth)) {
                renderable = false;
                break;
              }
              check(ACTION_NORTH);
              height -= range.y;
              top += range.y;
              width = height * aspectRatio;
            } else {
              check(ACTION_NORTH);
              check(ACTION_EAST);
              if (range.x >= 0) {
                if (right < maxWidth) {
                  width += range.x;
                } else if (range.y <= 0 && top <= minTop) {
                  renderable = false;
                }
              } else {
                width += range.x;
              }
              if (range.y <= 0) {
                if (top > minTop) {
                  height -= range.y;
                  top += range.y;
                }
              } else {
                height -= range.y;
                top += range.y;
              }
            }
            if (width < 0 && height < 0) {
              action = ACTION_SOUTH_WEST;
              height = -height;
              width = -width;
              top -= height;
              left -= width;
            } else if (width < 0) {
              action = ACTION_NORTH_WEST;
              width = -width;
              left -= width;
            } else if (height < 0) {
              action = ACTION_SOUTH_EAST;
              height = -height;
              top -= height;
            }
            break;
          case ACTION_NORTH_WEST:
            if (aspectRatio) {
              if (range.y <= 0 && (top <= minTop || left <= minLeft)) {
                renderable = false;
                break;
              }
              check(ACTION_NORTH);
              height -= range.y;
              top += range.y;
              width = height * aspectRatio;
              left += cropBoxData.width - width;
            } else {
              check(ACTION_NORTH);
              check(ACTION_WEST);
              if (range.x <= 0) {
                if (left > minLeft) {
                  width -= range.x;
                  left += range.x;
                } else if (range.y <= 0 && top <= minTop) {
                  renderable = false;
                }
              } else {
                width -= range.x;
                left += range.x;
              }
              if (range.y <= 0) {
                if (top > minTop) {
                  height -= range.y;
                  top += range.y;
                }
              } else {
                height -= range.y;
                top += range.y;
              }
            }
            if (width < 0 && height < 0) {
              action = ACTION_SOUTH_EAST;
              height = -height;
              width = -width;
              top -= height;
              left -= width;
            } else if (width < 0) {
              action = ACTION_NORTH_EAST;
              width = -width;
              left -= width;
            } else if (height < 0) {
              action = ACTION_SOUTH_WEST;
              height = -height;
              top -= height;
            }
            break;
          case ACTION_SOUTH_WEST:
            if (aspectRatio) {
              if (range.x <= 0 && (left <= minLeft || bottom >= maxHeight)) {
                renderable = false;
                break;
              }
              check(ACTION_WEST);
              width -= range.x;
              left += range.x;
              height = width / aspectRatio;
            } else {
              check(ACTION_SOUTH);
              check(ACTION_WEST);
              if (range.x <= 0) {
                if (left > minLeft) {
                  width -= range.x;
                  left += range.x;
                } else if (range.y >= 0 && bottom >= maxHeight) {
                  renderable = false;
                }
              } else {
                width -= range.x;
                left += range.x;
              }
              if (range.y >= 0) {
                if (bottom < maxHeight) {
                  height += range.y;
                }
              } else {
                height += range.y;
              }
            }
            if (width < 0 && height < 0) {
              action = ACTION_NORTH_EAST;
              height = -height;
              width = -width;
              top -= height;
              left -= width;
            } else if (width < 0) {
              action = ACTION_SOUTH_EAST;
              width = -width;
              left -= width;
            } else if (height < 0) {
              action = ACTION_NORTH_WEST;
              height = -height;
              top -= height;
            }
            break;
          case ACTION_SOUTH_EAST:
            if (aspectRatio) {
              if (range.x >= 0 && (right >= maxWidth || bottom >= maxHeight)) {
                renderable = false;
                break;
              }
              check(ACTION_EAST);
              width += range.x;
              height = width / aspectRatio;
            } else {
              check(ACTION_SOUTH);
              check(ACTION_EAST);
              if (range.x >= 0) {
                if (right < maxWidth) {
                  width += range.x;
                } else if (range.y >= 0 && bottom >= maxHeight) {
                  renderable = false;
                }
              } else {
                width += range.x;
              }
              if (range.y >= 0) {
                if (bottom < maxHeight) {
                  height += range.y;
                }
              } else {
                height += range.y;
              }
            }
            if (width < 0 && height < 0) {
              action = ACTION_NORTH_WEST;
              height = -height;
              width = -width;
              top -= height;
              left -= width;
            } else if (width < 0) {
              action = ACTION_SOUTH_WEST;
              width = -width;
              left -= width;
            } else if (height < 0) {
              action = ACTION_NORTH_EAST;
              height = -height;
              top -= height;
            }
            break;
          case ACTION_MOVE:
            this.move(range.x, range.y);
            renderable = false;
            break;
          case ACTION_ZOOM:
            this.zoom(getMaxZoomRatio(pointers), event);
            renderable = false;
            break;
          case ACTION_CROP:
            if (!range.x || !range.y) {
              renderable = false;
              break;
            }
            offset = getOffset(this.cropper);
            left = pointer2.startX - offset.left;
            top = pointer2.startY - offset.top;
            width = cropBoxData.minWidth;
            height = cropBoxData.minHeight;
            if (range.x > 0) {
              action = range.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST;
            } else if (range.x < 0) {
              left -= width;
              action = range.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST;
            }
            if (range.y < 0) {
              top -= height;
            }
            if (!this.cropped) {
              removeClass(this.cropBox, CLASS_HIDDEN);
              this.cropped = true;
              if (this.limited) {
                this.limitCropBox(true, true);
              }
            }
            break;
        }
        if (renderable) {
          cropBoxData.width = width;
          cropBoxData.height = height;
          cropBoxData.left = left;
          cropBoxData.top = top;
          this.action = action;
          this.renderCropBox();
        }
        forEach(pointers, function(p) {
          p.startX = p.endX;
          p.startY = p.endY;
        });
      }
    };
    var methods = {
      // Show the crop box manually
      crop: function crop() {
        if (this.ready && !this.cropped && !this.disabled) {
          this.cropped = true;
          this.limitCropBox(true, true);
          if (this.options.modal) {
            addClass(this.dragBox, CLASS_MODAL);
          }
          removeClass(this.cropBox, CLASS_HIDDEN);
          this.setCropBoxData(this.initialCropBoxData);
        }
        return this;
      },
      // Reset the image and crop box to their initial states
      reset: function reset2() {
        if (this.ready && !this.disabled) {
          this.imageData = assign({}, this.initialImageData);
          this.canvasData = assign({}, this.initialCanvasData);
          this.cropBoxData = assign({}, this.initialCropBoxData);
          this.renderCanvas();
          if (this.cropped) {
            this.renderCropBox();
          }
        }
        return this;
      },
      // Clear the crop box
      clear: function clear2() {
        if (this.cropped && !this.disabled) {
          assign(this.cropBoxData, {
            left: 0,
            top: 0,
            width: 0,
            height: 0
          });
          this.cropped = false;
          this.renderCropBox();
          this.limitCanvas(true, true);
          this.renderCanvas();
          removeClass(this.dragBox, CLASS_MODAL);
          addClass(this.cropBox, CLASS_HIDDEN);
        }
        return this;
      },
      /**
       * Replace the image's src and rebuild the cropper
       * @param {string} url - The new URL.
       * @param {boolean} [hasSameSize] - Indicate if the new image has the same size as the old one.
       * @returns {Cropper} this
       */
      replace: function replace2(url) {
        var hasSameSize = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!this.disabled && url) {
          if (this.isImg) {
            this.element.src = url;
          }
          if (hasSameSize) {
            this.url = url;
            this.image.src = url;
            if (this.ready) {
              this.viewBoxImage.src = url;
              forEach(this.previews, function(element) {
                element.getElementsByTagName("img")[0].src = url;
              });
            }
          } else {
            if (this.isImg) {
              this.replaced = true;
            }
            this.options.data = null;
            this.uncreate();
            this.load(url);
          }
        }
        return this;
      },
      // Enable (unfreeze) the cropper
      enable: function enable2() {
        if (this.ready && this.disabled) {
          this.disabled = false;
          removeClass(this.cropper, CLASS_DISABLED);
        }
        return this;
      },
      // Disable (freeze) the cropper
      disable: function disable2() {
        if (this.ready && !this.disabled) {
          this.disabled = true;
          addClass(this.cropper, CLASS_DISABLED);
        }
        return this;
      },
      /**
       * Destroy the cropper and remove the instance from the image
       * @returns {Cropper} this
       */
      destroy: function destroy2() {
        var element = this.element;
        if (!element[NAMESPACE]) {
          return this;
        }
        element[NAMESPACE] = void 0;
        if (this.isImg && this.replaced) {
          element.src = this.originalUrl;
        }
        this.uncreate();
        return this;
      },
      /**
       * Move the canvas with relative offsets
       * @param {number} offsetX - The relative offset distance on the x-axis.
       * @param {number} [offsetY=offsetX] - The relative offset distance on the y-axis.
       * @returns {Cropper} this
       */
      move: function move2(offsetX) {
        var offsetY = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : offsetX;
        var _this$canvasData = this.canvasData, left = _this$canvasData.left, top = _this$canvasData.top;
        return this.moveTo(isUndefined(offsetX) ? offsetX : left + Number(offsetX), isUndefined(offsetY) ? offsetY : top + Number(offsetY));
      },
      /**
       * Move the canvas to an absolute point
       * @param {number} x - The x-axis coordinate.
       * @param {number} [y=x] - The y-axis coordinate.
       * @returns {Cropper} this
       */
      moveTo: function moveTo2(x2) {
        var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x2;
        var canvasData = this.canvasData;
        var changed = false;
        x2 = Number(x2);
        y2 = Number(y2);
        if (this.ready && !this.disabled && this.options.movable) {
          if (isNumber(x2)) {
            canvasData.left = x2;
            changed = true;
          }
          if (isNumber(y2)) {
            canvasData.top = y2;
            changed = true;
          }
          if (changed) {
            this.renderCanvas(true);
          }
        }
        return this;
      },
      /**
       * Zoom the canvas with a relative ratio
       * @param {number} ratio - The target ratio.
       * @param {Event} _originalEvent - The original event if any.
       * @returns {Cropper} this
       */
      zoom: function zoom2(ratio, _originalEvent) {
        var canvasData = this.canvasData;
        ratio = Number(ratio);
        if (ratio < 0) {
          ratio = 1 / (1 - ratio);
        } else {
          ratio = 1 + ratio;
        }
        return this.zoomTo(canvasData.width * ratio / canvasData.naturalWidth, null, _originalEvent);
      },
      /**
       * Zoom the canvas to an absolute ratio
       * @param {number} ratio - The target ratio.
       * @param {Object} pivot - The zoom pivot point coordinate.
       * @param {Event} _originalEvent - The original event if any.
       * @returns {Cropper} this
       */
      zoomTo: function zoomTo2(ratio, pivot, _originalEvent) {
        var options = this.options, canvasData = this.canvasData;
        var width = canvasData.width, height = canvasData.height, naturalWidth = canvasData.naturalWidth, naturalHeight = canvasData.naturalHeight;
        ratio = Number(ratio);
        if (ratio >= 0 && this.ready && !this.disabled && options.zoomable) {
          var newWidth = naturalWidth * ratio;
          var newHeight = naturalHeight * ratio;
          if (dispatchEvent2(this.element, EVENT_ZOOM, {
            ratio,
            oldRatio: width / naturalWidth,
            originalEvent: _originalEvent
          }) === false) {
            return this;
          }
          if (_originalEvent) {
            var pointers = this.pointers;
            var offset = getOffset(this.cropper);
            var center = pointers && Object.keys(pointers).length ? getPointersCenter(pointers) : {
              pageX: _originalEvent.pageX,
              pageY: _originalEvent.pageY
            };
            canvasData.left -= (newWidth - width) * ((center.pageX - offset.left - canvasData.left) / width);
            canvasData.top -= (newHeight - height) * ((center.pageY - offset.top - canvasData.top) / height);
          } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
            canvasData.left -= (newWidth - width) * ((pivot.x - canvasData.left) / width);
            canvasData.top -= (newHeight - height) * ((pivot.y - canvasData.top) / height);
          } else {
            canvasData.left -= (newWidth - width) / 2;
            canvasData.top -= (newHeight - height) / 2;
          }
          canvasData.width = newWidth;
          canvasData.height = newHeight;
          this.renderCanvas(true);
        }
        return this;
      },
      /**
       * Rotate the canvas with a relative degree
       * @param {number} degree - The rotate degree.
       * @returns {Cropper} this
       */
      rotate: function rotate2(degree) {
        return this.rotateTo((this.imageData.rotate || 0) + Number(degree));
      },
      /**
       * Rotate the canvas to an absolute degree
       * @param {number} degree - The rotate degree.
       * @returns {Cropper} this
       */
      rotateTo: function rotateTo2(degree) {
        degree = Number(degree);
        if (isNumber(degree) && this.ready && !this.disabled && this.options.rotatable) {
          this.imageData.rotate = degree % 360;
          this.renderCanvas(true, true);
        }
        return this;
      },
      /**
       * Scale the image on the x-axis.
       * @param {number} scaleX - The scale ratio on the x-axis.
       * @returns {Cropper} this
       */
      scaleX: function scaleX2(_scaleX) {
        var scaleY2 = this.imageData.scaleY;
        return this.scale(_scaleX, isNumber(scaleY2) ? scaleY2 : 1);
      },
      /**
       * Scale the image on the y-axis.
       * @param {number} scaleY - The scale ratio on the y-axis.
       * @returns {Cropper} this
       */
      scaleY: function scaleY2(_scaleY) {
        var scaleX2 = this.imageData.scaleX;
        return this.scale(isNumber(scaleX2) ? scaleX2 : 1, _scaleY);
      },
      /**
       * Scale the image
       * @param {number} scaleX - The scale ratio on the x-axis.
       * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
       * @returns {Cropper} this
       */
      scale: function scale2(scaleX2) {
        var scaleY2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : scaleX2;
        var imageData = this.imageData;
        var transformed = false;
        scaleX2 = Number(scaleX2);
        scaleY2 = Number(scaleY2);
        if (this.ready && !this.disabled && this.options.scalable) {
          if (isNumber(scaleX2)) {
            imageData.scaleX = scaleX2;
            transformed = true;
          }
          if (isNumber(scaleY2)) {
            imageData.scaleY = scaleY2;
            transformed = true;
          }
          if (transformed) {
            this.renderCanvas(true, true);
          }
        }
        return this;
      },
      /**
       * Get the cropped area position and size data (base on the original image)
       * @param {boolean} [rounded=false] - Indicate if round the data values or not.
       * @returns {Object} The result cropped data.
       */
      getData: function getData3() {
        var rounded = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        var options = this.options, imageData = this.imageData, canvasData = this.canvasData, cropBoxData = this.cropBoxData;
        var data;
        if (this.ready && this.cropped) {
          data = {
            x: cropBoxData.left - canvasData.left,
            y: cropBoxData.top - canvasData.top,
            width: cropBoxData.width,
            height: cropBoxData.height
          };
          var ratio = imageData.width / imageData.naturalWidth;
          forEach(data, function(n2, i) {
            data[i] = n2 / ratio;
          });
          if (rounded) {
            var bottom = Math.round(data.y + data.height);
            var right = Math.round(data.x + data.width);
            data.x = Math.round(data.x);
            data.y = Math.round(data.y);
            data.width = right - data.x;
            data.height = bottom - data.y;
          }
        } else {
          data = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
        if (options.rotatable) {
          data.rotate = imageData.rotate || 0;
        }
        if (options.scalable) {
          data.scaleX = imageData.scaleX || 1;
          data.scaleY = imageData.scaleY || 1;
        }
        return data;
      },
      /**
       * Set the cropped area position and size with new data
       * @param {Object} data - The new data.
       * @returns {Cropper} this
       */
      setData: function setData3(data) {
        var options = this.options, imageData = this.imageData, canvasData = this.canvasData;
        var cropBoxData = {};
        if (this.ready && !this.disabled && isPlainObject(data)) {
          var transformed = false;
          if (options.rotatable) {
            if (isNumber(data.rotate) && data.rotate !== imageData.rotate) {
              imageData.rotate = data.rotate;
              transformed = true;
            }
          }
          if (options.scalable) {
            if (isNumber(data.scaleX) && data.scaleX !== imageData.scaleX) {
              imageData.scaleX = data.scaleX;
              transformed = true;
            }
            if (isNumber(data.scaleY) && data.scaleY !== imageData.scaleY) {
              imageData.scaleY = data.scaleY;
              transformed = true;
            }
          }
          if (transformed) {
            this.renderCanvas(true, true);
          }
          var ratio = imageData.width / imageData.naturalWidth;
          if (isNumber(data.x)) {
            cropBoxData.left = data.x * ratio + canvasData.left;
          }
          if (isNumber(data.y)) {
            cropBoxData.top = data.y * ratio + canvasData.top;
          }
          if (isNumber(data.width)) {
            cropBoxData.width = data.width * ratio;
          }
          if (isNumber(data.height)) {
            cropBoxData.height = data.height * ratio;
          }
          this.setCropBoxData(cropBoxData);
        }
        return this;
      },
      /**
       * Get the container size data.
       * @returns {Object} The result container data.
       */
      getContainerData: function getContainerData2() {
        return this.ready ? assign({}, this.containerData) : {};
      },
      /**
       * Get the image position and size data.
       * @returns {Object} The result image data.
       */
      getImageData: function getImageData2() {
        return this.sized ? assign({}, this.imageData) : {};
      },
      /**
       * Get the canvas position and size data.
       * @returns {Object} The result canvas data.
       */
      getCanvasData: function getCanvasData2() {
        var canvasData = this.canvasData;
        var data = {};
        if (this.ready) {
          forEach(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function(n2) {
            data[n2] = canvasData[n2];
          });
        }
        return data;
      },
      /**
       * Set the canvas position and size with new data.
       * @param {Object} data - The new canvas data.
       * @returns {Cropper} this
       */
      setCanvasData: function setCanvasData2(data) {
        var canvasData = this.canvasData;
        var aspectRatio = canvasData.aspectRatio;
        if (this.ready && !this.disabled && isPlainObject(data)) {
          if (isNumber(data.left)) {
            canvasData.left = data.left;
          }
          if (isNumber(data.top)) {
            canvasData.top = data.top;
          }
          if (isNumber(data.width)) {
            canvasData.width = data.width;
            canvasData.height = data.width / aspectRatio;
          } else if (isNumber(data.height)) {
            canvasData.height = data.height;
            canvasData.width = data.height * aspectRatio;
          }
          this.renderCanvas(true);
        }
        return this;
      },
      /**
       * Get the crop box position and size data.
       * @returns {Object} The result crop box data.
       */
      getCropBoxData: function getCropBoxData2() {
        var cropBoxData = this.cropBoxData;
        var data;
        if (this.ready && this.cropped) {
          data = {
            left: cropBoxData.left,
            top: cropBoxData.top,
            width: cropBoxData.width,
            height: cropBoxData.height
          };
        }
        return data || {};
      },
      /**
       * Set the crop box position and size with new data.
       * @param {Object} data - The new crop box data.
       * @returns {Cropper} this
       */
      setCropBoxData: function setCropBoxData2(data) {
        var cropBoxData = this.cropBoxData;
        var aspectRatio = this.options.aspectRatio;
        var widthChanged;
        var heightChanged;
        if (this.ready && this.cropped && !this.disabled && isPlainObject(data)) {
          if (isNumber(data.left)) {
            cropBoxData.left = data.left;
          }
          if (isNumber(data.top)) {
            cropBoxData.top = data.top;
          }
          if (isNumber(data.width) && data.width !== cropBoxData.width) {
            widthChanged = true;
            cropBoxData.width = data.width;
          }
          if (isNumber(data.height) && data.height !== cropBoxData.height) {
            heightChanged = true;
            cropBoxData.height = data.height;
          }
          if (aspectRatio) {
            if (widthChanged) {
              cropBoxData.height = cropBoxData.width / aspectRatio;
            } else if (heightChanged) {
              cropBoxData.width = cropBoxData.height * aspectRatio;
            }
          }
          this.renderCropBox();
        }
        return this;
      },
      /**
       * Get a canvas drawn the cropped image.
       * @param {Object} [options={}] - The config options.
       * @returns {HTMLCanvasElement} - The result canvas.
       */
      getCroppedCanvas: function getCroppedCanvas2() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!this.ready || !window.HTMLCanvasElement) {
          return null;
        }
        var canvasData = this.canvasData;
        var source = getSourceCanvas(this.image, this.imageData, canvasData, options);
        if (!this.cropped) {
          return source;
        }
        var _this$getData = this.getData(), initialX = _this$getData.x, initialY = _this$getData.y, initialWidth = _this$getData.width, initialHeight = _this$getData.height;
        var ratio = source.width / Math.floor(canvasData.naturalWidth);
        if (ratio !== 1) {
          initialX *= ratio;
          initialY *= ratio;
          initialWidth *= ratio;
          initialHeight *= ratio;
        }
        var aspectRatio = initialWidth / initialHeight;
        var maxSizes = getAdjustedSizes({
          aspectRatio,
          width: options.maxWidth || Infinity,
          height: options.maxHeight || Infinity
        });
        var minSizes = getAdjustedSizes({
          aspectRatio,
          width: options.minWidth || 0,
          height: options.minHeight || 0
        }, "cover");
        var _getAdjustedSizes = getAdjustedSizes({
          aspectRatio,
          width: options.width || (ratio !== 1 ? source.width : initialWidth),
          height: options.height || (ratio !== 1 ? source.height : initialHeight)
        }), width = _getAdjustedSizes.width, height = _getAdjustedSizes.height;
        width = Math.min(maxSizes.width, Math.max(minSizes.width, width));
        height = Math.min(maxSizes.height, Math.max(minSizes.height, height));
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");
        canvas.width = normalizeDecimalNumber(width);
        canvas.height = normalizeDecimalNumber(height);
        context.fillStyle = options.fillColor || "transparent";
        context.fillRect(0, 0, width, height);
        var _options$imageSmoothi = options.imageSmoothingEnabled, imageSmoothingEnabled = _options$imageSmoothi === void 0 ? true : _options$imageSmoothi, imageSmoothingQuality = options.imageSmoothingQuality;
        context.imageSmoothingEnabled = imageSmoothingEnabled;
        if (imageSmoothingQuality) {
          context.imageSmoothingQuality = imageSmoothingQuality;
        }
        var sourceWidth = source.width;
        var sourceHeight = source.height;
        var srcX = initialX;
        var srcY = initialY;
        var srcWidth;
        var srcHeight;
        var dstX;
        var dstY;
        var dstWidth;
        var dstHeight;
        if (srcX <= -initialWidth || srcX > sourceWidth) {
          srcX = 0;
          srcWidth = 0;
          dstX = 0;
          dstWidth = 0;
        } else if (srcX <= 0) {
          dstX = -srcX;
          srcX = 0;
          srcWidth = Math.min(sourceWidth, initialWidth + srcX);
          dstWidth = srcWidth;
        } else if (srcX <= sourceWidth) {
          dstX = 0;
          srcWidth = Math.min(initialWidth, sourceWidth - srcX);
          dstWidth = srcWidth;
        }
        if (srcWidth <= 0 || srcY <= -initialHeight || srcY > sourceHeight) {
          srcY = 0;
          srcHeight = 0;
          dstY = 0;
          dstHeight = 0;
        } else if (srcY <= 0) {
          dstY = -srcY;
          srcY = 0;
          srcHeight = Math.min(sourceHeight, initialHeight + srcY);
          dstHeight = srcHeight;
        } else if (srcY <= sourceHeight) {
          dstY = 0;
          srcHeight = Math.min(initialHeight, sourceHeight - srcY);
          dstHeight = srcHeight;
        }
        var params = [srcX, srcY, srcWidth, srcHeight];
        if (dstWidth > 0 && dstHeight > 0) {
          var scale2 = width / initialWidth;
          params.push(dstX * scale2, dstY * scale2, dstWidth * scale2, dstHeight * scale2);
        }
        context.drawImage.apply(context, [source].concat(_toConsumableArray(params.map(function(param) {
          return Math.floor(normalizeDecimalNumber(param));
        }))));
        return canvas;
      },
      /**
       * Change the aspect ratio of the crop box.
       * @param {number} aspectRatio - The new aspect ratio.
       * @returns {Cropper} this
       */
      setAspectRatio: function setAspectRatio2(aspectRatio) {
        var options = this.options;
        if (!this.disabled && !isUndefined(aspectRatio)) {
          options.aspectRatio = Math.max(0, aspectRatio) || NaN;
          if (this.ready) {
            this.initCropBox();
            if (this.cropped) {
              this.renderCropBox();
            }
          }
        }
        return this;
      },
      /**
       * Change the drag mode.
       * @param {string} mode - The new drag mode.
       * @returns {Cropper} this
       */
      setDragMode: function setDragMode2(mode) {
        var options = this.options, dragBox = this.dragBox, face = this.face;
        if (this.ready && !this.disabled) {
          var croppable = mode === DRAG_MODE_CROP;
          var movable = options.movable && mode === DRAG_MODE_MOVE;
          mode = croppable || movable ? mode : DRAG_MODE_NONE;
          options.dragMode = mode;
          setData2(dragBox, DATA_ACTION, mode);
          toggleClass(dragBox, CLASS_CROP, croppable);
          toggleClass(dragBox, CLASS_MOVE, movable);
          if (!options.cropBoxMovable) {
            setData2(face, DATA_ACTION, mode);
            toggleClass(face, CLASS_CROP, croppable);
            toggleClass(face, CLASS_MOVE, movable);
          }
        }
        return this;
      }
    };
    var AnotherCropper = WINDOW.Cropper;
    var Cropper = /* @__PURE__ */ function() {
      function Cropper2(element) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, Cropper2);
        if (!element || !REGEXP_TAG_NAME.test(element.tagName)) {
          throw new Error("The first argument is required and must be an <img> or <canvas> element.");
        }
        this.element = element;
        this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
        this.cropped = false;
        this.disabled = false;
        this.pointers = {};
        this.ready = false;
        this.reloading = false;
        this.replaced = false;
        this.sized = false;
        this.sizing = false;
        this.init();
      }
      _createClass(Cropper2, [{
        key: "init",
        value: function init2() {
          var element = this.element;
          var tagName = element.tagName.toLowerCase();
          var url;
          if (element[NAMESPACE]) {
            return;
          }
          element[NAMESPACE] = this;
          if (tagName === "img") {
            this.isImg = true;
            url = element.getAttribute("src") || "";
            this.originalUrl = url;
            if (!url) {
              return;
            }
            url = element.src;
          } else if (tagName === "canvas" && window.HTMLCanvasElement) {
            url = element.toDataURL();
          }
          this.load(url);
        }
      }, {
        key: "load",
        value: function load(url) {
          var _this = this;
          if (!url) {
            return;
          }
          this.url = url;
          this.imageData = {};
          var element = this.element, options = this.options;
          if (!options.rotatable && !options.scalable) {
            options.checkOrientation = false;
          }
          if (!options.checkOrientation || !window.ArrayBuffer) {
            this.clone();
            return;
          }
          if (REGEXP_DATA_URL.test(url)) {
            if (REGEXP_DATA_URL_JPEG.test(url)) {
              this.read(dataURLToArrayBuffer(url));
            } else {
              this.clone();
            }
            return;
          }
          var xhr = new XMLHttpRequest();
          var clone = this.clone.bind(this);
          this.reloading = true;
          this.xhr = xhr;
          xhr.onabort = clone;
          xhr.onerror = clone;
          xhr.ontimeout = clone;
          xhr.onprogress = function() {
            if (xhr.getResponseHeader("content-type") !== MIME_TYPE_JPEG) {
              xhr.abort();
            }
          };
          xhr.onload = function() {
            _this.read(xhr.response);
          };
          xhr.onloadend = function() {
            _this.reloading = false;
            _this.xhr = null;
          };
          if (options.checkCrossOrigin && isCrossOriginURL(url) && element.crossOrigin) {
            url = addTimestamp(url);
          }
          xhr.open("GET", url, true);
          xhr.responseType = "arraybuffer";
          xhr.withCredentials = element.crossOrigin === "use-credentials";
          xhr.send();
        }
      }, {
        key: "read",
        value: function read(arrayBuffer) {
          var options = this.options, imageData = this.imageData;
          var orientation = resetAndGetOrientation(arrayBuffer);
          var rotate2 = 0;
          var scaleX2 = 1;
          var scaleY2 = 1;
          if (orientation > 1) {
            this.url = arrayBufferToDataURL(arrayBuffer, MIME_TYPE_JPEG);
            var _parseOrientation = parseOrientation(orientation);
            rotate2 = _parseOrientation.rotate;
            scaleX2 = _parseOrientation.scaleX;
            scaleY2 = _parseOrientation.scaleY;
          }
          if (options.rotatable) {
            imageData.rotate = rotate2;
          }
          if (options.scalable) {
            imageData.scaleX = scaleX2;
            imageData.scaleY = scaleY2;
          }
          this.clone();
        }
      }, {
        key: "clone",
        value: function clone() {
          var element = this.element, url = this.url;
          var crossOrigin = element.crossOrigin;
          var crossOriginUrl = url;
          if (this.options.checkCrossOrigin && isCrossOriginURL(url)) {
            if (!crossOrigin) {
              crossOrigin = "anonymous";
            }
            crossOriginUrl = addTimestamp(url);
          }
          this.crossOrigin = crossOrigin;
          this.crossOriginUrl = crossOriginUrl;
          var image = document.createElement("img");
          if (crossOrigin) {
            image.crossOrigin = crossOrigin;
          }
          image.src = crossOriginUrl || url;
          image.alt = element.alt || "The image to crop";
          this.image = image;
          image.onload = this.start.bind(this);
          image.onerror = this.stop.bind(this);
          addClass(image, CLASS_HIDE);
          element.parentNode.insertBefore(image, element.nextSibling);
        }
      }, {
        key: "start",
        value: function start2() {
          var _this2 = this;
          var image = this.image;
          image.onload = null;
          image.onerror = null;
          this.sizing = true;
          var isIOSWebKit = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent);
          var done = function done2(naturalWidth, naturalHeight) {
            assign(_this2.imageData, {
              naturalWidth,
              naturalHeight,
              aspectRatio: naturalWidth / naturalHeight
            });
            _this2.initialImageData = assign({}, _this2.imageData);
            _this2.sizing = false;
            _this2.sized = true;
            _this2.build();
          };
          if (image.naturalWidth && !isIOSWebKit) {
            done(image.naturalWidth, image.naturalHeight);
            return;
          }
          var sizingImage = document.createElement("img");
          var body = document.body || document.documentElement;
          this.sizingImage = sizingImage;
          sizingImage.onload = function() {
            done(sizingImage.width, sizingImage.height);
            if (!isIOSWebKit) {
              body.removeChild(sizingImage);
            }
          };
          sizingImage.src = image.src;
          if (!isIOSWebKit) {
            sizingImage.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;";
            body.appendChild(sizingImage);
          }
        }
      }, {
        key: "stop",
        value: function stop() {
          var image = this.image;
          image.onload = null;
          image.onerror = null;
          image.parentNode.removeChild(image);
          this.image = null;
        }
      }, {
        key: "build",
        value: function build() {
          if (!this.sized || this.ready) {
            return;
          }
          var element = this.element, options = this.options, image = this.image;
          var container = element.parentNode;
          var template = document.createElement("div");
          template.innerHTML = TEMPLATE;
          var cropper2 = template.querySelector(".".concat(NAMESPACE, "-container"));
          var canvas = cropper2.querySelector(".".concat(NAMESPACE, "-canvas"));
          var dragBox = cropper2.querySelector(".".concat(NAMESPACE, "-drag-box"));
          var cropBox = cropper2.querySelector(".".concat(NAMESPACE, "-crop-box"));
          var face = cropBox.querySelector(".".concat(NAMESPACE, "-face"));
          this.container = container;
          this.cropper = cropper2;
          this.canvas = canvas;
          this.dragBox = dragBox;
          this.cropBox = cropBox;
          this.viewBox = cropper2.querySelector(".".concat(NAMESPACE, "-view-box"));
          this.face = face;
          canvas.appendChild(image);
          addClass(element, CLASS_HIDDEN);
          container.insertBefore(cropper2, element.nextSibling);
          removeClass(image, CLASS_HIDE);
          this.initPreview();
          this.bind();
          options.initialAspectRatio = Math.max(0, options.initialAspectRatio) || NaN;
          options.aspectRatio = Math.max(0, options.aspectRatio) || NaN;
          options.viewMode = Math.max(0, Math.min(3, Math.round(options.viewMode))) || 0;
          addClass(cropBox, CLASS_HIDDEN);
          if (!options.guides) {
            addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN);
          }
          if (!options.center) {
            addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN);
          }
          if (options.background) {
            addClass(cropper2, "".concat(NAMESPACE, "-bg"));
          }
          if (!options.highlight) {
            addClass(face, CLASS_INVISIBLE);
          }
          if (options.cropBoxMovable) {
            addClass(face, CLASS_MOVE);
            setData2(face, DATA_ACTION, ACTION_ALL);
          }
          if (!options.cropBoxResizable) {
            addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN);
            addClass(cropBox.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN);
          }
          this.render();
          this.ready = true;
          this.setDragMode(options.dragMode);
          if (options.autoCrop) {
            this.crop();
          }
          this.setData(options.data);
          if (isFunction(options.ready)) {
            addListener(element, EVENT_READY, options.ready, {
              once: true
            });
          }
          dispatchEvent2(element, EVENT_READY);
        }
      }, {
        key: "unbuild",
        value: function unbuild() {
          if (!this.ready) {
            return;
          }
          this.ready = false;
          this.unbind();
          this.resetPreview();
          var parentNode = this.cropper.parentNode;
          if (parentNode) {
            parentNode.removeChild(this.cropper);
          }
          removeClass(this.element, CLASS_HIDDEN);
        }
      }, {
        key: "uncreate",
        value: function uncreate() {
          if (this.ready) {
            this.unbuild();
            this.ready = false;
            this.cropped = false;
          } else if (this.sizing) {
            this.sizingImage.onload = null;
            this.sizing = false;
            this.sized = false;
          } else if (this.reloading) {
            this.xhr.onabort = null;
            this.xhr.abort();
          } else if (this.image) {
            this.stop();
          }
        }
        /**
         * Get the no conflict cropper class.
         * @returns {Cropper} The cropper class.
         */
      }], [{
        key: "noConflict",
        value: function noConflict() {
          window.Cropper = AnotherCropper;
          return Cropper2;
        }
        /**
         * Change the default options.
         * @param {Object} options - The new default options.
         */
      }, {
        key: "setDefaults",
        value: function setDefaults(options) {
          assign(DEFAULTS, isPlainObject(options) && options);
        }
      }]);
      return Cropper2;
    }();
    assign(Cropper.prototype, render82, preview, events, handlers, change, methods);
    return Cropper;
  });
})(cropper);
var cropperExports = cropper.exports;
Object.defineProperty(VueCropper, "__esModule", {
  value: true
});
var _cropperjs = cropperExports;
var _cropperjs2 = _interopRequireDefault(_cropperjs);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function _objectWithoutProperties(obj, keys) {
  var target = {};
  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }
  return target;
}
var previewPropType = typeof window === "undefined" ? [String, Array] : [String, Array, Element, NodeList];
var _default = VueCropper.default = {
  render: function render48(h) {
    var crossorigin = this.crossorigin || void 0;
    return h("div", { style: this.containerStyle }, [h("img", {
      ref: "img",
      attrs: {
        src: this.src,
        alt: this.alt || "image",
        style: "max-width: 100%",
        crossorigin
      },
      on: this.$listeners,
      style: this.imgStyle
    })]);
  },
  props: {
    containerStyle: Object,
    src: {
      type: String,
      default: ""
    },
    alt: String,
    imgStyle: Object,
    viewMode: Number,
    dragMode: String,
    initialAspectRatio: Number,
    aspectRatio: Number,
    data: Object,
    preview: previewPropType,
    responsive: {
      type: Boolean,
      default: true
    },
    restore: {
      type: Boolean,
      default: true
    },
    checkCrossOrigin: {
      type: Boolean,
      default: true
    },
    checkOrientation: {
      type: Boolean,
      default: true
    },
    crossorigin: {
      type: String
    },
    modal: {
      type: Boolean,
      default: true
    },
    guides: {
      type: Boolean,
      default: true
    },
    center: {
      type: Boolean,
      default: true
    },
    highlight: {
      type: Boolean,
      default: true
    },
    background: {
      type: Boolean,
      default: true
    },
    autoCrop: {
      type: Boolean,
      default: true
    },
    autoCropArea: Number,
    movable: {
      type: Boolean,
      default: true
    },
    rotatable: {
      type: Boolean,
      default: true
    },
    scalable: {
      type: Boolean,
      default: true
    },
    zoomable: {
      type: Boolean,
      default: true
    },
    zoomOnTouch: {
      type: Boolean,
      default: true
    },
    zoomOnWheel: {
      type: Boolean,
      default: true
    },
    wheelZoomRatio: Number,
    cropBoxMovable: {
      type: Boolean,
      default: true
    },
    cropBoxResizable: {
      type: Boolean,
      default: true
    },
    toggleDragModeOnDblclick: {
      type: Boolean,
      default: true
    },
    minCanvasWidth: Number,
    minCanvasHeight: Number,
    minCropBoxWidth: Number,
    minCropBoxHeight: Number,
    minContainerWidth: Number,
    minContainerHeight: Number,
    ready: Function,
    cropstart: Function,
    cropmove: Function,
    cropend: Function,
    crop: Function,
    zoom: Function
  },
  mounted: function mounted() {
    var _$options$props = this.$options.props;
    _$options$props.containerStyle;
    _$options$props.src;
    _$options$props.alt;
    _$options$props.imgStyle;
    var data = _objectWithoutProperties(_$options$props, ["containerStyle", "src", "alt", "imgStyle"]);
    var props = {};
    for (var key in data) {
      if (this[key] !== void 0) {
        props[key] = this[key];
      }
    }
    this.cropper = new _cropperjs2.default(this.$refs.img, props);
  },
  methods: {
    reset: function reset() {
      return this.cropper.reset();
    },
    clear: function clear() {
      return this.cropper.clear();
    },
    initCrop: function initCrop() {
      return this.cropper.crop();
    },
    replace: function replace(url) {
      var onlyColorChanged = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      return this.cropper.replace(url, onlyColorChanged);
    },
    enable: function enable() {
      return this.cropper.enable();
    },
    disable: function disable() {
      return this.cropper.disable();
    },
    destroy: function destroy() {
      return this.cropper.destroy();
    },
    move: function move(offsetX, offsetY) {
      return this.cropper.move(offsetX, offsetY);
    },
    moveTo: function moveTo(x2) {
      var y2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : x2;
      return this.cropper.moveTo(x2, y2);
    },
    relativeZoom: function relativeZoom(ratio, _originalEvent) {
      return this.cropper.zoom(ratio, _originalEvent);
    },
    zoomTo: function zoomTo(ratio, _originalEvent) {
      return this.cropper.zoomTo(ratio, _originalEvent);
    },
    rotate: function rotate(degree) {
      return this.cropper.rotate(degree);
    },
    rotateTo: function rotateTo(degree) {
      return this.cropper.rotateTo(degree);
    },
    scaleX: function scaleX(_scaleX) {
      return this.cropper.scaleX(_scaleX);
    },
    scaleY: function scaleY(_scaleY) {
      return this.cropper.scaleY(_scaleY);
    },
    scale: function scale(scaleX2) {
      var scaleY2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : scaleX2;
      return this.cropper.scale(scaleX2, scaleY2);
    },
    getData: function getData() {
      var rounded = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      return this.cropper.getData(rounded);
    },
    setData: function setData(data) {
      return this.cropper.setData(data);
    },
    getContainerData: function getContainerData() {
      return this.cropper.getContainerData();
    },
    getImageData: function getImageData() {
      return this.cropper.getImageData();
    },
    getCanvasData: function getCanvasData() {
      return this.cropper.getCanvasData();
    },
    setCanvasData: function setCanvasData(data) {
      return this.cropper.setCanvasData(data);
    },
    getCropBoxData: function getCropBoxData() {
      return this.cropper.getCropBoxData();
    },
    setCropBoxData: function setCropBoxData(data) {
      return this.cropper.setCropBoxData(data);
    },
    getCroppedCanvas: function getCroppedCanvas() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.cropper.getCroppedCanvas(options);
    },
    setAspectRatio: function setAspectRatio(aspectRatio) {
      return this.cropper.setAspectRatio(aspectRatio);
    },
    setDragMode: function setDragMode(mode) {
      return this.cropper.setDragMode(mode);
    }
  }
};
const supportedNetworks = loadState("contacts", "supportedNetworks");
const _sfc_main$w = {
  name: "ContactDetailsAvatar",
  components: {
    ActionButton: NcActionButton,
    ActionLink: NcActionLink,
    Actions: NcActions,
    Avatar: NcAvatar,
    IconCloudDownload,
    IconDownload,
    IconDelete,
    IconUpload,
    IconFolder,
    IconImage,
    NcButton,
    VueCropper: _default,
    NcModal
  },
  props: {
    contact: {
      type: Object,
      required: true
    },
    isReadOnly: {
      type: Boolean,
      required: true
    },
    reloadBus: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      opened: false,
      loading: false,
      photoUrl: void 0,
      root: U(`dav/files/${getCurrentUser().uid}`),
      showCropper: false,
      cropperOptions: {
        aspectRatio: 1 / 1,
        viewMode: 3,
        guides: false,
        center: false,
        highlight: false,
        autoCropArea: 1,
        dragMode: "move",
        minContainerWidth: 100,
        minContainerHeight: 100
      }
    };
  },
  computed: {
    supportedSocial() {
      const emails = this.contact.vCard.getAllProperties("email");
      const availableSocial = this.contact.vCard.getAllProperties("x-socialprofile").map((a) => a.jCal[1].type.toString().toLowerCase());
      const availableMessenger = this.contact.vCard.getAllProperties("impp").map((a) => a.jCal[1].type.toString().toLowerCase());
      const available = [].concat(availableSocial, availableMessenger);
      const supported = supportedNetworks.map((v2) => v2.toLowerCase());
      if (emails.length) {
        available.push("gravatar");
      }
      return supported.filter((i) => available.includes(i)).map((j) => this.capitalize(j));
    }
  },
  watch: {
    async contact() {
      await this.loadPhotoUrl();
    }
  },
  async mounted() {
    await this.loadPhotoUrl();
  },
  methods: {
    onLoad(...args) {
      console.debug(...args);
    },
    /**
     * Checks the selected image for mimetype
     * and open the cropper if valid, else show error
     *
     * @param {Buffer} data the image
     * @return {boolean}
     */
    async processPicture(data) {
      const type = this.getMimetype(data);
      if (!type.startsWith("image/")) {
        showError(t("contacts", "Please select a valid format"));
        return false;
      }
      if (type === "image/svg") {
        const imageSvg = atob(data.toString("base64"));
        const cleanSvg = await _default$1(imageSvg);
        if (!cleanSvg) {
          throw new Error("Unsafe svg image", imageSvg);
        }
      }
      this.openCropper(data, type);
      return true;
    },
    /**
     * Open the cropper-modal with the provided data
     *
     * @param {Buffer} data the image
     * @param {string} type of the image
     */
    openCropper(data, type) {
      const ccc = `data:${type};base64,${data.toString("base64")}`;
      this.$refs.cropper.replace(ccc);
      this.showCropper = true;
    },
    /**
     * Handle the uploaded file
     *
     * @param {object} event the event object containing the image
     */
    handleUploadedFile(event) {
      if (event.target.files && !this.loading) {
        this.closeMenu();
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = (e2) => {
          try {
            if (typeof e2.target.result === "object") {
              const data = Buffer.from(e2.target.result, "binary");
              if (this.processPicture(data)) {
                return;
              }
              throw new Error("Wrong image mimetype");
            }
          } catch (error) {
            console.error(error);
            showError(t("contacts", "Invalid image"));
          } finally {
            this.resetPicker();
          }
        };
        reader.readAsArrayBuffer(file);
      }
    },
    /**
     * Reset image pciker input
     */
    resetPicker() {
      this.$refs.uploadInput.value = "";
      this.loading = false;
    },
    /**
     * Return the word with (only) the first letter capitalized
     *
     * @param {string} word the word to handle
     * @return {string} the word with the first letter capitalized
     */
    capitalize(word) {
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    },
    /**
     * Return the mimetype based on the first 4 byte
     *
     * @param {Uint8Array} uint content
     * @return {string} the mimetype
     */
    getMimetype(uint) {
      const bytes = [];
      uint.slice(0, 12).forEach((byte) => {
        bytes.push(byte.toString(16).padStart(2, "0"));
      });
      const hex2 = bytes.join("").toUpperCase();
      const nextcloudMajorVersion = parseInt(window.OC.config.version.split(".")[0]);
      if (nextcloudMajorVersion >= 31 && hex2.slice(0, 8) === "52494646" && hex2.slice(16, 24) === "57454250") {
        return "image/webp";
      }
      if (nextcloudMajorVersion >= 32 && hex2.slice(8, 24) === "6674797061766966") {
        return "image/avif";
      }
      switch (hex2.slice(0, 8)) {
        case "89504E47":
          return "image/png";
        case "47494638":
          return "image/gif";
        case "3C3F786D":
        case "3C737667":
          return "image/svg+xml";
        case "FFD8FFDB":
        case "FFD8FFE0":
        case "FFD8FFE1":
          return "image/jpeg";
        default:
          return "application/octet-stream";
      }
    },
    /**
     * Update the contact photo
     *
     * @param {string} data the photo as base64 binary string
     * @param {string} type mimetype
     */
    async setPhoto(data, type) {
      if (this.contact.photo) {
        this.contact.vCard.addPropertyWithValue("photo", "");
      }
      if (this.contact.version === "3.0") {
        this.contact.photo = data;
        const photo = this.contact.vCard.getFirstProperty("photo");
        photo.setParameter("encoding", "b");
        if (type) {
          photo.setParameter("type", type.split("/").pop());
        }
      } else {
        this.contact.photo = `data:${type};base64,${data}`;
      }
      await this.$store.dispatch("updateContact", this.contact);
      await this.loadPhotoUrl();
      await this.reloadBus.emit("reload-avatar", this.contact.key);
      this.loading = false;
    },
    async loadPhotoUrl() {
      this.photoUrl = void 0;
      if (this.contact.photo) {
        const photoUrl = await this.contact.getPhotoUrl();
        if (!photoUrl) {
          console.warn("contact has an invalid photo");
          return;
        }
        this.photoUrl = photoUrl;
      } else if (this.contact.url) {
        this.photoUrl = `${this.contact.url}?photo`;
      }
    },
    /**
     * Save the cropped image
     */
    saveAvatar() {
      this.showCropper = false;
      this.loading = true;
      this.$refs.cropper.getCroppedCanvas({
        minWidth: 16,
        minHeight: 16,
        maxWidth: 512,
        maxHeight: 512
      }).toBlob(async (blob) => {
        if (blob === null) {
          showError(t("contacts", "Error cropping picture"));
          this.cancel();
          return;
        }
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = () => {
          const base64data = reader.result;
          this.setPhoto(base64data.split(",").pop(), blob.type);
        };
      });
    },
    /**
     * Remove the contact's picture
     */
    removePhoto() {
      this.contact.vCard.removeAllProperties("photo");
      this.$store.dispatch("updateContact", this.contact);
      this.photoUrl = void 0;
      this.reloadBus.emit("delete-avatar", this.contact.key);
    },
    /**
     * Cancel cropping
     */
    cancel() {
      this.showCropper = false;
      this.loading = false;
    },
    /**
     * Picker handlers Upload
     */
    selectFileInput() {
      if (!this.loading) {
        this.$refs.uploadInput.click();
      }
    },
    /**
     * Picker handlers from Files
     */
    async selectFilePicker() {
      if (!this.loading) {
        this.closeMenu();
        const picker2 = getFilePickerBuilder(t("contacts", "Pick an avatar")).setMimeTypeFilter([
          "image/png",
          "image/jpeg",
          "image/gif",
          "image/x-xbitmap",
          "image/bmp",
          "image/svg+xml"
        ]).addButton({
          label: t("calendar", "Pick"),
          type: "primary",
          callback: (nodes) => logger$1.debug("Picked avatar", { nodes })
        }).build();
        const file = await picker2.pick();
        if (file) {
          this.loading = true;
          try {
            const response = await cancelableClient.get(`${this.root}${file}`, {
              responseType: "arraybuffer"
            });
            const data = Buffer.from(response.data, "binary");
            this.processPicture(data);
          } catch (error) {
            showError(t("contacts", "Error while processing the picture."));
            console.error(error);
            this.loading = false;
          } finally {
            this.resetPicker();
          }
        }
      }
    },
    /**
     * Downloads the Avatar from social media
     *
     * @param {string} network the social network to use (or 'any' for first match)
     */
    async getSocialAvatar(network) {
      if (!this.loading) {
        this.loading = true;
        try {
          const response = await cancelableClient.put(_("/apps/contacts/api/v1/social/avatar/{network}/{id}/{uid}", {
            network: network.toLowerCase(),
            id: this.contact.addressbook.id,
            uid: this.contact.uid
          }));
          if (response?.status !== 200) {
            throw new URIError("Download of social profile avatar failed");
          }
          await this.$store.dispatch("fetchFullContact", { contact: this.contact, forceReFetch: true });
          const contact = this.$store.getters.getContact(this.contact.key);
          await this.$emit("update-local-contact", contact);
          await this.loadPhotoUrl();
          await this.reloadBus.emit("reload-avatar", this.contact.key);
          showSuccess(t("contacts", "Avatar downloaded from social network"));
        } catch (error) {
          if (error?.response?.status === 304) {
            showInfo(t("contacts", "Avatar already up to date"));
          } else {
            showError(t("contacts", "Avatar download failed"));
            console.debug(error);
          }
        }
      }
      this.loading = false;
    },
    closeMenu() {
      this.opened = false;
    }
  }
};
var _sfc_render$w = function render49() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { directives: [{ name: "click-outside", rawName: "v-click-outside", value: _vm.closeMenu, expression: "closeMenu" }], staticClass: "contact-header-avatar__wrapper" }, [_c("input", { ref: "uploadInput", staticClass: "hidden", attrs: { "id": "contact-avatar-upload", "type": "file", "accept": "image/*" }, on: { "change": _vm.handleUploadedFile } }), _c("Avatar", { staticClass: "contact-header-avatar__photo", attrs: { "disable-tooltip": true, "display-name": _vm.contact.displayName, "is-no-user": true, "size": 75, "url": _vm.photoUrl } }), _c("NcModal", { attrs: { "show": _vm.showCropper, "size": "small" }, on: { "update:show": function($event) {
    _vm.showCropper = $event;
  }, "close": _vm.cancel } }, [_c("div", { staticClass: "avatar__container" }, [_c("h2", [_vm._v(_vm._s(_vm.t("contacts", "Crop contact photo")))]), _c("VueCropper", _vm._b({ ref: "cropper", staticClass: "avatar__cropper" }, "VueCropper", _vm.cropperOptions, false)), _c("div", { staticClass: "avatar__cropper-buttons" }, [_c("NcButton", { attrs: { "type": "tertiary" }, on: { "click": _vm.cancel } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Cancel")) + " ")]), _c("NcButton", { attrs: { "type": "primary" }, on: { "click": _vm.saveAvatar } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Save")) + " ")])], 1)], 1)]), !_vm.isReadOnly ? _c("Actions", { staticClass: "contact-header-avatar__menu", attrs: { "force-menu": true, "open": _vm.opened }, on: { "update:open": function($event) {
    _vm.opened = $event;
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconImage", { attrs: { "size": 20, "fill-color": "#fff" } })];
  }, proxy: true }], null, false, 1819936392) }, [_c("ActionButton", { on: { "click": function($event) {
    $event.stopPropagation();
    $event.preventDefault();
    return _vm.selectFileInput.apply(null, arguments);
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconUpload", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 337456192) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Upload a new picture")) + " ")]), _c("ActionButton", { on: { "click": _vm.selectFilePicker }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconFolder", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2686820117) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Choose from Files")) + " ")]), _vm._l(_vm.supportedSocial, function(network) {
    return _c("ActionButton", { key: network, on: { "click": function($event) {
      return _vm.getSocialAvatar(network);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconCloudDownload", { attrs: { "size": 20 } })];
    }, proxy: true }], null, true) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Get from " + network)) + " ")]);
  }), _vm.contact.photo ? [_c("ActionLink", { attrs: { "href": `${_vm.contact.url}?photo`, "target": "_blank" }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconDownload", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2487097783) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Download picture")) + " ")]), _c("ActionButton", { on: { "click": _vm.removePhoto }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconDelete", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 881161434) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Delete picture")) + " ")])] : _vm._e()], 2) : _vm._e()], 1);
};
var _sfc_staticRenderFns$w = [];
var __component__$w = /* @__PURE__ */ normalizeComponent(
  _sfc_main$w,
  _sfc_render$w,
  _sfc_staticRenderFns$w,
  false,
  null,
  "5a5f05ef"
);
const ContactAvatar = __component__$w.exports;
const defaultAlphabetIndexMap = [];
function isNumberCode(code) {
  return code >= 48 && code <= 57;
}
function naturalCompare(a, b, opts) {
  if (typeof a !== "string") {
    throw new TypeError(`The first argument must be a string. Received type '${typeof a}'`);
  }
  if (typeof b !== "string") {
    throw new TypeError(`The second argument must be a string. Received type '${typeof b}'`);
  }
  const lengthA = a.length;
  const lengthB = b.length;
  let indexA = 0;
  let indexB = 0;
  let alphabetIndexMap = defaultAlphabetIndexMap;
  let firstDifferenceInLeadingZeros = 0;
  if (opts) {
    if (opts.caseInsensitive) {
      a = a.toLowerCase();
      b = b.toLowerCase();
    }
    if (opts.alphabet) {
      alphabetIndexMap = buildAlphabetIndexMap(opts.alphabet);
    }
  }
  while (indexA < lengthA && indexB < lengthB) {
    let charCodeA = a.charCodeAt(indexA);
    let charCodeB = b.charCodeAt(indexB);
    if (isNumberCode(charCodeA)) {
      if (!isNumberCode(charCodeB)) {
        return charCodeA - charCodeB;
      }
      let numStartA = indexA;
      let numStartB = indexB;
      while (charCodeA === 48 && ++numStartA < lengthA) {
        charCodeA = a.charCodeAt(numStartA);
      }
      while (charCodeB === 48 && ++numStartB < lengthB) {
        charCodeB = b.charCodeAt(numStartB);
      }
      if (numStartA !== numStartB && firstDifferenceInLeadingZeros === 0) {
        firstDifferenceInLeadingZeros = numStartA - numStartB;
      }
      let numEndA = numStartA;
      let numEndB = numStartB;
      while (numEndA < lengthA && isNumberCode(a.charCodeAt(numEndA))) {
        ++numEndA;
      }
      while (numEndB < lengthB && isNumberCode(b.charCodeAt(numEndB))) {
        ++numEndB;
      }
      let difference = numEndA - numStartA - numEndB + numStartB;
      if (difference !== 0) {
        return difference;
      }
      while (numStartA < numEndA) {
        difference = a.charCodeAt(numStartA++) - b.charCodeAt(numStartB++);
        if (difference !== 0) {
          return difference;
        }
      }
      indexA = numEndA;
      indexB = numEndB;
      continue;
    }
    if (charCodeA !== charCodeB) {
      if (charCodeA < alphabetIndexMap.length && charCodeB < alphabetIndexMap.length && alphabetIndexMap[charCodeA] !== -1 && alphabetIndexMap[charCodeB] !== -1) {
        return alphabetIndexMap[charCodeA] - alphabetIndexMap[charCodeB];
      }
      return charCodeA - charCodeB;
    }
    ++indexA;
    ++indexB;
  }
  if (indexA < lengthA) {
    return 1;
  }
  if (indexB < lengthB) {
    return -1;
  }
  return firstDifferenceInLeadingZeros;
}
const alphabetIndexMapCache = {};
function buildAlphabetIndexMap(alphabet) {
  const existingMap = alphabetIndexMapCache[alphabet];
  if (existingMap !== void 0) {
    return existingMap;
  }
  const indexMap = [];
  const maxCharCode = alphabet.split("").reduce((maxCode, char) => {
    return Math.max(maxCode, char.charCodeAt(0));
  }, 0);
  for (let i = 0; i <= maxCharCode; i++) {
    indexMap.push(-1);
  }
  for (let i = 0; i < alphabet.length; i++) {
    indexMap[alphabet.charCodeAt(i)] = i;
  }
  alphabetIndexMapCache[alphabet] = indexMap;
  return indexMap;
}
var naturalCompare_1 = naturalCompare;
const naturalCompare$1 = /* @__PURE__ */ getDefaultExportFromCjs(naturalCompare_1);
const _sfc_main$v = {
  name: "PropertyGroups",
  components: {
    PropertyTitle,
    NcSelect
  },
  props: {
    propModel: {
      type: Object,
      default: () => {
      },
      required: true
    },
    value: {
      type: Array,
      default: () => [],
      required: true
    },
    contact: {
      type: Contact,
      default: null,
      required: true
    },
    // Is it read-only?
    isReadOnly: {
      type: Boolean,
      required: true
    }
  },
  data() {
    return {
      localValue: [...this.value].sort()
    };
  },
  computed: {
    showAsText() {
      return this.isReadOnly && this.localValue.length <= 1;
    },
    showProperty() {
      return this.isReadOnly && this.localValue.length > 0 || !this.isReadOnly;
    },
    groups() {
      return this.$store.getters.getGroups.slice(0).map((group) => group.name).sort((a, b) => naturalCompare$1(a, b, { caseInsensitive: true }));
    },
    /**
     * Format array of groups objects to a string for the popup
     * Based on the ultiselect limit
     *
     * @return {string} the additional groups
     */
    formatGroupsTitle() {
      return this.localValue.slice(3).join(", ");
    }
  },
  watch: {
    /**
     * Since we're updating a local data based on the value prop,
     * we need to make sure to update the local data on pop change
     * TODO: check if this create performance drop
     */
    value() {
      this.localValue = this.value;
    },
    selectType() {
      this.localType = this.selectType;
    }
  },
  methods: {
    /**
     * Send update event to parent
     */
    updateValue() {
      this.$emit("update:value", this.localValue);
    }
  }
};
var _sfc_render$v = function render50() {
  var _vm = this, _c = _vm._self._c;
  return _vm.propModel && _vm.showProperty ? _c("div", { staticClass: "property" }, [_c("PropertyTitle", { attrs: { "icon": "icon-contacts-dark", "readable-name": _vm.t("contacts", "Contact groups"), "is-read-only": _vm.isReadOnly } }), _c("div", { staticClass: "property__row" }, [_c("div", { staticClass: "property__label" }, [_c("span", [_vm._v(_vm._s(_vm.propModel.readableName))])]), _c("div", { staticClass: "property__value" }, [!_vm.isReadOnly ? _c("NcSelect", { attrs: { "options": _vm.groups, "no-wrap": true, "placeholder": _vm.t("contacts", "Add contact in group"), "multiple": true, "close-on-select": false, "clearable": true, "deselect-from-dropdown": true, "taggable": true, "tag-placeholder": "create" }, on: { "option:deselected": _vm.updateValue, "close": _vm.updateValue }, scopedSlots: _vm._u([{ key: "limit", fn: function() {
    return [_c("span", { directives: [{ name: "tooltip", rawName: "v-tooltip.auto", value: _vm.formatGroupsTitle, expression: "formatGroupsTitle", modifiers: { "auto": true } }], staticClass: "multiselect__limit" }, [_vm._v(" +" + _vm._s(_vm.localValue.length - 3) + " ")])];
  }, proxy: true }, { key: "no-options", fn: function() {
    return [_c("span", [_vm._v(_vm._s(_vm.t("contacts", "No results")))])];
  }, proxy: true }], null, false, 2766193613), model: { value: _vm.localValue, callback: function($$v) {
    _vm.localValue = $$v;
  }, expression: "localValue" } }) : _c("div", [_vm.localValue.length === 0 ? _c("span", [_vm._v(_vm._s(_vm.t("contacts", "None")))]) : _c("div", { staticClass: "group__list" }, _vm._l(_vm.localValue, function(group, index2) {
    return _c("span", { key: index2 }, [_vm._v(" " + _vm._s(group) + _vm._s(index2 === _vm.localValue.length - 1 ? "" : ",") + " ")]);
  }), 0)])], 1), _c("div", { staticClass: "property__actions" })])], 1) : _vm._e();
};
var _sfc_staticRenderFns$v = [];
var __component__$v = /* @__PURE__ */ normalizeComponent(
  _sfc_main$v,
  _sfc_render$v,
  _sfc_staticRenderFns$v,
  false,
  null,
  "3ecbedb4"
);
const PropertyGroups = __component__$v.exports;
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var momentWithLocales = { exports: {} };
(function(module2, exports) {
  (function(global, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    var hookCallback;
    function hooks2() {
      return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
      hookCallback = callback;
    }
    function isArray(input) {
      return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
    }
    function isObject(input) {
      return input != null && Object.prototype.toString.call(input) === "[object Object]";
    }
    function hasOwnProp(a, b) {
      return Object.prototype.hasOwnProperty.call(a, b);
    }
    function isObjectEmpty(obj) {
      if (Object.getOwnPropertyNames) {
        return Object.getOwnPropertyNames(obj).length === 0;
      } else {
        var k;
        for (k in obj) {
          if (hasOwnProp(obj, k)) {
            return false;
          }
        }
        return true;
      }
    }
    function isUndefined(input) {
      return input === void 0;
    }
    function isNumber(input) {
      return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
    }
    function isDate(input) {
      return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
    }
    function map(arr, fn) {
      var res = [], i, arrLen = arr.length;
      for (i = 0; i < arrLen; ++i) {
        res.push(fn(arr[i], i));
      }
      return res;
    }
    function extend2(a, b) {
      for (var i in b) {
        if (hasOwnProp(b, i)) {
          a[i] = b[i];
        }
      }
      if (hasOwnProp(b, "toString")) {
        a.toString = b.toString;
      }
      if (hasOwnProp(b, "valueOf")) {
        a.valueOf = b.valueOf;
      }
      return a;
    }
    function createUTC(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, true).utc();
    }
    function defaultParsingFlags() {
      return {
        empty: false,
        unusedTokens: [],
        unusedInput: [],
        overflow: -2,
        charsLeftOver: 0,
        nullInput: false,
        invalidEra: null,
        invalidMonth: null,
        invalidFormat: false,
        userInvalidated: false,
        iso: false,
        parsedDateParts: [],
        era: null,
        meridiem: null,
        rfc2822: false,
        weekdayMismatch: false
      };
    }
    function getParsingFlags(m) {
      if (m._pf == null) {
        m._pf = defaultParsingFlags();
      }
      return m._pf;
    }
    var some;
    if (Array.prototype.some) {
      some = Array.prototype.some;
    } else {
      some = function(fun) {
        var t2 = Object(this), len = t2.length >>> 0, i;
        for (i = 0; i < len; i++) {
          if (i in t2 && fun.call(this, t2[i], i, t2)) {
            return true;
          }
        }
        return false;
      };
    }
    function isValid2(m) {
      var flags = null, parsedParts = false, isNowValid = m._d && !isNaN(m._d.getTime());
      if (isNowValid) {
        flags = getParsingFlags(m);
        parsedParts = some.call(flags.parsedDateParts, function(i) {
          return i != null;
        });
        isNowValid = flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
        if (m._strict) {
          isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
        }
      }
      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
      return m._isValid;
    }
    function createInvalid(flags) {
      var m = createUTC(NaN);
      if (flags != null) {
        extend2(getParsingFlags(m), flags);
      } else {
        getParsingFlags(m).userInvalidated = true;
      }
      return m;
    }
    var momentProperties = hooks2.momentProperties = [], updateInProgress = false;
    function copyConfig(to2, from2) {
      var i, prop, val, momentPropertiesLen = momentProperties.length;
      if (!isUndefined(from2._isAMomentObject)) {
        to2._isAMomentObject = from2._isAMomentObject;
      }
      if (!isUndefined(from2._i)) {
        to2._i = from2._i;
      }
      if (!isUndefined(from2._f)) {
        to2._f = from2._f;
      }
      if (!isUndefined(from2._l)) {
        to2._l = from2._l;
      }
      if (!isUndefined(from2._strict)) {
        to2._strict = from2._strict;
      }
      if (!isUndefined(from2._tzm)) {
        to2._tzm = from2._tzm;
      }
      if (!isUndefined(from2._isUTC)) {
        to2._isUTC = from2._isUTC;
      }
      if (!isUndefined(from2._offset)) {
        to2._offset = from2._offset;
      }
      if (!isUndefined(from2._pf)) {
        to2._pf = getParsingFlags(from2);
      }
      if (!isUndefined(from2._locale)) {
        to2._locale = from2._locale;
      }
      if (momentPropertiesLen > 0) {
        for (i = 0; i < momentPropertiesLen; i++) {
          prop = momentProperties[i];
          val = from2[prop];
          if (!isUndefined(val)) {
            to2[prop] = val;
          }
        }
      }
      return to2;
    }
    function Moment(config) {
      copyConfig(this, config);
      this._d = new Date(config._d != null ? config._d.getTime() : NaN);
      if (!this.isValid()) {
        this._d = /* @__PURE__ */ new Date(NaN);
      }
      if (updateInProgress === false) {
        updateInProgress = true;
        hooks2.updateOffset(this);
        updateInProgress = false;
      }
    }
    function isMoment(obj) {
      return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
    }
    function warn(msg) {
      if (hooks2.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
        console.warn("Deprecation warning: " + msg);
      }
    }
    function deprecate(msg, fn) {
      var firstTime = true;
      return extend2(function() {
        if (hooks2.deprecationHandler != null) {
          hooks2.deprecationHandler(null, msg);
        }
        if (firstTime) {
          var args = [], arg, i, key, argLen = arguments.length;
          for (i = 0; i < argLen; i++) {
            arg = "";
            if (typeof arguments[i] === "object") {
              arg += "\n[" + i + "] ";
              for (key in arguments[0]) {
                if (hasOwnProp(arguments[0], key)) {
                  arg += key + ": " + arguments[0][key] + ", ";
                }
              }
              arg = arg.slice(0, -2);
            } else {
              arg = arguments[i];
            }
            args.push(arg);
          }
          warn(
            msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
          );
          firstTime = false;
        }
        return fn.apply(this, arguments);
      }, fn);
    }
    var deprecations = {};
    function deprecateSimple(name, msg) {
      if (hooks2.deprecationHandler != null) {
        hooks2.deprecationHandler(name, msg);
      }
      if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
      }
    }
    hooks2.suppressDeprecationWarnings = false;
    hooks2.deprecationHandler = null;
    function isFunction(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    function set2(config) {
      var prop, i;
      for (i in config) {
        if (hasOwnProp(config, i)) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this["_" + i] = prop;
          }
        }
      }
      this._config = config;
      this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
      );
    }
    function mergeConfigs(parentConfig, childConfig) {
      var res = extend2({}, parentConfig), prop;
      for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
          if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
            res[prop] = {};
            extend2(res[prop], parentConfig[prop]);
            extend2(res[prop], childConfig[prop]);
          } else if (childConfig[prop] != null) {
            res[prop] = childConfig[prop];
          } else {
            delete res[prop];
          }
        }
      }
      for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
          res[prop] = extend2({}, res[prop]);
        }
      }
      return res;
    }
    function Locale(config) {
      if (config != null) {
        this.set(config);
      }
    }
    var keys;
    if (Object.keys) {
      keys = Object.keys;
    } else {
      keys = function(obj) {
        var i, res = [];
        for (i in obj) {
          if (hasOwnProp(obj, i)) {
            res.push(i);
          }
        }
        return res;
      };
    }
    var defaultCalendar = {
      sameDay: "[Today at] LT",
      nextDay: "[Tomorrow at] LT",
      nextWeek: "dddd [at] LT",
      lastDay: "[Yesterday at] LT",
      lastWeek: "[Last] dddd [at] LT",
      sameElse: "L"
    };
    function calendar(key, mom, now3) {
      var output = this._calendar[key] || this._calendar["sameElse"];
      return isFunction(output) ? output.call(mom, now3) : output;
    }
    function zeroFill(number, targetLength, forceSign) {
      var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign2 = number >= 0;
      return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {};
    function addFormatToken(token2, padded, ordinal2, callback) {
      var func = callback;
      if (typeof callback === "string") {
        func = function() {
          return this[callback]();
        };
      }
      if (token2) {
        formatTokenFunctions[token2] = func;
      }
      if (padded) {
        formatTokenFunctions[padded[0]] = function() {
          return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
      }
      if (ordinal2) {
        formatTokenFunctions[ordinal2] = function() {
          return this.localeData().ordinal(
            func.apply(this, arguments),
            token2
          );
        };
      }
    }
    function removeFormattingTokens(input) {
      if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, "");
      }
      return input.replace(/\\/g, "");
    }
    function makeFormatFunction(format2) {
      var array2 = format2.match(formattingTokens), i, length;
      for (i = 0, length = array2.length; i < length; i++) {
        if (formatTokenFunctions[array2[i]]) {
          array2[i] = formatTokenFunctions[array2[i]];
        } else {
          array2[i] = removeFormattingTokens(array2[i]);
        }
      }
      return function(mom) {
        var output = "", i2;
        for (i2 = 0; i2 < length; i2++) {
          output += isFunction(array2[i2]) ? array2[i2].call(mom, format2) : array2[i2];
        }
        return output;
      };
    }
    function formatMoment(m, format2) {
      if (!m.isValid()) {
        return m.localeData().invalidDate();
      }
      format2 = expandFormat(format2, m.localeData());
      formatFunctions[format2] = formatFunctions[format2] || makeFormatFunction(format2);
      return formatFunctions[format2](m);
    }
    function expandFormat(format2, locale2) {
      var i = 5;
      function replaceLongDateFormatTokens(input) {
        return locale2.longDateFormat(input) || input;
      }
      localFormattingTokens.lastIndex = 0;
      while (i >= 0 && localFormattingTokens.test(format2)) {
        format2 = format2.replace(
          localFormattingTokens,
          replaceLongDateFormatTokens
        );
        localFormattingTokens.lastIndex = 0;
        i -= 1;
      }
      return format2;
    }
    var defaultLongDateFormat = {
      LTS: "h:mm:ss A",
      LT: "h:mm A",
      L: "MM/DD/YYYY",
      LL: "MMMM D, YYYY",
      LLL: "MMMM D, YYYY h:mm A",
      LLLL: "dddd, MMMM D, YYYY h:mm A"
    };
    function longDateFormat(key) {
      var format2 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
      if (format2 || !formatUpper) {
        return format2;
      }
      this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
        if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
          return tok.slice(1);
        }
        return tok;
      }).join("");
      return this._longDateFormat[key];
    }
    var defaultInvalidDate = "Invalid date";
    function invalidDate() {
      return this._invalidDate;
    }
    var defaultOrdinal = "%d", defaultDayOfMonthOrdinalParse = /\d{1,2}/;
    function ordinal(number) {
      return this._ordinal.replace("%d", number);
    }
    var defaultRelativeTime = {
      future: "in %s",
      past: "%s ago",
      s: "a few seconds",
      ss: "%d seconds",
      m: "a minute",
      mm: "%d minutes",
      h: "an hour",
      hh: "%d hours",
      d: "a day",
      dd: "%d days",
      w: "a week",
      ww: "%d weeks",
      M: "a month",
      MM: "%d months",
      y: "a year",
      yy: "%d years"
    };
    function relativeTime(number, withoutSuffix, string, isFuture) {
      var output = this._relativeTime[string];
      return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff2, output) {
      var format2 = this._relativeTime[diff2 > 0 ? "future" : "past"];
      return isFunction(format2) ? format2(output) : format2.replace(/%s/i, output);
    }
    var aliases = {
      D: "date",
      dates: "date",
      date: "date",
      d: "day",
      days: "day",
      day: "day",
      e: "weekday",
      weekdays: "weekday",
      weekday: "weekday",
      E: "isoWeekday",
      isoweekdays: "isoWeekday",
      isoweekday: "isoWeekday",
      DDD: "dayOfYear",
      dayofyears: "dayOfYear",
      dayofyear: "dayOfYear",
      h: "hour",
      hours: "hour",
      hour: "hour",
      ms: "millisecond",
      milliseconds: "millisecond",
      millisecond: "millisecond",
      m: "minute",
      minutes: "minute",
      minute: "minute",
      M: "month",
      months: "month",
      month: "month",
      Q: "quarter",
      quarters: "quarter",
      quarter: "quarter",
      s: "second",
      seconds: "second",
      second: "second",
      gg: "weekYear",
      weekyears: "weekYear",
      weekyear: "weekYear",
      GG: "isoWeekYear",
      isoweekyears: "isoWeekYear",
      isoweekyear: "isoWeekYear",
      w: "week",
      weeks: "week",
      week: "week",
      W: "isoWeek",
      isoweeks: "isoWeek",
      isoweek: "isoWeek",
      y: "year",
      years: "year",
      year: "year"
    };
    function normalizeUnits(units2) {
      return typeof units2 === "string" ? aliases[units2] || aliases[units2.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
      var normalizedInput = {}, normalizedProp, prop;
      for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
          normalizedProp = normalizeUnits(prop);
          if (normalizedProp) {
            normalizedInput[normalizedProp] = inputObject[prop];
          }
        }
      }
      return normalizedInput;
    }
    var priorities = {
      date: 9,
      day: 11,
      weekday: 11,
      isoWeekday: 11,
      dayOfYear: 4,
      hour: 13,
      millisecond: 16,
      minute: 14,
      month: 8,
      quarter: 7,
      second: 15,
      weekYear: 1,
      isoWeekYear: 1,
      week: 5,
      isoWeek: 5,
      year: 1
    };
    function getPrioritizedUnits(unitsObj) {
      var units2 = [], u;
      for (u in unitsObj) {
        if (hasOwnProp(unitsObj, u)) {
          units2.push({ unit: u, priority: priorities[u] });
        }
      }
      units2.sort(function(a, b) {
        return a.priority - b.priority;
      });
      return units2;
    }
    var match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, match1to2NoLeadingZero = /^[1-9]\d?/, match1to2HasZero = /^([1-9]\d|\d)/, regexes;
    regexes = {};
    function addRegexToken(token2, regex, strictRegex) {
      regexes[token2] = isFunction(regex) ? regex : function(isStrict, localeData2) {
        return isStrict && strictRegex ? strictRegex : regex;
      };
    }
    function getParseRegexForToken(token2, config) {
      if (!hasOwnProp(regexes, token2)) {
        return new RegExp(unescapeFormat(token2));
      }
      return regexes[token2](config._strict, config._locale);
    }
    function unescapeFormat(s2) {
      return regexEscape(
        s2.replace("\\", "").replace(
          /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
          function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
          }
        )
      );
    }
    function regexEscape(s2) {
      return s2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function absFloor(number) {
      if (number < 0) {
        return Math.ceil(number) || 0;
      } else {
        return Math.floor(number);
      }
    }
    function toInt(argumentForCoercion) {
      var coercedNumber = +argumentForCoercion, value = 0;
      if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
      }
      return value;
    }
    var tokens = {};
    function addParseToken(token2, callback) {
      var i, func = callback, tokenLen;
      if (typeof token2 === "string") {
        token2 = [token2];
      }
      if (isNumber(callback)) {
        func = function(input, array2) {
          array2[callback] = toInt(input);
        };
      }
      tokenLen = token2.length;
      for (i = 0; i < tokenLen; i++) {
        tokens[token2[i]] = func;
      }
    }
    function addWeekParseToken(token2, callback) {
      addParseToken(token2, function(input, array2, config, token3) {
        config._w = config._w || {};
        callback(input, config._w, config, token3);
      });
    }
    function addTimeToArrayFromToken(token2, input, config) {
      if (input != null && hasOwnProp(tokens, token2)) {
        tokens[token2](input, config._a, config, token2);
      }
    }
    function isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    var YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    addFormatToken("Y", 0, 0, function() {
      var y2 = this.year();
      return y2 <= 9999 ? zeroFill(y2, 4) : "+" + y2;
    });
    addFormatToken(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    });
    addFormatToken(0, ["YYYY", 4], 0, "year");
    addFormatToken(0, ["YYYYY", 5], 0, "year");
    addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
    addRegexToken("Y", matchSigned);
    addRegexToken("YY", match1to2, match2);
    addRegexToken("YYYY", match1to4, match4);
    addRegexToken("YYYYY", match1to6, match6);
    addRegexToken("YYYYYY", match1to6, match6);
    addParseToken(["YYYYY", "YYYYYY"], YEAR);
    addParseToken("YYYY", function(input, array2) {
      array2[YEAR] = input.length === 2 ? hooks2.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken("YY", function(input, array2) {
      array2[YEAR] = hooks2.parseTwoDigitYear(input);
    });
    addParseToken("Y", function(input, array2) {
      array2[YEAR] = parseInt(input, 10);
    });
    function daysInYear(year) {
      return isLeapYear(year) ? 366 : 365;
    }
    hooks2.parseTwoDigitYear = function(input) {
      return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", true);
    function getIsLeapYear() {
      return isLeapYear(this.year());
    }
    function makeGetSet(unit, keepTime) {
      return function(value) {
        if (value != null) {
          set$12(this, unit, value);
          hooks2.updateOffset(this, keepTime);
          return this;
        } else {
          return get2(this, unit);
        }
      };
    }
    function get2(mom, unit) {
      if (!mom.isValid()) {
        return NaN;
      }
      var d = mom._d, isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return isUTC ? d.getUTCMilliseconds() : d.getMilliseconds();
        case "Seconds":
          return isUTC ? d.getUTCSeconds() : d.getSeconds();
        case "Minutes":
          return isUTC ? d.getUTCMinutes() : d.getMinutes();
        case "Hours":
          return isUTC ? d.getUTCHours() : d.getHours();
        case "Date":
          return isUTC ? d.getUTCDate() : d.getDate();
        case "Day":
          return isUTC ? d.getUTCDay() : d.getDay();
        case "Month":
          return isUTC ? d.getUTCMonth() : d.getMonth();
        case "FullYear":
          return isUTC ? d.getUTCFullYear() : d.getFullYear();
        default:
          return NaN;
      }
    }
    function set$12(mom, unit, value) {
      var d, isUTC, year, month, date;
      if (!mom.isValid() || isNaN(value)) {
        return;
      }
      d = mom._d;
      isUTC = mom._isUTC;
      switch (unit) {
        case "Milliseconds":
          return void (isUTC ? d.setUTCMilliseconds(value) : d.setMilliseconds(value));
        case "Seconds":
          return void (isUTC ? d.setUTCSeconds(value) : d.setSeconds(value));
        case "Minutes":
          return void (isUTC ? d.setUTCMinutes(value) : d.setMinutes(value));
        case "Hours":
          return void (isUTC ? d.setUTCHours(value) : d.setHours(value));
        case "Date":
          return void (isUTC ? d.setUTCDate(value) : d.setDate(value));
        case "FullYear":
          break;
        default:
          return;
      }
      year = value;
      month = mom.month();
      date = mom.date();
      date = date === 29 && month === 1 && !isLeapYear(year) ? 28 : date;
      void (isUTC ? d.setUTCFullYear(year, month, date) : d.setFullYear(year, month, date));
    }
    function stringGet(units2) {
      units2 = normalizeUnits(units2);
      if (isFunction(this[units2])) {
        return this[units2]();
      }
      return this;
    }
    function stringSet(units2, value) {
      if (typeof units2 === "object") {
        units2 = normalizeObjectUnits(units2);
        var prioritized = getPrioritizedUnits(units2), i, prioritizedLen = prioritized.length;
        for (i = 0; i < prioritizedLen; i++) {
          this[prioritized[i].unit](units2[prioritized[i].unit]);
        }
      } else {
        units2 = normalizeUnits(units2);
        if (isFunction(this[units2])) {
          return this[units2](value);
        }
      }
      return this;
    }
    function mod(n2, x2) {
      return (n2 % x2 + x2) % x2;
    }
    var indexOf;
    if (Array.prototype.indexOf) {
      indexOf = Array.prototype.indexOf;
    } else {
      indexOf = function(o2) {
        var i;
        for (i = 0; i < this.length; ++i) {
          if (this[i] === o2) {
            return i;
          }
        }
        return -1;
      };
    }
    function daysInMonth(year, month) {
      if (isNaN(year) || isNaN(month)) {
        return NaN;
      }
      var modMonth = mod(month, 12);
      year += (month - modMonth) / 12;
      return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
    }
    addFormatToken("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    });
    addFormatToken("MMM", 0, 0, function(format2) {
      return this.localeData().monthsShort(this, format2);
    });
    addFormatToken("MMMM", 0, 0, function(format2) {
      return this.localeData().months(this, format2);
    });
    addRegexToken("M", match1to2, match1to2NoLeadingZero);
    addRegexToken("MM", match1to2, match2);
    addRegexToken("MMM", function(isStrict, locale2) {
      return locale2.monthsShortRegex(isStrict);
    });
    addRegexToken("MMMM", function(isStrict, locale2) {
      return locale2.monthsRegex(isStrict);
    });
    addParseToken(["M", "MM"], function(input, array2) {
      array2[MONTH] = toInt(input) - 1;
    });
    addParseToken(["MMM", "MMMM"], function(input, array2, config, token2) {
      var month = config._locale.monthsParse(input, token2, config._strict);
      if (month != null) {
        array2[MONTH] = month;
      } else {
        getParsingFlags(config).invalidMonth = input;
      }
    });
    var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
      "_"
    ), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    function localeMonths(m, format2) {
      if (!m) {
        return isArray(this._months) ? this._months : this._months["standalone"];
      }
      return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format2) ? "format" : "standalone"][m.month()];
    }
    function localeMonthsShort(m, format2) {
      if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
      }
      return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format2) ? "format" : "standalone"][m.month()];
    }
    function handleStrictParse(monthName, format2, strict) {
      var i, ii, mom, llc = monthName.toLocaleLowerCase();
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
          mom = createUTC([2e3, i]);
          this._shortMonthsParse[i] = this.monthsShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "MMM") {
          ii = indexOf.call(this._shortMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._longMonthsParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._longMonthsParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortMonthsParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeMonthsParse(monthName, format2, strict) {
      var i, mom, regex;
      if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format2, strict);
      }
      if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
      }
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        if (strict && !this._longMonthsParse[i]) {
          this._longMonthsParse[i] = new RegExp(
            "^" + this.months(mom, "").replace(".", "") + "$",
            "i"
          );
          this._shortMonthsParse[i] = new RegExp(
            "^" + this.monthsShort(mom, "").replace(".", "") + "$",
            "i"
          );
        }
        if (!strict && !this._monthsParse[i]) {
          regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
          this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "MMMM" && this._longMonthsParse[i].test(monthName)) {
          return i;
        } else if (strict && format2 === "MMM" && this._shortMonthsParse[i].test(monthName)) {
          return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
          return i;
        }
      }
    }
    function setMonth(mom, value) {
      if (!mom.isValid()) {
        return mom;
      }
      if (typeof value === "string") {
        if (/^\d+$/.test(value)) {
          value = toInt(value);
        } else {
          value = mom.localeData().monthsParse(value);
          if (!isNumber(value)) {
            return mom;
          }
        }
      }
      var month = value, date = mom.date();
      date = date < 29 ? date : Math.min(date, daysInMonth(mom.year(), month));
      void (mom._isUTC ? mom._d.setUTCMonth(month, date) : mom._d.setMonth(month, date));
      return mom;
    }
    function getSetMonth(value) {
      if (value != null) {
        setMonth(this, value);
        hooks2.updateOffset(this, true);
        return this;
      } else {
        return get2(this, "Month");
      }
    }
    function getDaysInMonth() {
      return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsShortStrictRegex;
        } else {
          return this._monthsShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsShortRegex")) {
          this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
      }
    }
    function monthsRegex(isStrict) {
      if (this._monthsParseExact) {
        if (!hasOwnProp(this, "_monthsRegex")) {
          computeMonthsParse.call(this);
        }
        if (isStrict) {
          return this._monthsStrictRegex;
        } else {
          return this._monthsRegex;
        }
      } else {
        if (!hasOwnProp(this, "_monthsRegex")) {
          this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
      }
    }
    function computeMonthsParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var shortPieces = [], longPieces = [], mixedPieces = [], i, mom, shortP, longP;
      for (i = 0; i < 12; i++) {
        mom = createUTC([2e3, i]);
        shortP = regexEscape(this.monthsShort(mom, ""));
        longP = regexEscape(this.months(mom, ""));
        shortPieces.push(shortP);
        longPieces.push(longP);
        mixedPieces.push(longP);
        mixedPieces.push(shortP);
      }
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._monthsShortRegex = this._monthsRegex;
      this._monthsStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._monthsShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
    }
    function createDate(y2, m, d, h, M, s2, ms) {
      var date;
      if (y2 < 100 && y2 >= 0) {
        date = new Date(y2 + 400, m, d, h, M, s2, ms);
        if (isFinite(date.getFullYear())) {
          date.setFullYear(y2);
        }
      } else {
        date = new Date(y2, m, d, h, M, s2, ms);
      }
      return date;
    }
    function createUTCDate(y2) {
      var date, args;
      if (y2 < 100 && y2 >= 0) {
        args = Array.prototype.slice.call(arguments);
        args[0] = y2 + 400;
        date = new Date(Date.UTC.apply(null, args));
        if (isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y2);
        }
      } else {
        date = new Date(Date.UTC.apply(null, arguments));
      }
      return date;
    }
    function firstWeekOffset(year, dow, doy) {
      var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week2, weekday, dow, doy) {
      var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week2 - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
      if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
      } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
      } else {
        resYear = year;
        resDayOfYear = dayOfYear;
      }
      return {
        year: resYear,
        dayOfYear: resDayOfYear
      };
    }
    function weekOfYear(mom, dow, doy) {
      var weekOffset = firstWeekOffset(mom.year(), dow, doy), week2 = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
      if (week2 < 1) {
        resYear = mom.year() - 1;
        resWeek = week2 + weeksInYear(resYear, dow, doy);
      } else if (week2 > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week2 - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
      } else {
        resYear = mom.year();
        resWeek = week2;
      }
      return {
        week: resWeek,
        year: resYear
      };
    }
    function weeksInYear(year, dow, doy) {
      var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
      return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    addFormatToken("w", ["ww", 2], "wo", "week");
    addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
    addRegexToken("w", match1to2, match1to2NoLeadingZero);
    addRegexToken("ww", match1to2, match2);
    addRegexToken("W", match1to2, match1to2NoLeadingZero);
    addRegexToken("WW", match1to2, match2);
    addWeekParseToken(
      ["w", "ww", "W", "WW"],
      function(input, week2, config, token2) {
        week2[token2.substr(0, 1)] = toInt(input);
      }
    );
    function localeWeek(mom) {
      return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    var defaultLocaleWeek = {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6
      // The week that contains Jan 6th is the first week of the year.
    };
    function localeFirstDayOfWeek() {
      return this._week.dow;
    }
    function localeFirstDayOfYear() {
      return this._week.doy;
    }
    function getSetWeek(input) {
      var week2 = this.localeData().week(this);
      return input == null ? week2 : this.add((input - week2) * 7, "d");
    }
    function getSetISOWeek(input) {
      var week2 = weekOfYear(this, 1, 4).week;
      return input == null ? week2 : this.add((input - week2) * 7, "d");
    }
    addFormatToken("d", 0, "do", "day");
    addFormatToken("dd", 0, 0, function(format2) {
      return this.localeData().weekdaysMin(this, format2);
    });
    addFormatToken("ddd", 0, 0, function(format2) {
      return this.localeData().weekdaysShort(this, format2);
    });
    addFormatToken("dddd", 0, 0, function(format2) {
      return this.localeData().weekdays(this, format2);
    });
    addFormatToken("e", 0, 0, "weekday");
    addFormatToken("E", 0, 0, "isoWeekday");
    addRegexToken("d", match1to2);
    addRegexToken("e", match1to2);
    addRegexToken("E", match1to2);
    addRegexToken("dd", function(isStrict, locale2) {
      return locale2.weekdaysMinRegex(isStrict);
    });
    addRegexToken("ddd", function(isStrict, locale2) {
      return locale2.weekdaysShortRegex(isStrict);
    });
    addRegexToken("dddd", function(isStrict, locale2) {
      return locale2.weekdaysRegex(isStrict);
    });
    addWeekParseToken(["dd", "ddd", "dddd"], function(input, week2, config, token2) {
      var weekday = config._locale.weekdaysParse(input, token2, config._strict);
      if (weekday != null) {
        week2.d = weekday;
      } else {
        getParsingFlags(config).invalidWeekday = input;
      }
    });
    addWeekParseToken(["d", "e", "E"], function(input, week2, config, token2) {
      week2[token2] = toInt(input);
    });
    function parseWeekday(input, locale2) {
      if (typeof input !== "string") {
        return input;
      }
      if (!isNaN(input)) {
        return parseInt(input, 10);
      }
      input = locale2.weekdaysParse(input);
      if (typeof input === "number") {
        return input;
      }
      return null;
    }
    function parseIsoWeekday(input, locale2) {
      if (typeof input === "string") {
        return locale2.weekdaysParse(input) % 7 || 7;
      }
      return isNaN(input) ? null : input;
    }
    function shiftWeekdays(ws, n2) {
      return ws.slice(n2, 7).concat(ws.slice(0, n2));
    }
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    function localeWeekdays(m, format2) {
      var weekdays2 = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format2) ? "format" : "standalone"];
      return m === true ? shiftWeekdays(weekdays2, this._week.dow) : m ? weekdays2[m.day()] : weekdays2;
    }
    function localeWeekdaysShort(m) {
      return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
      return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format2, strict) {
      var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];
        for (i = 0; i < 7; ++i) {
          mom = createUTC([2e3, 1]).day(i);
          this._minWeekdaysParse[i] = this.weekdaysMin(
            mom,
            ""
          ).toLocaleLowerCase();
          this._shortWeekdaysParse[i] = this.weekdaysShort(
            mom,
            ""
          ).toLocaleLowerCase();
          this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        }
      }
      if (strict) {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      } else {
        if (format2 === "dddd") {
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else if (format2 === "ddd") {
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._minWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        } else {
          ii = indexOf.call(this._minWeekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._weekdaysParse, llc);
          if (ii !== -1) {
            return ii;
          }
          ii = indexOf.call(this._shortWeekdaysParse, llc);
          return ii !== -1 ? ii : null;
        }
      }
    }
    function localeWeekdaysParse(weekdayName, format2, strict) {
      var i, mom, regex;
      if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format2, strict);
      }
      if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
      }
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
          this._fullWeekdaysParse[i] = new RegExp(
            "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._shortWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
          this._minWeekdaysParse[i] = new RegExp(
            "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
            "i"
          );
        }
        if (!this._weekdaysParse[i]) {
          regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
          this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i");
        }
        if (strict && format2 === "dddd" && this._fullWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "ddd" && this._shortWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (strict && format2 === "dd" && this._minWeekdaysParse[i].test(weekdayName)) {
          return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
          return i;
        }
      }
    }
    function getSetDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var day = get2(this, "Day");
      if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, "d");
      } else {
        return day;
      }
    }
    function getSetLocaleDayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return input == null ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
      } else {
        return this.day() || 7;
      }
    }
    function weekdaysRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysStrictRegex;
        } else {
          return this._weekdaysRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
      }
    }
    function weekdaysShortRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysShortStrictRegex;
        } else {
          return this._weekdaysShortRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysShortRegex")) {
          this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
      }
    }
    function weekdaysMinRegex(isStrict) {
      if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, "_weekdaysRegex")) {
          computeWeekdaysParse.call(this);
        }
        if (isStrict) {
          return this._weekdaysMinStrictRegex;
        } else {
          return this._weekdaysMinRegex;
        }
      } else {
        if (!hasOwnProp(this, "_weekdaysMinRegex")) {
          this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
      }
    }
    function computeWeekdaysParse() {
      function cmpLenRev(a, b) {
        return b.length - a.length;
      }
      var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
      for (i = 0; i < 7; i++) {
        mom = createUTC([2e3, 1]).day(i);
        minp = regexEscape(this.weekdaysMin(mom, ""));
        shortp = regexEscape(this.weekdaysShort(mom, ""));
        longp = regexEscape(this.weekdays(mom, ""));
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
      }
      minPieces.sort(cmpLenRev);
      shortPieces.sort(cmpLenRev);
      longPieces.sort(cmpLenRev);
      mixedPieces.sort(cmpLenRev);
      this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._weekdaysShortRegex = this._weekdaysRegex;
      this._weekdaysMinRegex = this._weekdaysRegex;
      this._weekdaysStrictRegex = new RegExp(
        "^(" + longPieces.join("|") + ")",
        "i"
      );
      this._weekdaysShortStrictRegex = new RegExp(
        "^(" + shortPieces.join("|") + ")",
        "i"
      );
      this._weekdaysMinStrictRegex = new RegExp(
        "^(" + minPieces.join("|") + ")",
        "i"
      );
    }
    function hFormat() {
      return this.hours() % 12 || 12;
    }
    function kFormat() {
      return this.hours() || 24;
    }
    addFormatToken("H", ["HH", 2], 0, "hour");
    addFormatToken("h", ["hh", 2], 0, hFormat);
    addFormatToken("k", ["kk", 2], 0, kFormat);
    addFormatToken("hmm", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });
    addFormatToken("hmmss", 0, 0, function() {
      return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    addFormatToken("Hmm", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2);
    });
    addFormatToken("Hmmss", 0, 0, function() {
      return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });
    function meridiem(token2, lowercase) {
      addFormatToken(token2, 0, 0, function() {
        return this.localeData().meridiem(
          this.hours(),
          this.minutes(),
          lowercase
        );
      });
    }
    meridiem("a", true);
    meridiem("A", false);
    function matchMeridiem(isStrict, locale2) {
      return locale2._meridiemParse;
    }
    addRegexToken("a", matchMeridiem);
    addRegexToken("A", matchMeridiem);
    addRegexToken("H", match1to2, match1to2HasZero);
    addRegexToken("h", match1to2, match1to2NoLeadingZero);
    addRegexToken("k", match1to2, match1to2NoLeadingZero);
    addRegexToken("HH", match1to2, match2);
    addRegexToken("hh", match1to2, match2);
    addRegexToken("kk", match1to2, match2);
    addRegexToken("hmm", match3to4);
    addRegexToken("hmmss", match5to6);
    addRegexToken("Hmm", match3to4);
    addRegexToken("Hmmss", match5to6);
    addParseToken(["H", "HH"], HOUR);
    addParseToken(["k", "kk"], function(input, array2, config) {
      var kInput = toInt(input);
      array2[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(["a", "A"], function(input, array2, config) {
      config._isPm = config._locale.isPM(input);
      config._meridiem = input;
    });
    addParseToken(["h", "hh"], function(input, array2, config) {
      array2[HOUR] = toInt(input);
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmm", function(input, array2, config) {
      var pos = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos));
      array2[MINUTE] = toInt(input.substr(pos));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("hmmss", function(input, array2, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos1));
      array2[MINUTE] = toInt(input.substr(pos1, 2));
      array2[SECOND] = toInt(input.substr(pos2));
      getParsingFlags(config).bigHour = true;
    });
    addParseToken("Hmm", function(input, array2, config) {
      var pos = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos));
      array2[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken("Hmmss", function(input, array2, config) {
      var pos1 = input.length - 4, pos2 = input.length - 2;
      array2[HOUR] = toInt(input.substr(0, pos1));
      array2[MINUTE] = toInt(input.substr(pos1, 2));
      array2[SECOND] = toInt(input.substr(pos2));
    });
    function localeIsPM(input) {
      return (input + "").toLowerCase().charAt(0) === "p";
    }
    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", true);
    function localeMeridiem(hours2, minutes2, isLower) {
      if (hours2 > 11) {
        return isLower ? "pm" : "PM";
      } else {
        return isLower ? "am" : "AM";
      }
    }
    var baseConfig = {
      calendar: defaultCalendar,
      longDateFormat: defaultLongDateFormat,
      invalidDate: defaultInvalidDate,
      ordinal: defaultOrdinal,
      dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
      relativeTime: defaultRelativeTime,
      months: defaultLocaleMonths,
      monthsShort: defaultLocaleMonthsShort,
      week: defaultLocaleWeek,
      weekdays: defaultLocaleWeekdays,
      weekdaysMin: defaultLocaleWeekdaysMin,
      weekdaysShort: defaultLocaleWeekdaysShort,
      meridiemParse: defaultLocaleMeridiemParse
    };
    var locales = {}, localeFamilies = {}, globalLocale;
    function commonPrefix(arr1, arr2) {
      var i, minl = Math.min(arr1.length, arr2.length);
      for (i = 0; i < minl; i += 1) {
        if (arr1[i] !== arr2[i]) {
          return i;
        }
      }
      return minl;
    }
    function normalizeLocale(key) {
      return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
      var i = 0, j, next, locale2, split;
      while (i < names.length) {
        split = normalizeLocale(names[i]).split("-");
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split("-") : null;
        while (j > 0) {
          locale2 = loadLocale(split.slice(0, j).join("-"));
          if (locale2) {
            return locale2;
          }
          if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
            break;
          }
          j--;
        }
        i++;
      }
      return globalLocale;
    }
    function isLocaleNameSane(name) {
      return !!(name && name.match("^[^/\\\\]*$"));
    }
    function loadLocale(name) {
      var oldLocale = null, aliasedRequire;
      if (locales[name] === void 0 && true && module2 && module2.exports && isLocaleNameSane(name)) {
        try {
          oldLocale = globalLocale._abbr;
          aliasedRequire = commonjsRequire;
          aliasedRequire("./locale/" + name);
          getSetGlobalLocale(oldLocale);
        } catch (e2) {
          locales[name] = null;
        }
      }
      return locales[name];
    }
    function getSetGlobalLocale(key, values) {
      var data;
      if (key) {
        if (isUndefined(values)) {
          data = getLocale2(key);
        } else {
          data = defineLocale(key, values);
        }
        if (data) {
          globalLocale = data;
        } else {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(
              "Locale " + key + " not found. Did you forget to load it?"
            );
          }
        }
      }
      return globalLocale._abbr;
    }
    function defineLocale(name, config) {
      if (config !== null) {
        var locale2, parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
          deprecateSimple(
            "defineLocaleOverride",
            "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
          );
          parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
          if (locales[config.parentLocale] != null) {
            parentConfig = locales[config.parentLocale]._config;
          } else {
            locale2 = loadLocale(config.parentLocale);
            if (locale2 != null) {
              parentConfig = locale2._config;
            } else {
              if (!localeFamilies[config.parentLocale]) {
                localeFamilies[config.parentLocale] = [];
              }
              localeFamilies[config.parentLocale].push({
                name,
                config
              });
              return null;
            }
          }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));
        if (localeFamilies[name]) {
          localeFamilies[name].forEach(function(x2) {
            defineLocale(x2.name, x2.config);
          });
        }
        getSetGlobalLocale(name);
        return locales[name];
      } else {
        delete locales[name];
        return null;
      }
    }
    function updateLocale(name, config) {
      if (config != null) {
        var locale2, tmpLocale, parentConfig = baseConfig;
        if (locales[name] != null && locales[name].parentLocale != null) {
          locales[name].set(mergeConfigs(locales[name]._config, config));
        } else {
          tmpLocale = loadLocale(name);
          if (tmpLocale != null) {
            parentConfig = tmpLocale._config;
          }
          config = mergeConfigs(parentConfig, config);
          if (tmpLocale == null) {
            config.abbr = name;
          }
          locale2 = new Locale(config);
          locale2.parentLocale = locales[name];
          locales[name] = locale2;
        }
        getSetGlobalLocale(name);
      } else {
        if (locales[name] != null) {
          if (locales[name].parentLocale != null) {
            locales[name] = locales[name].parentLocale;
            if (name === getSetGlobalLocale()) {
              getSetGlobalLocale(name);
            }
          } else if (locales[name] != null) {
            delete locales[name];
          }
        }
      }
      return locales[name];
    }
    function getLocale2(key) {
      var locale2;
      if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
      }
      if (!key) {
        return globalLocale;
      }
      if (!isArray(key)) {
        locale2 = loadLocale(key);
        if (locale2) {
          return locale2;
        }
        key = [key];
      }
      return chooseLocale(key);
    }
    function listLocales() {
      return keys(locales);
    }
    function checkOverflow(m) {
      var overflow, a = m._a;
      if (a && getParsingFlags(m).overflow === -2) {
        overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
          overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
          overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
          overflow = WEEKDAY;
        }
        getParsingFlags(m).overflow = overflow;
      }
      return m;
    }
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [
      ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
      ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
      ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
      ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
      ["YYYY-DDD", /\d{4}-\d{3}/],
      ["YYYY-MM", /\d{4}-\d\d/, false],
      ["YYYYYYMMDD", /[+-]\d{10}/],
      ["YYYYMMDD", /\d{8}/],
      ["GGGG[W]WWE", /\d{4}W\d{3}/],
      ["GGGG[W]WW", /\d{4}W\d{2}/, false],
      ["YYYYDDD", /\d{7}/],
      ["YYYYMM", /\d{6}/, false],
      ["YYYY", /\d{4}/, false]
    ], isoTimes = [
      ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
      ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
      ["HH:mm:ss", /\d\d:\d\d:\d\d/],
      ["HH:mm", /\d\d:\d\d/],
      ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
      ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
      ["HHmmss", /\d\d\d\d\d\d/],
      ["HHmm", /\d\d\d\d/],
      ["HH", /\d\d/]
    ], aspNetJsonRegex = /^\/?Date\((-?\d+)/i, rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, obsOffsets = {
      UT: 0,
      GMT: 0,
      EDT: -4 * 60,
      EST: -5 * 60,
      CDT: -5 * 60,
      CST: -6 * 60,
      MDT: -6 * 60,
      MST: -7 * 60,
      PDT: -7 * 60,
      PST: -8 * 60
    };
    function configFromISO(config) {
      var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
      if (match) {
        getParsingFlags(config).iso = true;
        for (i = 0, l = isoDatesLen; i < l; i++) {
          if (isoDates[i][1].exec(match[1])) {
            dateFormat = isoDates[i][0];
            allowTime = isoDates[i][2] !== false;
            break;
          }
        }
        if (dateFormat == null) {
          config._isValid = false;
          return;
        }
        if (match[3]) {
          for (i = 0, l = isoTimesLen; i < l; i++) {
            if (isoTimes[i][1].exec(match[3])) {
              timeFormat = (match[2] || " ") + isoTimes[i][0];
              break;
            }
          }
          if (timeFormat == null) {
            config._isValid = false;
            return;
          }
        }
        if (!allowTime && timeFormat != null) {
          config._isValid = false;
          return;
        }
        if (match[4]) {
          if (tzRegex.exec(match[4])) {
            tzFormat = "Z";
          } else {
            config._isValid = false;
            return;
          }
        }
        config._f = dateFormat + (timeFormat || "") + (tzFormat || "");
        configFromStringAndFormat(config);
      } else {
        config._isValid = false;
      }
    }
    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
      var result = [
        untruncateYear(yearStr),
        defaultLocaleMonthsShort.indexOf(monthStr),
        parseInt(dayStr, 10),
        parseInt(hourStr, 10),
        parseInt(minuteStr, 10)
      ];
      if (secondStr) {
        result.push(parseInt(secondStr, 10));
      }
      return result;
    }
    function untruncateYear(yearStr) {
      var year = parseInt(yearStr, 10);
      if (year <= 49) {
        return 2e3 + year;
      } else if (year <= 999) {
        return 1900 + year;
      }
      return year;
    }
    function preprocessRFC2822(s2) {
      return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
    }
    function checkWeekday(weekdayStr, parsedInput, config) {
      if (weekdayStr) {
        var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
          parsedInput[0],
          parsedInput[1],
          parsedInput[2]
        ).getDay();
        if (weekdayProvided !== weekdayActual) {
          getParsingFlags(config).weekdayMismatch = true;
          config._isValid = false;
          return false;
        }
      }
      return true;
    }
    function calculateOffset(obsOffset, militaryOffset, numOffset) {
      if (obsOffset) {
        return obsOffsets[obsOffset];
      } else if (militaryOffset) {
        return 0;
      } else {
        var hm = parseInt(numOffset, 10), m = hm % 100, h = (hm - m) / 100;
        return h * 60 + m;
      }
    }
    function configFromRFC2822(config) {
      var match = rfc2822.exec(preprocessRFC2822(config._i)), parsedArray;
      if (match) {
        parsedArray = extractFromRFC2822Strings(
          match[4],
          match[3],
          match[2],
          match[5],
          match[6],
          match[7]
        );
        if (!checkWeekday(match[1], parsedArray, config)) {
          return;
        }
        config._a = parsedArray;
        config._tzm = calculateOffset(match[8], match[9], match[10]);
        config._d = createUTCDate.apply(null, config._a);
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        getParsingFlags(config).rfc2822 = true;
      } else {
        config._isValid = false;
      }
    }
    function configFromString(config) {
      var matched = aspNetJsonRegex.exec(config._i);
      if (matched !== null) {
        config._d = /* @__PURE__ */ new Date(+matched[1]);
        return;
      }
      configFromISO(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      configFromRFC2822(config);
      if (config._isValid === false) {
        delete config._isValid;
      } else {
        return;
      }
      if (config._strict) {
        config._isValid = false;
      } else {
        hooks2.createFromInputFallback(config);
      }
    }
    hooks2.createFromInputFallback = deprecate(
      "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
      function(config) {
        config._d = /* @__PURE__ */ new Date(config._i + (config._useUTC ? " UTC" : ""));
      }
    );
    function defaults2(a, b, c) {
      if (a != null) {
        return a;
      }
      if (b != null) {
        return b;
      }
      return c;
    }
    function currentDateArray(config) {
      var nowValue = new Date(hooks2.now());
      if (config._useUTC) {
        return [
          nowValue.getUTCFullYear(),
          nowValue.getUTCMonth(),
          nowValue.getUTCDate()
        ];
      }
      return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }
    function configFromArray(config) {
      var i, date, input = [], currentDate, expectedWeekday, yearToUse;
      if (config._d) {
        return;
      }
      currentDate = currentDateArray(config);
      if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
      }
      if (config._dayOfYear != null) {
        yearToUse = defaults2(config._a[YEAR], currentDate[YEAR]);
        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
          getParsingFlags(config)._overflowDayOfYear = true;
        }
        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
      }
      for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
      }
      for (; i < 7; i++) {
        config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
      }
      if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
      }
      config._d = (config._useUTC ? createUTCDate : createDate).apply(
        null,
        input
      );
      expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
      if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
      }
      if (config._nextDay) {
        config._a[HOUR] = 24;
      }
      if (config._w && typeof config._w.d !== "undefined" && config._w.d !== expectedWeekday) {
        getParsingFlags(config).weekdayMismatch = true;
      }
    }
    function dayOfYearFromWeekInfo(config) {
      var w, weekYear, week2, weekday, dow, doy, temp, weekdayOverflow, curWeek;
      w = config._w;
      if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        weekYear = defaults2(
          w.GG,
          config._a[YEAR],
          weekOfYear(createLocal(), 1, 4).year
        );
        week2 = defaults2(w.W, 1);
        weekday = defaults2(w.E, 1);
        if (weekday < 1 || weekday > 7) {
          weekdayOverflow = true;
        }
      } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        curWeek = weekOfYear(createLocal(), dow, doy);
        weekYear = defaults2(w.gg, config._a[YEAR], curWeek.year);
        week2 = defaults2(w.w, curWeek.week);
        if (w.d != null) {
          weekday = w.d;
          if (weekday < 0 || weekday > 6) {
            weekdayOverflow = true;
          }
        } else if (w.e != null) {
          weekday = w.e + dow;
          if (w.e < 0 || w.e > 6) {
            weekdayOverflow = true;
          }
        } else {
          weekday = dow;
        }
      }
      if (week2 < 1 || week2 > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
      } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
      } else {
        temp = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
      }
    }
    hooks2.ISO_8601 = function() {
    };
    hooks2.RFC_2822 = function() {
    };
    function configFromStringAndFormat(config) {
      if (config._f === hooks2.ISO_8601) {
        configFromISO(config);
        return;
      }
      if (config._f === hooks2.RFC_2822) {
        configFromRFC2822(config);
        return;
      }
      config._a = [];
      getParsingFlags(config).empty = true;
      var string = "" + config._i, i, parsedInput, tokens2, token2, skipped, stringLength = string.length, totalParsedInputLength = 0, era, tokenLen;
      tokens2 = expandFormat(config._f, config._locale).match(formattingTokens) || [];
      tokenLen = tokens2.length;
      for (i = 0; i < tokenLen; i++) {
        token2 = tokens2[i];
        parsedInput = (string.match(getParseRegexForToken(token2, config)) || [])[0];
        if (parsedInput) {
          skipped = string.substr(0, string.indexOf(parsedInput));
          if (skipped.length > 0) {
            getParsingFlags(config).unusedInput.push(skipped);
          }
          string = string.slice(
            string.indexOf(parsedInput) + parsedInput.length
          );
          totalParsedInputLength += parsedInput.length;
        }
        if (formatTokenFunctions[token2]) {
          if (parsedInput) {
            getParsingFlags(config).empty = false;
          } else {
            getParsingFlags(config).unusedTokens.push(token2);
          }
          addTimeToArrayFromToken(token2, parsedInput, config);
        } else if (config._strict && !parsedInput) {
          getParsingFlags(config).unusedTokens.push(token2);
        }
      }
      getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
      if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
      }
      if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = void 0;
      }
      getParsingFlags(config).parsedDateParts = config._a.slice(0);
      getParsingFlags(config).meridiem = config._meridiem;
      config._a[HOUR] = meridiemFixWrap(
        config._locale,
        config._a[HOUR],
        config._meridiem
      );
      era = getParsingFlags(config).era;
      if (era !== null) {
        config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
      }
      configFromArray(config);
      checkOverflow(config);
    }
    function meridiemFixWrap(locale2, hour, meridiem2) {
      var isPm;
      if (meridiem2 == null) {
        return hour;
      }
      if (locale2.meridiemHour != null) {
        return locale2.meridiemHour(hour, meridiem2);
      } else if (locale2.isPM != null) {
        isPm = locale2.isPM(meridiem2);
        if (isPm && hour < 12) {
          hour += 12;
        }
        if (!isPm && hour === 12) {
          hour = 0;
        }
        return hour;
      } else {
        return hour;
      }
    }
    function configFromStringAndArray(config) {
      var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config._f.length;
      if (configfLen === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = /* @__PURE__ */ new Date(NaN);
        return;
      }
      for (i = 0; i < configfLen; i++) {
        currentScore = 0;
        validFormatFound = false;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
          tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);
        if (isValid2(tempConfig)) {
          validFormatFound = true;
        }
        currentScore += getParsingFlags(tempConfig).charsLeftOver;
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
        getParsingFlags(tempConfig).score = currentScore;
        if (!bestFormatIsValid) {
          if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
            if (validFormatFound) {
              bestFormatIsValid = true;
            }
          }
        } else {
          if (currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
      }
      extend2(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
      if (config._d) {
        return;
      }
      var i = normalizeObjectUnits(config._i), dayOrDate = i.day === void 0 ? i.date : i.day;
      config._a = map(
        [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
        function(obj) {
          return obj && parseInt(obj, 10);
        }
      );
      configFromArray(config);
    }
    function createFromConfig(config) {
      var res = new Moment(checkOverflow(prepareConfig(config)));
      if (res._nextDay) {
        res.add(1, "d");
        res._nextDay = void 0;
      }
      return res;
    }
    function prepareConfig(config) {
      var input = config._i, format2 = config._f;
      config._locale = config._locale || getLocale2(config._l);
      if (input === null || format2 === void 0 && input === "") {
        return createInvalid({ nullInput: true });
      }
      if (typeof input === "string") {
        config._i = input = config._locale.preparse(input);
      }
      if (isMoment(input)) {
        return new Moment(checkOverflow(input));
      } else if (isDate(input)) {
        config._d = input;
      } else if (isArray(format2)) {
        configFromStringAndArray(config);
      } else if (format2) {
        configFromStringAndFormat(config);
      } else {
        configFromInput(config);
      }
      if (!isValid2(config)) {
        config._d = null;
      }
      return config;
    }
    function configFromInput(config) {
      var input = config._i;
      if (isUndefined(input)) {
        config._d = new Date(hooks2.now());
      } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
      } else if (typeof input === "string") {
        configFromString(config);
      } else if (isArray(input)) {
        config._a = map(input.slice(0), function(obj) {
          return parseInt(obj, 10);
        });
        configFromArray(config);
      } else if (isObject(input)) {
        configFromObject(config);
      } else if (isNumber(input)) {
        config._d = new Date(input);
      } else {
        hooks2.createFromInputFallback(config);
      }
    }
    function createLocalOrUTC(input, format2, locale2, strict, isUTC) {
      var c = {};
      if (format2 === true || format2 === false) {
        strict = format2;
        format2 = void 0;
      }
      if (locale2 === true || locale2 === false) {
        strict = locale2;
        locale2 = void 0;
      }
      if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
        input = void 0;
      }
      c._isAMomentObject = true;
      c._useUTC = c._isUTC = isUTC;
      c._l = locale2;
      c._i = input;
      c._f = format2;
      c._strict = strict;
      return createFromConfig(c);
    }
    function createLocal(input, format2, locale2, strict) {
      return createLocalOrUTC(input, format2, locale2, strict, false);
    }
    var prototypeMin = deprecate(
      "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return createInvalid();
        }
      }
    ), prototypeMax = deprecate(
      "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
      function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return createInvalid();
        }
      }
    );
    function pickBy(fn, moments) {
      var res, i;
      if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
      }
      if (!moments.length) {
        return createLocal();
      }
      res = moments[0];
      for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
          res = moments[i];
        }
      }
      return res;
    }
    function min2() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isBefore", args);
    }
    function max2() {
      var args = [].slice.call(arguments, 0);
      return pickBy("isAfter", args);
    }
    var now2 = function() {
      return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
    };
    var ordering = [
      "year",
      "quarter",
      "month",
      "week",
      "day",
      "hour",
      "minute",
      "second",
      "millisecond"
    ];
    function isDurationValid(m) {
      var key, unitHasDecimal = false, i, orderLen = ordering.length;
      for (key in m) {
        if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
          return false;
        }
      }
      for (i = 0; i < orderLen; ++i) {
        if (m[ordering[i]]) {
          if (unitHasDecimal) {
            return false;
          }
          if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
            unitHasDecimal = true;
          }
        }
      }
      return true;
    }
    function isValid$1() {
      return this._isValid;
    }
    function createInvalid$1() {
      return createDuration(NaN);
    }
    function Duration(duration) {
      var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
      this._isValid = isDurationValid(normalizedInput);
      this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
      minutes2 * 6e4 + // 1000 * 60
      hours2 * 1e3 * 60 * 60;
      this._days = +days2 + weeks2 * 7;
      this._months = +months2 + quarters * 3 + years2 * 12;
      this._data = {};
      this._locale = getLocale2();
      this._bubble();
    }
    function isDuration(obj) {
      return obj instanceof Duration;
    }
    function absRound(number) {
      if (number < 0) {
        return Math.round(-1 * number) * -1;
      } else {
        return Math.round(number);
      }
    }
    function compareArrays(array1, array2, dontConvert) {
      var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
      for (i = 0; i < len; i++) {
        if (toInt(array1[i]) !== toInt(array2[i])) {
          diffs++;
        }
      }
      return diffs + lengthDiff;
    }
    function offset(token2, separator) {
      addFormatToken(token2, 0, 0, function() {
        var offset2 = this.utcOffset(), sign2 = "+";
        if (offset2 < 0) {
          offset2 = -offset2;
          sign2 = "-";
        }
        return sign2 + zeroFill(~~(offset2 / 60), 2) + separator + zeroFill(~~offset2 % 60, 2);
      });
    }
    offset("Z", ":");
    offset("ZZ", "");
    addRegexToken("Z", matchShortOffset);
    addRegexToken("ZZ", matchShortOffset);
    addParseToken(["Z", "ZZ"], function(input, array2, config) {
      config._useUTC = true;
      config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    function offsetFromString(matcher2, string) {
      var matches = (string || "").match(matcher2), chunk, parts, minutes2;
      if (matches === null) {
        return null;
      }
      chunk = matches[matches.length - 1] || [];
      parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
      minutes2 = +(parts[1] * 60) + toInt(parts[2]);
      return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
    }
    function cloneWithOffset(input, model) {
      var res, diff2;
      if (model._isUTC) {
        res = model.clone();
        diff2 = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        res._d.setTime(res._d.valueOf() + diff2);
        hooks2.updateOffset(res, false);
        return res;
      } else {
        return createLocal(input).local();
      }
    }
    function getDateOffset(m) {
      return -Math.round(m._d.getTimezoneOffset());
    }
    hooks2.updateOffset = function() {
    };
    function getSetOffset(input, keepLocalTime, keepMinutes) {
      var offset2 = this._offset || 0, localAdjust;
      if (!this.isValid()) {
        return input != null ? this : NaN;
      }
      if (input != null) {
        if (typeof input === "string") {
          input = offsetFromString(matchShortOffset, input);
          if (input === null) {
            return this;
          }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
          input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
          localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
          this.add(localAdjust, "m");
        }
        if (offset2 !== input) {
          if (!keepLocalTime || this._changeInProgress) {
            addSubtract(
              this,
              createDuration(input - offset2, "m"),
              1,
              false
            );
          } else if (!this._changeInProgress) {
            this._changeInProgress = true;
            hooks2.updateOffset(this, true);
            this._changeInProgress = null;
          }
        }
        return this;
      } else {
        return this._isUTC ? offset2 : getDateOffset(this);
      }
    }
    function getSetZone(input, keepLocalTime) {
      if (input != null) {
        if (typeof input !== "string") {
          input = -input;
        }
        this.utcOffset(input, keepLocalTime);
        return this;
      } else {
        return -this.utcOffset();
      }
    }
    function setOffsetToUTC(keepLocalTime) {
      return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
      if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;
        if (keepLocalTime) {
          this.subtract(getDateOffset(this), "m");
        }
      }
      return this;
    }
    function setOffsetToParsedOffset() {
      if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
      } else if (typeof this._i === "string") {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
          this.utcOffset(tZone);
        } else {
          this.utcOffset(0, true);
        }
      }
      return this;
    }
    function hasAlignedHourOffset(input) {
      if (!this.isValid()) {
        return false;
      }
      input = input ? createLocal(input).utcOffset() : 0;
      return (this.utcOffset() - input) % 60 === 0;
    }
    function isDaylightSavingTime() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
      if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
      }
      var c = {}, other;
      copyConfig(c, this);
      c = prepareConfig(c);
      if (c._a) {
        other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
      } else {
        this._isDSTShifted = false;
      }
      return this._isDSTShifted;
    }
    function isLocal() {
      return this.isValid() ? !this._isUTC : false;
    }
    function isUtcOffset() {
      return this.isValid() ? this._isUTC : false;
    }
    function isUtc() {
      return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }
    var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function createDuration(input, key) {
      var duration = input, match = null, sign2, ret, diffRes;
      if (isDuration(input)) {
        duration = {
          ms: input._milliseconds,
          d: input._days,
          M: input._months
        };
      } else if (isNumber(input) || !isNaN(+input)) {
        duration = {};
        if (key) {
          duration[key] = +input;
        } else {
          duration.milliseconds = +input;
        }
      } else if (match = aspNetRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: 0,
          d: toInt(match[DATE]) * sign2,
          h: toInt(match[HOUR]) * sign2,
          m: toInt(match[MINUTE]) * sign2,
          s: toInt(match[SECOND]) * sign2,
          ms: toInt(absRound(match[MILLISECOND] * 1e3)) * sign2
          // the millisecond decimal point is included in the match
        };
      } else if (match = isoRegex.exec(input)) {
        sign2 = match[1] === "-" ? -1 : 1;
        duration = {
          y: parseIso(match[2], sign2),
          M: parseIso(match[3], sign2),
          w: parseIso(match[4], sign2),
          d: parseIso(match[5], sign2),
          h: parseIso(match[6], sign2),
          m: parseIso(match[7], sign2),
          s: parseIso(match[8], sign2)
        };
      } else if (duration == null) {
        duration = {};
      } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
        diffRes = momentsDifference(
          createLocal(duration.from),
          createLocal(duration.to)
        );
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
      }
      ret = new Duration(duration);
      if (isDuration(input) && hasOwnProp(input, "_locale")) {
        ret._locale = input._locale;
      }
      if (isDuration(input) && hasOwnProp(input, "_isValid")) {
        ret._isValid = input._isValid;
      }
      return ret;
    }
    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;
    function parseIso(inp, sign2) {
      var res = inp && parseFloat(inp.replace(",", "."));
      return (isNaN(res) ? 0 : res) * sign2;
    }
    function positiveMomentsDifference(base, other) {
      var res = {};
      res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
      if (base.clone().add(res.months, "M").isAfter(other)) {
        --res.months;
      }
      res.milliseconds = +other - +base.clone().add(res.months, "M");
      return res;
    }
    function momentsDifference(base, other) {
      var res;
      if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
      }
      other = cloneWithOffset(other, base);
      if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
      } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
      }
      return res;
    }
    function createAdder(direction, name) {
      return function(val, period) {
        var dur, tmp;
        if (period !== null && !isNaN(+period)) {
          deprecateSimple(
            name,
            "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
          );
          tmp = val;
          val = period;
          period = tmp;
        }
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
      };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
      var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
      if (!mom.isValid()) {
        return;
      }
      updateOffset = updateOffset == null ? true : updateOffset;
      if (months2) {
        setMonth(mom, get2(mom, "Month") + months2 * isAdding);
      }
      if (days2) {
        set$12(mom, "Date", get2(mom, "Date") + days2 * isAdding);
      }
      if (milliseconds2) {
        mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
      }
      if (updateOffset) {
        hooks2.updateOffset(mom, days2 || months2);
      }
    }
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    function isString(input) {
      return typeof input === "string" || input instanceof String;
    }
    function isMomentInput(input) {
      return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
    }
    function isMomentInputObject(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "years",
        "year",
        "y",
        "months",
        "month",
        "M",
        "days",
        "day",
        "d",
        "dates",
        "date",
        "D",
        "hours",
        "hour",
        "h",
        "minutes",
        "minute",
        "m",
        "seconds",
        "second",
        "s",
        "milliseconds",
        "millisecond",
        "ms"
      ], i, property, propertyLen = properties.length;
      for (i = 0; i < propertyLen; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function isNumberOrStringArray(input) {
      var arrayTest = isArray(input), dataTypeTest = false;
      if (arrayTest) {
        dataTypeTest = input.filter(function(item) {
          return !isNumber(item) && isString(input);
        }).length === 0;
      }
      return arrayTest && dataTypeTest;
    }
    function isCalendarSpec(input) {
      var objectTest = isObject(input) && !isObjectEmpty(input), propertyTest = false, properties = [
        "sameDay",
        "nextDay",
        "lastDay",
        "nextWeek",
        "lastWeek",
        "sameElse"
      ], i, property;
      for (i = 0; i < properties.length; i += 1) {
        property = properties[i];
        propertyTest = propertyTest || hasOwnProp(input, property);
      }
      return objectTest && propertyTest;
    }
    function getCalendarFormat(myMoment, now3) {
      var diff2 = myMoment.diff(now3, "days", true);
      return diff2 < -6 ? "sameElse" : diff2 < -1 ? "lastWeek" : diff2 < 0 ? "lastDay" : diff2 < 1 ? "sameDay" : diff2 < 2 ? "nextDay" : diff2 < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
      if (arguments.length === 1) {
        if (!arguments[0]) {
          time = void 0;
          formats = void 0;
        } else if (isMomentInput(arguments[0])) {
          time = arguments[0];
          formats = void 0;
        } else if (isCalendarSpec(arguments[0])) {
          formats = arguments[0];
          time = void 0;
        }
      }
      var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format2 = hooks2.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format2]) ? formats[format2].call(this, now3) : formats[format2]);
      return this.format(
        output || this.localeData().calendar(format2, this, createLocal(now3))
      );
    }
    function clone() {
      return new Moment(this);
    }
    function isAfter(input, units2) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units2 = normalizeUnits(units2) || "millisecond";
      if (units2 === "millisecond") {
        return this.valueOf() > localInput.valueOf();
      } else {
        return localInput.valueOf() < this.clone().startOf(units2).valueOf();
      }
    }
    function isBefore(input, units2) {
      var localInput = isMoment(input) ? input : createLocal(input);
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units2 = normalizeUnits(units2) || "millisecond";
      if (units2 === "millisecond") {
        return this.valueOf() < localInput.valueOf();
      } else {
        return this.clone().endOf(units2).valueOf() < localInput.valueOf();
      }
    }
    function isBetween(from2, to2, units2, inclusivity) {
      var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to2) ? to2 : createLocal(to2);
      if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
        return false;
      }
      inclusivity = inclusivity || "()";
      return (inclusivity[0] === "(" ? this.isAfter(localFrom, units2) : !this.isBefore(localFrom, units2)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units2) : !this.isAfter(localTo, units2));
    }
    function isSame(input, units2) {
      var localInput = isMoment(input) ? input : createLocal(input), inputMs;
      if (!(this.isValid() && localInput.isValid())) {
        return false;
      }
      units2 = normalizeUnits(units2) || "millisecond";
      if (units2 === "millisecond") {
        return this.valueOf() === localInput.valueOf();
      } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units2).valueOf() <= inputMs && inputMs <= this.clone().endOf(units2).valueOf();
      }
    }
    function isSameOrAfter(input, units2) {
      return this.isSame(input, units2) || this.isAfter(input, units2);
    }
    function isSameOrBefore(input, units2) {
      return this.isSame(input, units2) || this.isBefore(input, units2);
    }
    function diff(input, units2, asFloat) {
      var that, zoneDelta, output;
      if (!this.isValid()) {
        return NaN;
      }
      that = cloneWithOffset(input, this);
      if (!that.isValid()) {
        return NaN;
      }
      zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
      units2 = normalizeUnits(units2);
      switch (units2) {
        case "year":
          output = monthDiff(this, that) / 12;
          break;
        case "month":
          output = monthDiff(this, that);
          break;
        case "quarter":
          output = monthDiff(this, that) / 3;
          break;
        case "second":
          output = (this - that) / 1e3;
          break;
        case "minute":
          output = (this - that) / 6e4;
          break;
        case "hour":
          output = (this - that) / 36e5;
          break;
        case "day":
          output = (this - that - zoneDelta) / 864e5;
          break;
        case "week":
          output = (this - that - zoneDelta) / 6048e5;
          break;
        default:
          output = this - that;
      }
      return asFloat ? output : absFloor(output);
    }
    function monthDiff(a, b) {
      if (a.date() < b.date()) {
        return -monthDiff(b, a);
      }
      var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
      if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, "months");
        adjust = (b - anchor) / (anchor - anchor2);
      } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, "months");
        adjust = (b - anchor) / (anchor2 - anchor);
      }
      return -(wholeMonthDiff + adjust) || 0;
    }
    hooks2.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
    hooks2.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    function toString() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString(keepOffset) {
      if (!this.isValid()) {
        return null;
      }
      var utc = keepOffset !== true, m = utc ? this.clone().utc() : this;
      if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(
          m,
          utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
        );
      }
      if (isFunction(Date.prototype.toISOString)) {
        if (utc) {
          return this.toDate().toISOString();
        } else {
          return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m, "Z"));
        }
      }
      return formatMoment(
        m,
        utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
      );
    }
    function inspect() {
      if (!this.isValid()) {
        return "moment.invalid(/* " + this._i + " */)";
      }
      var func = "moment", zone = "", prefix, year, datetime, suffix;
      if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
        zone = "Z";
      }
      prefix = "[" + func + '("]';
      year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
      datetime = "-MM-DD[T]HH:mm:ss.SSS";
      suffix = zone + '[")]';
      return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
      if (!inputString) {
        inputString = this.isUtc() ? hooks2.defaultFormatUtc : hooks2.defaultFormat;
      }
      var output = formatMoment(this, inputString);
      return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function fromNow(withoutSuffix) {
      return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
      if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
        return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
      } else {
        return this.localeData().invalidDate();
      }
    }
    function toNow(withoutSuffix) {
      return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
      var newLocaleData;
      if (key === void 0) {
        return this._locale._abbr;
      } else {
        newLocaleData = getLocale2(key);
        if (newLocaleData != null) {
          this._locale = newLocaleData;
        }
        return this;
      }
    }
    var lang = deprecate(
      "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
      function(key) {
        if (key === void 0) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      }
    );
    function localeData() {
      return this._locale;
    }
    var MS_PER_SECOND = 1e3, MS_PER_MINUTE = 60 * MS_PER_SECOND, MS_PER_HOUR = 60 * MS_PER_MINUTE, MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
    function mod$1(dividend, divisor) {
      return (dividend % divisor + divisor) % divisor;
    }
    function localStartOfDate(y2, m, d) {
      if (y2 < 100 && y2 >= 0) {
        return new Date(y2 + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return new Date(y2, m, d).valueOf();
      }
    }
    function utcStartOfDate(y2, m, d) {
      if (y2 < 100 && y2 >= 0) {
        return Date.UTC(y2 + 400, m, d) - MS_PER_400_YEARS;
      } else {
        return Date.UTC(y2, m, d);
      }
    }
    function startOf(units2) {
      var time, startOfDate;
      units2 = normalizeUnits(units2);
      if (units2 === void 0 || units2 === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units2) {
        case "year":
          time = startOfDate(this.year(), 0, 1);
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3,
            1
          );
          break;
        case "month":
          time = startOfDate(this.year(), this.month(), 1);
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday()
          );
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1)
          );
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date());
          break;
        case "hour":
          time = this._d.valueOf();
          time -= mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          );
          break;
        case "minute":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_MINUTE);
          break;
        case "second":
          time = this._d.valueOf();
          time -= mod$1(time, MS_PER_SECOND);
          break;
      }
      this._d.setTime(time);
      hooks2.updateOffset(this, true);
      return this;
    }
    function endOf(units2) {
      var time, startOfDate;
      units2 = normalizeUnits(units2);
      if (units2 === void 0 || units2 === "millisecond" || !this.isValid()) {
        return this;
      }
      startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
      switch (units2) {
        case "year":
          time = startOfDate(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          time = startOfDate(
            this.year(),
            this.month() - this.month() % 3 + 3,
            1
          ) - 1;
          break;
        case "month":
          time = startOfDate(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - this.weekday() + 7
          ) - 1;
          break;
        case "isoWeek":
          time = startOfDate(
            this.year(),
            this.month(),
            this.date() - (this.isoWeekday() - 1) + 7
          ) - 1;
          break;
        case "day":
        case "date":
          time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          time = this._d.valueOf();
          time += MS_PER_HOUR - mod$1(
            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
            MS_PER_HOUR
          ) - 1;
          break;
        case "minute":
          time = this._d.valueOf();
          time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
          break;
        case "second":
          time = this._d.valueOf();
          time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
          break;
      }
      this._d.setTime(time);
      hooks2.updateOffset(this, true);
      return this;
    }
    function valueOf() {
      return this._d.valueOf() - (this._offset || 0) * 6e4;
    }
    function unix() {
      return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
      return new Date(this.valueOf());
    }
    function toArray() {
      var m = this;
      return [
        m.year(),
        m.month(),
        m.date(),
        m.hour(),
        m.minute(),
        m.second(),
        m.millisecond()
      ];
    }
    function toObject() {
      var m = this;
      return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
      };
    }
    function toJSON() {
      return this.isValid() ? this.toISOString() : null;
    }
    function isValid$2() {
      return isValid2(this);
    }
    function parsingFlags() {
      return extend2({}, getParsingFlags(this));
    }
    function invalidAt() {
      return getParsingFlags(this).overflow;
    }
    function creationData() {
      return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
      };
    }
    addFormatToken("N", 0, 0, "eraAbbr");
    addFormatToken("NN", 0, 0, "eraAbbr");
    addFormatToken("NNN", 0, 0, "eraAbbr");
    addFormatToken("NNNN", 0, 0, "eraName");
    addFormatToken("NNNNN", 0, 0, "eraNarrow");
    addFormatToken("y", ["y", 1], "yo", "eraYear");
    addFormatToken("y", ["yy", 2], 0, "eraYear");
    addFormatToken("y", ["yyy", 3], 0, "eraYear");
    addFormatToken("y", ["yyyy", 4], 0, "eraYear");
    addRegexToken("N", matchEraAbbr);
    addRegexToken("NN", matchEraAbbr);
    addRegexToken("NNN", matchEraAbbr);
    addRegexToken("NNNN", matchEraName);
    addRegexToken("NNNNN", matchEraNarrow);
    addParseToken(
      ["N", "NN", "NNN", "NNNN", "NNNNN"],
      function(input, array2, config, token2) {
        var era = config._locale.erasParse(input, token2, config._strict);
        if (era) {
          getParsingFlags(config).era = era;
        } else {
          getParsingFlags(config).invalidEra = input;
        }
      }
    );
    addRegexToken("y", matchUnsigned);
    addRegexToken("yy", matchUnsigned);
    addRegexToken("yyy", matchUnsigned);
    addRegexToken("yyyy", matchUnsigned);
    addRegexToken("yo", matchEraYearOrdinal);
    addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
    addParseToken(["yo"], function(input, array2, config, token2) {
      var match;
      if (config._locale._eraYearOrdinalRegex) {
        match = input.match(config._locale._eraYearOrdinalRegex);
      }
      if (config._locale.eraYearOrdinalParse) {
        array2[YEAR] = config._locale.eraYearOrdinalParse(input, match);
      } else {
        array2[YEAR] = parseInt(input, 10);
      }
    });
    function localeEras(m, format2) {
      var i, l, date, eras = this._eras || getLocale2("en")._eras;
      for (i = 0, l = eras.length; i < l; ++i) {
        switch (typeof eras[i].since) {
          case "string":
            date = hooks2(eras[i].since).startOf("day");
            eras[i].since = date.valueOf();
            break;
        }
        switch (typeof eras[i].until) {
          case "undefined":
            eras[i].until = Infinity;
            break;
          case "string":
            date = hooks2(eras[i].until).startOf("day").valueOf();
            eras[i].until = date.valueOf();
            break;
        }
      }
      return eras;
    }
    function localeErasParse(eraName, format2, strict) {
      var i, l, eras = this.eras(), name, abbr, narrow;
      eraName = eraName.toUpperCase();
      for (i = 0, l = eras.length; i < l; ++i) {
        name = eras[i].name.toUpperCase();
        abbr = eras[i].abbr.toUpperCase();
        narrow = eras[i].narrow.toUpperCase();
        if (strict) {
          switch (format2) {
            case "N":
            case "NN":
            case "NNN":
              if (abbr === eraName) {
                return eras[i];
              }
              break;
            case "NNNN":
              if (name === eraName) {
                return eras[i];
              }
              break;
            case "NNNNN":
              if (narrow === eraName) {
                return eras[i];
              }
              break;
          }
        } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
          return eras[i];
        }
      }
    }
    function localeErasConvertYear(era, year) {
      var dir = era.since <= era.until ? 1 : -1;
      if (year === void 0) {
        return hooks2(era.since).year();
      } else {
        return hooks2(era.since).year() + (year - era.offset) * dir;
      }
    }
    function getEraName() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].name;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].name;
        }
      }
      return "";
    }
    function getEraNarrow() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].narrow;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].narrow;
        }
      }
      return "";
    }
    function getEraAbbr() {
      var i, l, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until) {
          return eras[i].abbr;
        }
        if (eras[i].until <= val && val <= eras[i].since) {
          return eras[i].abbr;
        }
      }
      return "";
    }
    function getEraYear() {
      var i, l, dir, val, eras = this.localeData().eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        dir = eras[i].since <= eras[i].until ? 1 : -1;
        val = this.clone().startOf("day").valueOf();
        if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
          return (this.year() - hooks2(eras[i].since).year()) * dir + eras[i].offset;
        }
      }
      return this.year();
    }
    function erasNameRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNameRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNameRegex : this._erasRegex;
    }
    function erasAbbrRegex(isStrict) {
      if (!hasOwnProp(this, "_erasAbbrRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasAbbrRegex : this._erasRegex;
    }
    function erasNarrowRegex(isStrict) {
      if (!hasOwnProp(this, "_erasNarrowRegex")) {
        computeErasParse.call(this);
      }
      return isStrict ? this._erasNarrowRegex : this._erasRegex;
    }
    function matchEraAbbr(isStrict, locale2) {
      return locale2.erasAbbrRegex(isStrict);
    }
    function matchEraName(isStrict, locale2) {
      return locale2.erasNameRegex(isStrict);
    }
    function matchEraNarrow(isStrict, locale2) {
      return locale2.erasNarrowRegex(isStrict);
    }
    function matchEraYearOrdinal(isStrict, locale2) {
      return locale2._eraYearOrdinalRegex || matchUnsigned;
    }
    function computeErasParse() {
      var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i, l, erasName, erasAbbr, erasNarrow, eras = this.eras();
      for (i = 0, l = eras.length; i < l; ++i) {
        erasName = regexEscape(eras[i].name);
        erasAbbr = regexEscape(eras[i].abbr);
        erasNarrow = regexEscape(eras[i].narrow);
        namePieces.push(erasName);
        abbrPieces.push(erasAbbr);
        narrowPieces.push(erasNarrow);
        mixedPieces.push(erasName);
        mixedPieces.push(erasAbbr);
        mixedPieces.push(erasNarrow);
      }
      this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
      this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
      this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
      this._erasNarrowRegex = new RegExp(
        "^(" + narrowPieces.join("|") + ")",
        "i"
      );
    }
    addFormatToken(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    });
    addFormatToken(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    });
    function addWeekYearFormatToken(token2, getter) {
      addFormatToken(0, [token2, token2.length], 0, getter);
    }
    addWeekYearFormatToken("gggg", "weekYear");
    addWeekYearFormatToken("ggggg", "weekYear");
    addWeekYearFormatToken("GGGG", "isoWeekYear");
    addWeekYearFormatToken("GGGGG", "isoWeekYear");
    addRegexToken("G", matchSigned);
    addRegexToken("g", matchSigned);
    addRegexToken("GG", match1to2, match2);
    addRegexToken("gg", match1to2, match2);
    addRegexToken("GGGG", match1to4, match4);
    addRegexToken("gggg", match1to4, match4);
    addRegexToken("GGGGG", match1to6, match6);
    addRegexToken("ggggg", match1to6, match6);
    addWeekParseToken(
      ["gggg", "ggggg", "GGGG", "GGGGG"],
      function(input, week2, config, token2) {
        week2[token2.substr(0, 2)] = toInt(input);
      }
    );
    addWeekParseToken(["gg", "GG"], function(input, week2, config, token2) {
      week2[token2] = hooks2.parseTwoDigitYear(input);
    });
    function getSetWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.week(),
        this.weekday() + this.localeData()._week.dow,
        this.localeData()._week.dow,
        this.localeData()._week.doy
      );
    }
    function getSetISOWeekYear(input) {
      return getSetWeekYearHelper.call(
        this,
        input,
        this.isoWeek(),
        this.isoWeekday(),
        1,
        4
      );
    }
    function getISOWeeksInYear() {
      return weeksInYear(this.year(), 1, 4);
    }
    function getISOWeeksInISOWeekYear() {
      return weeksInYear(this.isoWeekYear(), 1, 4);
    }
    function getWeeksInYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getWeeksInWeekYear() {
      var weekInfo = this.localeData()._week;
      return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week2, weekday, dow, doy) {
      var weeksTarget;
      if (input == null) {
        return weekOfYear(this, dow, doy).year;
      } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week2 > weeksTarget) {
          week2 = weeksTarget;
        }
        return setWeekAll.call(this, input, week2, weekday, dow, doy);
      }
    }
    function setWeekAll(weekYear, week2, weekday, dow, doy) {
      var dayOfYearData = dayOfYearFromWeeks(weekYear, week2, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
      this.year(date.getUTCFullYear());
      this.month(date.getUTCMonth());
      this.date(date.getUTCDate());
      return this;
    }
    addFormatToken("Q", 0, "Qo", "quarter");
    addRegexToken("Q", match1);
    addParseToken("Q", function(input, array2) {
      array2[MONTH] = (toInt(input) - 1) * 3;
    });
    function getSetQuarter(input) {
      return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }
    addFormatToken("D", ["DD", 2], "Do", "date");
    addRegexToken("D", match1to2, match1to2NoLeadingZero);
    addRegexToken("DD", match1to2, match2);
    addRegexToken("Do", function(isStrict, locale2) {
      return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
    });
    addParseToken(["D", "DD"], DATE);
    addParseToken("Do", function(input, array2) {
      array2[DATE] = toInt(input.match(match1to2)[0]);
    });
    var getSetDayOfMonth = makeGetSet("Date", true);
    addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
    addRegexToken("DDD", match1to3);
    addRegexToken("DDDD", match3);
    addParseToken(["DDD", "DDDD"], function(input, array2, config) {
      config._dayOfYear = toInt(input);
    });
    function getSetDayOfYear(input) {
      var dayOfYear = Math.round(
        (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
      ) + 1;
      return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    addFormatToken("m", ["mm", 2], 0, "minute");
    addRegexToken("m", match1to2, match1to2HasZero);
    addRegexToken("mm", match1to2, match2);
    addParseToken(["m", "mm"], MINUTE);
    var getSetMinute = makeGetSet("Minutes", false);
    addFormatToken("s", ["ss", 2], 0, "second");
    addRegexToken("s", match1to2, match1to2HasZero);
    addRegexToken("ss", match1to2, match2);
    addParseToken(["s", "ss"], SECOND);
    var getSetSecond = makeGetSet("Seconds", false);
    addFormatToken("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    });
    addFormatToken(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    });
    addFormatToken(0, ["SSS", 3], 0, "millisecond");
    addFormatToken(0, ["SSSS", 4], 0, function() {
      return this.millisecond() * 10;
    });
    addFormatToken(0, ["SSSSS", 5], 0, function() {
      return this.millisecond() * 100;
    });
    addFormatToken(0, ["SSSSSS", 6], 0, function() {
      return this.millisecond() * 1e3;
    });
    addFormatToken(0, ["SSSSSSS", 7], 0, function() {
      return this.millisecond() * 1e4;
    });
    addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
      return this.millisecond() * 1e5;
    });
    addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
      return this.millisecond() * 1e6;
    });
    addRegexToken("S", match1to3, match1);
    addRegexToken("SS", match1to3, match2);
    addRegexToken("SSS", match1to3, match3);
    var token, getSetMillisecond;
    for (token = "SSSS"; token.length <= 9; token += "S") {
      addRegexToken(token, matchUnsigned);
    }
    function parseMs(input, array2) {
      array2[MILLISECOND] = toInt(("0." + input) * 1e3);
    }
    for (token = "S"; token.length <= 9; token += "S") {
      addParseToken(token, parseMs);
    }
    getSetMillisecond = makeGetSet("Milliseconds", false);
    addFormatToken("z", 0, 0, "zoneAbbr");
    addFormatToken("zz", 0, 0, "zoneName");
    function getZoneAbbr() {
      return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }
    var proto = Moment.prototype;
    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    if (typeof Symbol !== "undefined" && Symbol.for != null) {
      proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
        return "Moment<" + this.format() + ">";
      };
    }
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.eraName = getEraName;
    proto.eraNarrow = getEraNarrow;
    proto.eraAbbr = getEraAbbr;
    proto.eraYear = getEraYear;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.weeksInWeekYear = getWeeksInWeekYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate(
      "dates accessor is deprecated. Use date instead.",
      getSetDayOfMonth
    );
    proto.months = deprecate(
      "months accessor is deprecated. Use month instead",
      getSetMonth
    );
    proto.years = deprecate(
      "years accessor is deprecated. Use year instead",
      getSetYear
    );
    proto.zone = deprecate(
      "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
      getSetZone
    );
    proto.isDSTShifted = deprecate(
      "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
      isDaylightSavingTimeShifted
    );
    function createUnix(input) {
      return createLocal(input * 1e3);
    }
    function createInZone() {
      return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
      return string;
    }
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set2;
    proto$1.eras = localeEras;
    proto$1.erasParse = localeErasParse;
    proto$1.erasConvertYear = localeErasConvertYear;
    proto$1.erasAbbrRegex = erasAbbrRegex;
    proto$1.erasNameRegex = erasNameRegex;
    proto$1.erasNarrowRegex = erasNarrowRegex;
    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;
    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;
    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;
    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;
    function get$12(format2, index2, field, setter) {
      var locale2 = getLocale2(), utc = createUTC().set(setter, index2);
      return locale2[field](utc, format2);
    }
    function listMonthsImpl(format2, index2, field) {
      if (isNumber(format2)) {
        index2 = format2;
        format2 = void 0;
      }
      format2 = format2 || "";
      if (index2 != null) {
        return get$12(format2, index2, field, "month");
      }
      var i, out = [];
      for (i = 0; i < 12; i++) {
        out[i] = get$12(format2, i, field, "month");
      }
      return out;
    }
    function listWeekdaysImpl(localeSorted, format2, index2, field) {
      if (typeof localeSorted === "boolean") {
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      } else {
        format2 = localeSorted;
        index2 = format2;
        localeSorted = false;
        if (isNumber(format2)) {
          index2 = format2;
          format2 = void 0;
        }
        format2 = format2 || "";
      }
      var locale2 = getLocale2(), shift = localeSorted ? locale2._week.dow : 0, i, out = [];
      if (index2 != null) {
        return get$12(format2, (index2 + shift) % 7, field, "day");
      }
      for (i = 0; i < 7; i++) {
        out[i] = get$12(format2, (i + shift) % 7, field, "day");
      }
      return out;
    }
    function listMonths(format2, index2) {
      return listMonthsImpl(format2, index2, "months");
    }
    function listMonthsShort(format2, index2) {
      return listMonthsImpl(format2, index2, "monthsShort");
    }
    function listWeekdays(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format2, index2) {
      return listWeekdaysImpl(localeSorted, format2, index2, "weekdaysMin");
    }
    getSetGlobalLocale("en", {
      eras: [
        {
          since: "0001-01-01",
          until: Infinity,
          offset: 1,
          name: "Anno Domini",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "Before Christ",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = toInt(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    hooks2.lang = deprecate(
      "moment.lang is deprecated. Use moment.locale instead.",
      getSetGlobalLocale
    );
    hooks2.langData = deprecate(
      "moment.langData is deprecated. Use moment.localeData instead.",
      getLocale2
    );
    var mathAbs = Math.abs;
    function abs() {
      var data = this._data;
      this._milliseconds = mathAbs(this._milliseconds);
      this._days = mathAbs(this._days);
      this._months = mathAbs(this._months);
      data.milliseconds = mathAbs(data.milliseconds);
      data.seconds = mathAbs(data.seconds);
      data.minutes = mathAbs(data.minutes);
      data.hours = mathAbs(data.hours);
      data.months = mathAbs(data.months);
      data.years = mathAbs(data.years);
      return this;
    }
    function addSubtract$1(duration, input, value, direction) {
      var other = createDuration(input, value);
      duration._milliseconds += direction * other._milliseconds;
      duration._days += direction * other._days;
      duration._months += direction * other._months;
      return duration._bubble();
    }
    function add$1(input, value) {
      return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
      return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
      if (number < 0) {
        return Math.floor(number);
      } else {
        return Math.ceil(number);
      }
    }
    function bubble() {
      var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
      if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
        milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
        days2 = 0;
        months2 = 0;
      }
      data.milliseconds = milliseconds2 % 1e3;
      seconds2 = absFloor(milliseconds2 / 1e3);
      data.seconds = seconds2 % 60;
      minutes2 = absFloor(seconds2 / 60);
      data.minutes = minutes2 % 60;
      hours2 = absFloor(minutes2 / 60);
      data.hours = hours2 % 24;
      days2 += absFloor(hours2 / 24);
      monthsFromDays = absFloor(daysToMonths(days2));
      months2 += monthsFromDays;
      days2 -= absCeil(monthsToDays(monthsFromDays));
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      data.days = days2;
      data.months = months2;
      data.years = years2;
      return this;
    }
    function daysToMonths(days2) {
      return days2 * 4800 / 146097;
    }
    function monthsToDays(months2) {
      return months2 * 146097 / 4800;
    }
    function as(units2) {
      if (!this.isValid()) {
        return NaN;
      }
      var days2, months2, milliseconds2 = this._milliseconds;
      units2 = normalizeUnits(units2);
      if (units2 === "month" || units2 === "quarter" || units2 === "year") {
        days2 = this._days + milliseconds2 / 864e5;
        months2 = this._months + daysToMonths(days2);
        switch (units2) {
          case "month":
            return months2;
          case "quarter":
            return months2 / 3;
          case "year":
            return months2 / 12;
        }
      } else {
        days2 = this._days + Math.round(monthsToDays(this._months));
        switch (units2) {
          case "week":
            return days2 / 7 + milliseconds2 / 6048e5;
          case "day":
            return days2 + milliseconds2 / 864e5;
          case "hour":
            return days2 * 24 + milliseconds2 / 36e5;
          case "minute":
            return days2 * 1440 + milliseconds2 / 6e4;
          case "second":
            return days2 * 86400 + milliseconds2 / 1e3;
          case "millisecond":
            return Math.floor(days2 * 864e5) + milliseconds2;
          default:
            throw new Error("Unknown unit " + units2);
        }
      }
    }
    function makeAs(alias) {
      return function() {
        return this.as(alias);
      };
    }
    var asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asQuarters = makeAs("Q"), asYears = makeAs("y"), valueOf$1 = asMilliseconds;
    function clone$1() {
      return createDuration(this);
    }
    function get$2(units2) {
      units2 = normalizeUnits(units2);
      return this.isValid() ? this[units2 + "s"]() : NaN;
    }
    function makeGetter(name) {
      return function() {
        return this.isValid() ? this._data[name] : NaN;
      };
    }
    var milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years");
    function weeks() {
      return absFloor(this.days() / 7);
    }
    var round = Math.round, thresholds = {
      ss: 44,
      // a few seconds to seconds
      s: 45,
      // seconds to minute
      m: 45,
      // minutes to hour
      h: 22,
      // hours to day
      d: 26,
      // days to month/week
      w: null,
      // weeks to month
      M: 11
      // months to year
    };
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale2) {
      return locale2.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
      var duration = createDuration(posNegDuration).abs(), seconds2 = round(duration.as("s")), minutes2 = round(duration.as("m")), hours2 = round(duration.as("h")), days2 = round(duration.as("d")), months2 = round(duration.as("M")), weeks2 = round(duration.as("w")), years2 = round(duration.as("y")), a = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
      if (thresholds2.w != null) {
        a = a || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
      }
      a = a || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
      a[2] = withoutSuffix;
      a[3] = +posNegDuration > 0;
      a[4] = locale2;
      return substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
      if (roundingFunction === void 0) {
        return round;
      }
      if (typeof roundingFunction === "function") {
        round = roundingFunction;
        return true;
      }
      return false;
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
      if (thresholds[threshold] === void 0) {
        return false;
      }
      if (limit === void 0) {
        return thresholds[threshold];
      }
      thresholds[threshold] = limit;
      if (threshold === "s") {
        thresholds.ss = limit - 1;
      }
      return true;
    }
    function humanize(argWithSuffix, argThresholds) {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var withSuffix = false, th = thresholds, locale2, output;
      if (typeof argWithSuffix === "object") {
        argThresholds = argWithSuffix;
        argWithSuffix = false;
      }
      if (typeof argWithSuffix === "boolean") {
        withSuffix = argWithSuffix;
      }
      if (typeof argThresholds === "object") {
        th = Object.assign({}, thresholds, argThresholds);
        if (argThresholds.s != null && argThresholds.ss == null) {
          th.ss = argThresholds.s - 1;
        }
      }
      locale2 = this.localeData();
      output = relativeTime$1(this, !withSuffix, th, locale2);
      if (withSuffix) {
        output = locale2.pastFuture(+this, output);
      }
      return locale2.postformat(output);
    }
    var abs$1 = Math.abs;
    function sign(x2) {
      return (x2 > 0) - (x2 < 0) || +x2;
    }
    function toISOString$1() {
      if (!this.isValid()) {
        return this.localeData().invalidDate();
      }
      var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s2, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
      if (!total) {
        return "P0D";
      }
      minutes2 = absFloor(seconds2 / 60);
      hours2 = absFloor(minutes2 / 60);
      seconds2 %= 60;
      minutes2 %= 60;
      years2 = absFloor(months2 / 12);
      months2 %= 12;
      s2 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
      totalSign = total < 0 ? "-" : "";
      ymSign = sign(this._months) !== sign(total) ? "-" : "";
      daysSign = sign(this._days) !== sign(total) ? "-" : "";
      hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
      return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s2 + "S" : "");
    }
    var proto$2 = Duration.prototype;
    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asQuarters = asQuarters;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;
    proto$2.toIsoString = deprecate(
      "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
      toISOString$1
    );
    proto$2.lang = lang;
    addFormatToken("X", 0, 0, "unix");
    addFormatToken("x", 0, 0, "valueOf");
    addRegexToken("x", matchSigned);
    addRegexToken("X", matchTimestamp);
    addParseToken("X", function(input, array2, config) {
      config._d = new Date(parseFloat(input) * 1e3);
    });
    addParseToken("x", function(input, array2, config) {
      config._d = new Date(toInt(input));
    });
    //! moment.js
    hooks2.version = "2.30.1";
    setHookCallback(createLocal);
    hooks2.fn = proto;
    hooks2.min = min2;
    hooks2.max = max2;
    hooks2.now = now2;
    hooks2.utc = createUTC;
    hooks2.unix = createUnix;
    hooks2.months = listMonths;
    hooks2.isDate = isDate;
    hooks2.locale = getSetGlobalLocale;
    hooks2.invalid = createInvalid;
    hooks2.duration = createDuration;
    hooks2.isMoment = isMoment;
    hooks2.weekdays = listWeekdays;
    hooks2.parseZone = createInZone;
    hooks2.localeData = getLocale2;
    hooks2.isDuration = isDuration;
    hooks2.monthsShort = listMonthsShort;
    hooks2.weekdaysMin = listWeekdaysMin;
    hooks2.defineLocale = defineLocale;
    hooks2.updateLocale = updateLocale;
    hooks2.locales = listLocales;
    hooks2.weekdaysShort = listWeekdaysShort;
    hooks2.normalizeUnits = normalizeUnits;
    hooks2.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks2.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks2.calendarFormat = getCalendarFormat;
    hooks2.prototype = proto;
    hooks2.HTML5_FMT = {
      DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
      // <input type="datetime-local" />
      DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
      // <input type="datetime-local" step="1" />
      DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
      // <input type="datetime-local" step="0.001" />
      DATE: "YYYY-MM-DD",
      // <input type="date" />
      TIME: "HH:mm",
      // <input type="time" />
      TIME_SECONDS: "HH:mm:ss",
      // <input type="time" step="1" />
      TIME_MS: "HH:mm:ss.SSS",
      // <input type="time" step="0.001" />
      WEEK: "GGGG-[W]WW",
      // <input type="week" />
      MONTH: "YYYY-MM"
      // <input type="month" />
    };
    //! moment.js locale configuration
    hooks2.defineLocale("af", {
      months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
      weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split(
        "_"
      ),
      weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
      weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
      meridiemParse: /vm|nm/i,
      isPM: function(input) {
        return /^nm$/i.test(input);
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 12) {
          return isLower ? "vm" : "VM";
        } else {
          return isLower ? "nm" : "NM";
        }
      },
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Vandag om] LT",
        nextDay: "[Mre om] LT",
        nextWeek: "dddd [om] LT",
        lastDay: "[Gister om] LT",
        lastWeek: "[Laas] dddd [om] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "oor %s",
        past: "%s gelede",
        s: "'n paar sekondes",
        ss: "%d sekondes",
        m: "'n minuut",
        mm: "%d minute",
        h: "'n uur",
        hh: "%d ure",
        d: "'n dag",
        dd: "%d dae",
        M: "'n maand",
        MM: "%d maande",
        y: "'n jaar",
        yy: "%d jaar"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function(number) {
        return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
      },
      week: {
        dow: 1,
        // Maandag is die eerste dag van die week.
        doy: 4
        // Die week wat die 4de Januarie bevat is die eerste week van die jaar.
      }
    });
    //! moment.js locale configuration
    var pluralForm = function(n2) {
      return n2 === 0 ? 0 : n2 === 1 ? 1 : n2 === 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5;
    }, plurals = {
      s: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      m: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      h: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      d: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      M: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      y: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ]
    }, pluralize = function(u) {
      return function(number, withoutSuffix, string, isFuture) {
        var f = pluralForm(number), str = plurals[u][pluralForm(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    }, months$1 = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
    hooks2.defineLocale("ar-dz", {
      months: months$1,
      monthsShort: months$1,
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "D/M/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: pluralize("s"),
        ss: pluralize("s"),
        m: pluralize("m"),
        mm: pluralize("m"),
        h: pluralize("h"),
        hh: pluralize("h"),
        d: pluralize("d"),
        dd: pluralize("d"),
        M: pluralize("M"),
        MM: pluralize("M"),
        y: pluralize("y"),
        yy: pluralize("y")
      },
      postformat: function(string) {
        return string.replace(/,/g, "");
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ar-kw", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap = {
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      0: "0"
    }, pluralForm$1 = function(n2) {
      return n2 === 0 ? 0 : n2 === 1 ? 1 : n2 === 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5;
    }, plurals$1 = {
      s: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      m: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      h: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      d: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      M: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      y: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ]
    }, pluralize$1 = function(u) {
      return function(number, withoutSuffix, string, isFuture) {
        var f = pluralForm$1(number), str = plurals$1[u][pluralForm$1(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    }, months$2 = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
    hooks2.defineLocale("ar-ly", {
      months: months$2,
      monthsShort: months$2,
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "D/M/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: pluralize$1("s"),
        ss: pluralize$1("s"),
        m: pluralize$1("m"),
        mm: pluralize$1("m"),
        h: pluralize$1("h"),
        hh: pluralize$1("h"),
        d: pluralize$1("d"),
        dd: pluralize$1("d"),
        M: pluralize$1("M"),
        MM: pluralize$1("M"),
        y: pluralize$1("y"),
        yy: pluralize$1("y")
      },
      preparse: function(string) {
        return string.replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap[match];
        }).replace(/,/g, "");
      },
      week: {
        dow: 6,
        // Saturday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ar-ma", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$1 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("ar-ps", {
      months: " _________ _ _ ".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap[match];
        }).split("").reverse().join("").replace(/[](?![\u062a\u0643])/g, function(match) {
          return numberMap[match];
        }).split("").reverse().join("").replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$1[match];
        }).replace(/,/g, "");
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$2 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$1 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("ar-sa", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$1[match];
        }).replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$2[match];
        }).replace(/,/g, "");
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ar-tn", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$3 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$2 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    }, pluralForm$2 = function(n2) {
      return n2 === 0 ? 0 : n2 === 1 ? 1 : n2 === 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5;
    }, plurals$2 = {
      s: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      m: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      h: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      d: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      M: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ],
      y: [
        "  ",
        " ",
        ["", ""],
        "%d ",
        "%d ",
        "%d "
      ]
    }, pluralize$2 = function(u) {
      return function(number, withoutSuffix, string, isFuture) {
        var f = pluralForm$2(number), str = plurals$2[u][pluralForm$2(number)];
        if (f === 2) {
          str = str[withoutSuffix ? 0 : 1];
        }
        return str.replace(/%d/i, number);
      };
    }, months$3 = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
    hooks2.defineLocale("ar", {
      months: months$3,
      monthsShort: months$3,
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "D/M/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[  ] LT",
        nextDay: "[  ] LT",
        nextWeek: "dddd [ ] LT",
        lastDay: "[  ] LT",
        lastWeek: "dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: pluralize$2("s"),
        ss: pluralize$2("s"),
        m: pluralize$2("m"),
        mm: pluralize$2("m"),
        h: pluralize$2("h"),
        hh: pluralize$2("h"),
        d: pluralize$2("d"),
        dd: pluralize$2("d"),
        M: pluralize$2("M"),
        MM: pluralize$2("M"),
        y: pluralize$2("y"),
        yy: pluralize$2("y")
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$2[match];
        }).replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$3[match];
        }).replace(/,/g, "");
      },
      week: {
        dow: 6,
        // Saturday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var suffixes = {
      1: "-inci",
      5: "-inci",
      8: "-inci",
      70: "-inci",
      80: "-inci",
      2: "-nci",
      7: "-nci",
      20: "-nci",
      50: "-nci",
      3: "-nc",
      4: "-nc",
      100: "-nc",
      6: "-nc",
      9: "-uncu",
      10: "-uncu",
      30: "-uncu",
      60: "-nc",
      90: "-nc"
    };
    hooks2.defineLocale("az", {
      months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split(
        "_"
      ),
      monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
      weekdays: "Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb".split(
        "_"
      ),
      weekdaysShort: "Baz_BzE_Ax_r_CAx_Cm_n".split("_"),
      weekdaysMin: "Bz_BE_A__CA_C_".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[bugn saat] LT",
        nextDay: "[sabah saat] LT",
        nextWeek: "[gln hft] dddd [saat] LT",
        lastDay: "[dnn] LT",
        lastWeek: "[ken hft] dddd [saat] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s sonra",
        past: "%s vvl",
        s: "bir ne saniy",
        ss: "%d saniy",
        m: "bir dqiq",
        mm: "%d dqiq",
        h: "bir saat",
        hh: "%d saat",
        d: "bir gn",
        dd: "%d gn",
        M: "bir ay",
        MM: "%d ay",
        y: "bir il",
        yy: "%d il"
      },
      meridiemParse: /gec|shr|gndz|axam/,
      isPM: function(input) {
        return /^(gndz|axam)$/.test(input);
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "gec";
        } else if (hour < 12) {
          return "shr";
        } else if (hour < 17) {
          return "gndz";
        } else {
          return "axam";
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
      ordinal: function(number) {
        if (number === 0) {
          return number + "-nc";
        }
        var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
        return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function plural(word, num) {
      var forms2 = word.split("_");
      return num % 10 === 1 && num % 100 !== 11 ? forms2[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms2[1] : forms2[2];
    }
    function relativeTimeWithPlural(number, withoutSuffix, key) {
      var format2 = {
        ss: withoutSuffix ? "__" : "__",
        mm: withoutSuffix ? "__" : "__",
        hh: withoutSuffix ? "__" : "__",
        dd: "__",
        MM: "__",
        yy: "__"
      };
      if (key === "m") {
        return withoutSuffix ? "" : "";
      } else if (key === "h") {
        return withoutSuffix ? "" : "";
      } else {
        return number + " " + plural(format2[key], +number);
      }
    }
    hooks2.defineLocale("be", {
      months: {
        format: "___________".split(
          "_"
        ),
        standalone: "___________".split(
          "_"
        )
      },
      monthsShort: "___________".split("_"),
      weekdays: {
        format: "______".split(
          "_"
        ),
        standalone: "______".split(
          "_"
        ),
        isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
      },
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY .",
        LLL: "D MMMM YYYY ., HH:mm",
        LLLL: "dddd, D MMMM YYYY ., HH:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        lastDay: "[ ] LT",
        nextWeek: function() {
          return "[] dddd [] LT";
        },
        lastWeek: function() {
          switch (this.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
              return "[ ] dddd [] LT";
            case 1:
            case 2:
            case 4:
              return "[ ] dddd [] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s ",
        s: " ",
        m: relativeTimeWithPlural,
        mm: relativeTimeWithPlural,
        h: relativeTimeWithPlural,
        hh: relativeTimeWithPlural,
        d: "",
        dd: relativeTimeWithPlural,
        M: "",
        MM: relativeTimeWithPlural,
        y: "",
        yy: relativeTimeWithPlural
      },
      meridiemParse: /|||/,
      isPM: function(input) {
        return /^(|)$/.test(input);
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 17) {
          return "";
        } else {
          return "";
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
      ordinal: function(number, period) {
        switch (period) {
          case "M":
          case "d":
          case "DDD":
          case "w":
          case "W":
            return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + "-" : number + "-";
          case "D":
            return number + "-";
          default:
            return number;
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("bg", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "D.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY H:mm",
        LLLL: "dddd, D MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
            case 3:
            case 6:
              return "[] dddd [] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[] dddd [] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: " ",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        w: "",
        ww: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
      ordinal: function(number) {
        var lastDigit = number % 10, last2Digits = number % 100;
        if (number === 0) {
          return number + "-";
        } else if (last2Digits === 0) {
          return number + "-";
        } else if (last2Digits > 10 && last2Digits < 20) {
          return number + "-";
        } else if (lastDigit === 1) {
          return number + "-";
        } else if (lastDigit === 2) {
          return number + "-";
        } else if (lastDigit === 7 || lastDigit === 8) {
          return number + "-";
        } else {
          return number + "-";
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("bm", {
      months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo".split(
        "_"
      ),
      monthsShort: "Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des".split("_"),
      weekdays: "Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
      weekdaysShort: "Kar_Nt_Tar_Ara_Ala_Jum_Sib".split("_"),
      weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "MMMM [tile] D [san] YYYY",
        LLL: "MMMM [tile] D [san] YYYY [lr] HH:mm",
        LLLL: "dddd MMMM [tile] D [san] YYYY [lr] HH:mm"
      },
      calendar: {
        sameDay: "[Bi lr] LT",
        nextDay: "[Sini lr] LT",
        nextWeek: "dddd [don lr] LT",
        lastDay: "[Kunu lr] LT",
        lastWeek: "dddd [tmnen lr] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s kn",
        past: "a b %s b",
        s: "sanga dama dama",
        ss: "sekondi %d",
        m: "miniti kelen",
        mm: "miniti %d",
        h: "lr kelen",
        hh: "lr %d",
        d: "tile kelen",
        dd: "tile %d",
        M: "kalo kelen",
        MM: "kalo %d",
        y: "san kelen",
        yy: "san %d"
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$4 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$3 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("bn-bd", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm ",
        LTS: "A h:mm:ss ",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm ",
        LLLL: "dddd, D MMMM YYYY, A h:mm "
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$3[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$4[match];
        });
      },
      meridiemParse: /||||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 3 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 6) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 15) {
          return "";
        } else if (hour < 18) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$5 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$4 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("bn", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm ",
        LTS: "A h:mm:ss ",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm ",
        LLLL: "dddd, D MMMM YYYY, A h:mm "
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$4[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$5[match];
        });
      },
      meridiemParse: /||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" && hour >= 4 || meridiem2 === "" && hour < 5 || meridiem2 === "") {
          return hour + 12;
        } else {
          return hour;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 10) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$6 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$5 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("bo", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
        "_"
      ),
      monthsShortRegex: /^(\d{1,2})/,
      monthsParseExact: true,
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split(
        "_"
      ),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm",
        LTS: "A h:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm",
        LLLL: "dddd, D MMMM YYYY, A h:mm"
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[], LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$5[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$6[match];
        });
      },
      meridiemParse: /||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" && hour >= 4 || meridiem2 === "" && hour < 5 || meridiem2 === "") {
          return hour + 12;
        } else {
          return hour;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 10) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function relativeTimeWithMutation(number, withoutSuffix, key) {
      var format2 = {
        mm: "munutenn",
        MM: "miz",
        dd: "devezh"
      };
      return number + " " + mutation(format2[key], number);
    }
    function specialMutationForYears(number) {
      switch (lastNumber(number)) {
        case 1:
        case 3:
        case 4:
        case 5:
        case 9:
          return number + " bloaz";
        default:
          return number + " vloaz";
      }
    }
    function lastNumber(number) {
      if (number > 9) {
        return lastNumber(number % 10);
      }
      return number;
    }
    function mutation(text, number) {
      if (number === 2) {
        return softMutation(text);
      }
      return text;
    }
    function softMutation(text) {
      var mutationTable = {
        m: "v",
        b: "v",
        d: "z"
      };
      if (mutationTable[text.charAt(0)] === void 0) {
        return text;
      }
      return mutationTable[text.charAt(0)] + text.substring(1);
    }
    var monthsParse = [
      /^gen/i,
      /^c[\']hwe/i,
      /^meu/i,
      /^ebr/i,
      /^mae/i,
      /^(mez|eve)/i,
      /^gou/i,
      /^eos/i,
      /^gwe/i,
      /^her/i,
      /^du/i,
      /^ker/i
    ], monthsRegex$1 = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, monthsStrictRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i, monthsShortStrictRegex = /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i, fullWeekdaysParse = [
      /^sul/i,
      /^lun/i,
      /^meurzh/i,
      /^merc[\']her/i,
      /^yaou/i,
      /^gwener/i,
      /^sadorn/i
    ], shortWeekdaysParse = [
      /^Sul/i,
      /^Lun/i,
      /^Meu/i,
      /^Mer/i,
      /^Yao/i,
      /^Gwe/i,
      /^Sad/i
    ], minWeekdaysParse = [
      /^Su/i,
      /^Lu/i,
      /^Me([^r]|$)/i,
      /^Mer/i,
      /^Ya/i,
      /^Gw/i,
      /^Sa/i
    ];
    hooks2.defineLocale("br", {
      months: "Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split(
        "_"
      ),
      monthsShort: "Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
      weekdays: "Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn".split("_"),
      weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
      weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
      weekdaysParse: minWeekdaysParse,
      fullWeekdaysParse,
      shortWeekdaysParse,
      minWeekdaysParse,
      monthsRegex: monthsRegex$1,
      monthsShortRegex: monthsRegex$1,
      monthsStrictRegex,
      monthsShortStrictRegex,
      monthsParse,
      longMonthsParse: monthsParse,
      shortMonthsParse: monthsParse,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D [a viz] MMMM YYYY",
        LLL: "D [a viz] MMMM YYYY HH:mm",
        LLLL: "dddd, D [a viz] MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Hiziv da] LT",
        nextDay: "[Warchoazh da] LT",
        nextWeek: "dddd [da] LT",
        lastDay: "[Dech da] LT",
        lastWeek: "dddd [paset da] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "a-benn %s",
        past: "%s zo",
        s: "un nebeud segondenno",
        ss: "%d eilenn",
        m: "ur vunutenn",
        mm: relativeTimeWithMutation,
        h: "un eur",
        hh: "%d eur",
        d: "un devezh",
        dd: relativeTimeWithMutation,
        M: "ur miz",
        MM: relativeTimeWithMutation,
        y: "ur bloaz",
        yy: specialMutationForYears
      },
      dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
      ordinal: function(number) {
        var output = number === 1 ? "a" : "vet";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      },
      meridiemParse: /a.m.|g.m./,
      // goude merenn | a-raok merenn
      isPM: function(token2) {
        return token2 === "g.m.";
      },
      meridiem: function(hour, minute, isLower) {
        return hour < 12 ? "a.m." : "g.m.";
      }
    });
    //! moment.js locale configuration
    function processRelativeTime(number, withoutSuffix, key, isFuture) {
      switch (key) {
        case "m":
          return withoutSuffix ? "jedna minuta" : isFuture ? "jednu minutu" : "jedne minute";
      }
    }
    function translate2(number, withoutSuffix, key) {
      var result = number + " ";
      switch (key) {
        case "ss":
          if (number === 1) {
            result += "sekunda";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "sekunde";
          } else {
            result += "sekundi";
          }
          return result;
        case "mm":
          if (number === 1) {
            result += "minuta";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "minute";
          } else {
            result += "minuta";
          }
          return result;
        case "h":
          return withoutSuffix ? "jedan sat" : "jedan sat";
        case "hh":
          if (number === 1) {
            result += "sat";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "sata";
          } else {
            result += "sati";
          }
          return result;
        case "dd":
          if (number === 1) {
            result += "dan";
          } else {
            result += "dana";
          }
          return result;
        case "MM":
          if (number === 1) {
            result += "mjesec";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "mjeseca";
          } else {
            result += "mjeseci";
          }
          return result;
        case "yy":
          if (number === 1) {
            result += "godina";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "godine";
          } else {
            result += "godina";
          }
          return result;
      }
    }
    hooks2.defineLocale("bs", {
      months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split(
        "_"
      ),
      monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split(
        "_"
      ),
      weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
      weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY H:mm",
        LLLL: "dddd, D. MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[danas u] LT",
        nextDay: "[sutra u] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[u] [nedjelju] [u] LT";
            case 3:
              return "[u] [srijedu] [u] LT";
            case 6:
              return "[u] [subotu] [u] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[u] dddd [u] LT";
          }
        },
        lastDay: "[juer u] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
            case 3:
              return "[prolu] dddd [u] LT";
            case 6:
              return "[prole] [subote] [u] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[proli] dddd [u] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "za %s",
        past: "prije %s",
        s: "par sekundi",
        ss: translate2,
        m: processRelativeTime,
        mm: translate2,
        h: translate2,
        hh: translate2,
        d: "dan",
        dd: translate2,
        M: "mjesec",
        MM: translate2,
        y: "godinu",
        yy: translate2
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ca", {
      months: {
        standalone: "gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split(
          "_"
        ),
        format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split(
          "_"
        ),
        isFormat: /D[oD]?(\s)+MMMM/
      },
      monthsShort: "gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split(
        "_"
      ),
      weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
      weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM [de] YYYY",
        ll: "D MMM YYYY",
        LLL: "D MMMM [de] YYYY [a les] H:mm",
        lll: "D MMM YYYY, H:mm",
        LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
        llll: "ddd D MMM YYYY, H:mm"
      },
      calendar: {
        sameDay: function() {
          return "[avui a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
        },
        nextDay: function() {
          return "[dem a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
        },
        nextWeek: function() {
          return "dddd [a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
        },
        lastDay: function() {
          return "[ahir a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
        },
        lastWeek: function() {
          return "[el] dddd [passat a " + (this.hours() !== 1 ? "les" : "la") + "] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "d'aqu %s",
        past: "fa %s",
        s: "uns segons",
        ss: "%d segons",
        m: "un minut",
        mm: "%d minuts",
        h: "una hora",
        hh: "%d hores",
        d: "un dia",
        dd: "%d dies",
        M: "un mes",
        MM: "%d mesos",
        y: "un any",
        yy: "%d anys"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
      ordinal: function(number, period) {
        var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "";
        if (period === "w" || period === "W") {
          output = "a";
        }
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var months$4 = {
      standalone: "leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec".split(
        "_"
      ),
      format: "ledna_nora_bezna_dubna_kvtna_ervna_ervence_srpna_z_jna_listopadu_prosince".split(
        "_"
      ),
      isFormat: /DD?[o.]?(\[[^\[\]]*\]|\s)+MMMM/
    }, monthsShort = "led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro".split("_"), monthsParse$1 = [
      /^led/i,
      /^no/i,
      /^be/i,
      /^dub/i,
      /^kv/i,
      /^(vn|erven$|ervna)/i,
      /^(vc|ervenec|ervence)/i,
      /^srp/i,
      /^z/i,
      /^j/i,
      /^lis/i,
      /^pro/i
    ], monthsRegex$2 = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;
    function plural$1(n2) {
      return n2 > 1 && n2 < 5 && ~~(n2 / 10) !== 1;
    }
    function translate$1(number, withoutSuffix, key, isFuture) {
      var result = number + " ";
      switch (key) {
        case "s":
          return withoutSuffix || isFuture ? "pr sekund" : "pr sekundami";
        case "ss":
          if (withoutSuffix || isFuture) {
            return result + (plural$1(number) ? "sekundy" : "sekund");
          } else {
            return result + "sekundami";
          }
        case "m":
          return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";
        case "mm":
          if (withoutSuffix || isFuture) {
            return result + (plural$1(number) ? "minuty" : "minut");
          } else {
            return result + "minutami";
          }
        case "h":
          return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
        case "hh":
          if (withoutSuffix || isFuture) {
            return result + (plural$1(number) ? "hodiny" : "hodin");
          } else {
            return result + "hodinami";
          }
        case "d":
          return withoutSuffix || isFuture ? "den" : "dnem";
        case "dd":
          if (withoutSuffix || isFuture) {
            return result + (plural$1(number) ? "dny" : "dn");
          } else {
            return result + "dny";
          }
        case "M":
          return withoutSuffix || isFuture ? "msc" : "mscem";
        case "MM":
          if (withoutSuffix || isFuture) {
            return result + (plural$1(number) ? "msce" : "msc");
          } else {
            return result + "msci";
          }
        case "y":
          return withoutSuffix || isFuture ? "rok" : "rokem";
        case "yy":
          if (withoutSuffix || isFuture) {
            return result + (plural$1(number) ? "roky" : "let");
          } else {
            return result + "lety";
          }
      }
    }
    hooks2.defineLocale("cs", {
      months: months$4,
      monthsShort,
      monthsRegex: monthsRegex$2,
      monthsShortRegex: monthsRegex$2,
      // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
      // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
      monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
      monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
      monthsParse: monthsParse$1,
      longMonthsParse: monthsParse$1,
      shortMonthsParse: monthsParse$1,
      weekdays: "nedle_pondl_ter_steda_tvrtek_ptek_sobota".split("_"),
      weekdaysShort: "ne_po_t_st_t_p_so".split("_"),
      weekdaysMin: "ne_po_t_st_t_p_so".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY H:mm",
        LLLL: "dddd D. MMMM YYYY H:mm",
        l: "D. M. YYYY"
      },
      calendar: {
        sameDay: "[dnes v] LT",
        nextDay: "[ztra v] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[v nedli v] LT";
            case 1:
            case 2:
              return "[v] dddd [v] LT";
            case 3:
              return "[ve stedu v] LT";
            case 4:
              return "[ve tvrtek v] LT";
            case 5:
              return "[v ptek v] LT";
            case 6:
              return "[v sobotu v] LT";
          }
        },
        lastDay: "[vera v] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
              return "[minulou nedli v] LT";
            case 1:
            case 2:
              return "[minul] dddd [v] LT";
            case 3:
              return "[minulou stedu v] LT";
            case 4:
            case 5:
              return "[minul] dddd [v] LT";
            case 6:
              return "[minulou sobotu v] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "za %s",
        past: "ped %s",
        s: translate$1,
        ss: translate$1,
        m: translate$1,
        mm: translate$1,
        h: translate$1,
        hh: translate$1,
        d: translate$1,
        dd: translate$1,
        M: translate$1,
        MM: translate$1,
        y: translate$1,
        yy: translate$1
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("cv", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD-MM-YYYY",
        LL: "YYYY [] MMMM [] D[-]",
        LLL: "YYYY [] MMMM [] D[-], HH:mm",
        LLLL: "dddd, YYYY [] MMMM [] D[-], HH:mm"
      },
      calendar: {
        sameDay: "[] LT []",
        nextDay: "[] LT []",
        lastDay: "[] LT []",
        nextWeek: "[] dddd LT []",
        lastWeek: "[] dddd LT []",
        sameElse: "L"
      },
      relativeTime: {
        future: function(output) {
          var affix = /$/i.exec(output) ? "" : /$/i.exec(output) ? "" : "";
          return output + affix;
        },
        past: "%s ",
        s: "- ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}-/,
      ordinal: "%d-",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("cy", {
      months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split(
        "_"
      ),
      monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split(
        "_"
      ),
      weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split(
        "_"
      ),
      weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
      weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
      weekdaysParseExact: true,
      // time formats are the same as en-gb
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Heddiw am] LT",
        nextDay: "[Yfory am] LT",
        nextWeek: "dddd [am] LT",
        lastDay: "[Ddoe am] LT",
        lastWeek: "dddd [diwethaf am] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "mewn %s",
        past: "%s yn l",
        s: "ychydig eiliadau",
        ss: "%d eiliad",
        m: "munud",
        mm: "%d munud",
        h: "awr",
        hh: "%d awr",
        d: "diwrnod",
        dd: "%d diwrnod",
        M: "mis",
        MM: "%d mis",
        y: "blwyddyn",
        yy: "%d flynedd"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
      // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
      ordinal: function(number) {
        var b = number, output = "", lookup = [
          "",
          "af",
          "il",
          "ydd",
          "ydd",
          "ed",
          "ed",
          "ed",
          "fed",
          "fed",
          "fed",
          // 1af to 10fed
          "eg",
          "fed",
          "eg",
          "eg",
          "fed",
          "eg",
          "eg",
          "fed",
          "eg",
          "fed"
          // 11eg to 20fed
        ];
        if (b > 20) {
          if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
            output = "fed";
          } else {
            output = "ain";
          }
        } else if (b > 0) {
          output = lookup[b];
        }
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("da", {
      months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split(
        "_"
      ),
      monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
      weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
      weekdaysShort: "sn_man_tir_ons_tor_fre_lr".split("_"),
      weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY HH:mm",
        LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
      },
      calendar: {
        sameDay: "[i dag kl.] LT",
        nextDay: "[i morgen kl.] LT",
        nextWeek: "p dddd [kl.] LT",
        lastDay: "[i gr kl.] LT",
        lastWeek: "[i] dddd[s kl.] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "om %s",
        past: "%s siden",
        s: "f sekunder",
        ss: "%d sekunder",
        m: "et minut",
        mm: "%d minutter",
        h: "en time",
        hh: "%d timer",
        d: "en dag",
        dd: "%d dage",
        M: "en mned",
        MM: "%d mneder",
        y: "et r",
        yy: "%d r"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$1(number, withoutSuffix, key, isFuture) {
      var format2 = {
        m: ["eine Minute", "einer Minute"],
        h: ["eine Stunde", "einer Stunde"],
        d: ["ein Tag", "einem Tag"],
        dd: [number + " Tage", number + " Tagen"],
        w: ["eine Woche", "einer Woche"],
        M: ["ein Monat", "einem Monat"],
        MM: [number + " Monate", number + " Monaten"],
        y: ["ein Jahr", "einem Jahr"],
        yy: [number + " Jahre", number + " Jahren"]
      };
      return withoutSuffix ? format2[key][0] : format2[key][1];
    }
    hooks2.defineLocale("de-at", {
      months: "Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split(
        "_"
      ),
      monthsShort: "Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
      monthsParseExact: true,
      weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split(
        "_"
      ),
      weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
      weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY HH:mm",
        LLLL: "dddd, D. MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[heute um] LT [Uhr]",
        sameElse: "L",
        nextDay: "[morgen um] LT [Uhr]",
        nextWeek: "dddd [um] LT [Uhr]",
        lastDay: "[gestern um] LT [Uhr]",
        lastWeek: "[letzten] dddd [um] LT [Uhr]"
      },
      relativeTime: {
        future: "in %s",
        past: "vor %s",
        s: "ein paar Sekunden",
        ss: "%d Sekunden",
        m: processRelativeTime$1,
        mm: "%d Minuten",
        h: processRelativeTime$1,
        hh: "%d Stunden",
        d: processRelativeTime$1,
        dd: processRelativeTime$1,
        w: processRelativeTime$1,
        ww: "%d Wochen",
        M: processRelativeTime$1,
        MM: processRelativeTime$1,
        y: processRelativeTime$1,
        yy: processRelativeTime$1
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$2(number, withoutSuffix, key, isFuture) {
      var format2 = {
        m: ["eine Minute", "einer Minute"],
        h: ["eine Stunde", "einer Stunde"],
        d: ["ein Tag", "einem Tag"],
        dd: [number + " Tage", number + " Tagen"],
        w: ["eine Woche", "einer Woche"],
        M: ["ein Monat", "einem Monat"],
        MM: [number + " Monate", number + " Monaten"],
        y: ["ein Jahr", "einem Jahr"],
        yy: [number + " Jahre", number + " Jahren"]
      };
      return withoutSuffix ? format2[key][0] : format2[key][1];
    }
    hooks2.defineLocale("de-ch", {
      months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split(
        "_"
      ),
      monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
      monthsParseExact: true,
      weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split(
        "_"
      ),
      weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
      weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY HH:mm",
        LLLL: "dddd, D. MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[heute um] LT [Uhr]",
        sameElse: "L",
        nextDay: "[morgen um] LT [Uhr]",
        nextWeek: "dddd [um] LT [Uhr]",
        lastDay: "[gestern um] LT [Uhr]",
        lastWeek: "[letzten] dddd [um] LT [Uhr]"
      },
      relativeTime: {
        future: "in %s",
        past: "vor %s",
        s: "ein paar Sekunden",
        ss: "%d Sekunden",
        m: processRelativeTime$2,
        mm: "%d Minuten",
        h: processRelativeTime$2,
        hh: "%d Stunden",
        d: processRelativeTime$2,
        dd: processRelativeTime$2,
        w: processRelativeTime$2,
        ww: "%d Wochen",
        M: processRelativeTime$2,
        MM: processRelativeTime$2,
        y: processRelativeTime$2,
        yy: processRelativeTime$2
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$3(number, withoutSuffix, key, isFuture) {
      var format2 = {
        m: ["eine Minute", "einer Minute"],
        h: ["eine Stunde", "einer Stunde"],
        d: ["ein Tag", "einem Tag"],
        dd: [number + " Tage", number + " Tagen"],
        w: ["eine Woche", "einer Woche"],
        M: ["ein Monat", "einem Monat"],
        MM: [number + " Monate", number + " Monaten"],
        y: ["ein Jahr", "einem Jahr"],
        yy: [number + " Jahre", number + " Jahren"]
      };
      return withoutSuffix ? format2[key][0] : format2[key][1];
    }
    hooks2.defineLocale("de", {
      months: "Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split(
        "_"
      ),
      monthsShort: "Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
      monthsParseExact: true,
      weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split(
        "_"
      ),
      weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
      weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY HH:mm",
        LLLL: "dddd, D. MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[heute um] LT [Uhr]",
        sameElse: "L",
        nextDay: "[morgen um] LT [Uhr]",
        nextWeek: "dddd [um] LT [Uhr]",
        lastDay: "[gestern um] LT [Uhr]",
        lastWeek: "[letzten] dddd [um] LT [Uhr]"
      },
      relativeTime: {
        future: "in %s",
        past: "vor %s",
        s: "ein paar Sekunden",
        ss: "%d Sekunden",
        m: processRelativeTime$3,
        mm: "%d Minuten",
        h: processRelativeTime$3,
        hh: "%d Stunden",
        d: processRelativeTime$3,
        dd: processRelativeTime$3,
        w: processRelativeTime$3,
        ww: "%d Wochen",
        M: processRelativeTime$3,
        MM: processRelativeTime$3,
        y: processRelativeTime$3,
        yy: processRelativeTime$3
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var months$5 = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ], weekdays = [
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
    hooks2.defineLocale("dv", {
      months: months$5,
      monthsShort: months$5,
      weekdays,
      weekdaysShort: weekdays,
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "D/M/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: "",
        ss: "d% ",
        m: "",
        mm: " %d",
        h: "",
        hh: " %d",
        d: "",
        dd: " %d",
        M: "",
        MM: " %d",
        y: "",
        yy: " %d"
      },
      preparse: function(string) {
        return string.replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/,/g, "");
      },
      week: {
        dow: 7,
        // Sunday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function isFunction$1(input) {
      return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
    }
    hooks2.defineLocale("el", {
      monthsNominativeEl: "___________".split(
        "_"
      ),
      monthsGenitiveEl: "___________".split(
        "_"
      ),
      months: function(momentToFormat, format2) {
        if (!momentToFormat) {
          return this._monthsNominativeEl;
        } else if (typeof format2 === "string" && /D/.test(format2.substring(0, format2.indexOf("MMMM")))) {
          return this._monthsGenitiveEl[momentToFormat.month()];
        } else {
          return this._monthsNominativeEl[momentToFormat.month()];
        }
      },
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "" : "";
        } else {
          return isLower ? "" : "";
        }
      },
      isPM: function(input) {
        return (input + "").toLowerCase()[0] === "";
      },
      meridiemParse: /[]\.??\.?/i,
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY h:mm A",
        LLLL: "dddd, D MMMM YYYY h:mm A"
      },
      calendarEl: {
        sameDay: "[ {}] LT",
        nextDay: "[ {}] LT",
        nextWeek: "dddd [{}] LT",
        lastDay: "[ {}] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 6:
              return "[ ] dddd [{}] LT";
            default:
              return "[ ] dddd [{}] LT";
          }
        },
        sameElse: "L"
      },
      calendar: function(key, mom) {
        var output = this._calendarEl[key], hours2 = mom && mom.hours();
        if (isFunction$1(output)) {
          output = output.apply(mom);
        }
        return output.replace("{}", hours2 % 12 === 1 ? "" : "");
      },
      relativeTime: {
        future: " %s",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4st is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-au", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY h:mm A",
        LLLL: "dddd, D MMMM YYYY h:mm A"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-ca", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "YYYY-MM-DD",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-gb", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-ie", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-il", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-in", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY h:mm A",
        LLLL: "dddd, D MMMM YYYY h:mm A"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 1st is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-nz", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY h:mm A",
        LLLL: "dddd, D MMMM YYYY h:mm A"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("en-sg", {
      months: "January_February_March_April_May_June_July_August_September_October_November_December".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
      weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
        "_"
      ),
      weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
      weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "%d seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("eo", {
      months: "januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro".split(
        "_"
      ),
      monthsShort: "jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec".split("_"),
      weekdays: "dimano_lundo_mardo_merkredo_ado_vendredo_sabato".split("_"),
      weekdaysShort: "dim_lun_mard_merk_a_ven_sab".split("_"),
      weekdaysMin: "di_lu_ma_me_a_ve_sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY-MM-DD",
        LL: "[la] D[-an de] MMMM, YYYY",
        LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
        LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
        llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm"
      },
      meridiemParse: /[ap]\.t\.m/i,
      isPM: function(input) {
        return input.charAt(0).toLowerCase() === "p";
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "p.t.m." : "P.T.M.";
        } else {
          return isLower ? "a.t.m." : "A.T.M.";
        }
      },
      calendar: {
        sameDay: "[Hodia je] LT",
        nextDay: "[Morga je] LT",
        nextWeek: "dddd[n je] LT",
        lastDay: "[Hiera je] LT",
        lastWeek: "[pasintan] dddd[n je] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "post %s",
        past: "anta %s",
        s: "kelkaj sekundoj",
        ss: "%d sekundoj",
        m: "unu minuto",
        mm: "%d minutoj",
        h: "unu horo",
        hh: "%d horoj",
        d: "unu tago",
        //ne 'diurno', ar estas uzita por proksimumo
        dd: "%d tagoj",
        M: "unu monato",
        MM: "%d monatoj",
        y: "unu jaro",
        yy: "%d jaroj"
      },
      dayOfMonthOrdinalParse: /\d{1,2}a/,
      ordinal: "%da",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
      "_"
    ), monthsShort$1 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$2 = [
      /^ene/i,
      /^feb/i,
      /^mar/i,
      /^abr/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^ago/i,
      /^sep/i,
      /^oct/i,
      /^nov/i,
      /^dic/i
    ], monthsRegex$3 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks2.defineLocale("es-do", {
      months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
        "_"
      ),
      monthsShort: function(m, format2) {
        if (!m) {
          return monthsShortDot;
        } else if (/-MMM-/.test(format2)) {
          return monthsShort$1[m.month()];
        } else {
          return monthsShortDot[m.month()];
        }
      },
      monthsRegex: monthsRegex$3,
      monthsShortRegex: monthsRegex$3,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$2,
      longMonthsParse: monthsParse$2,
      shortMonthsParse: monthsParse$2,
      weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
      weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
      weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D [de] MMMM [de] YYYY",
        LLL: "D [de] MMMM [de] YYYY h:mm A",
        LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
      },
      calendar: {
        sameDay: function() {
          return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextDay: function() {
          return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextWeek: function() {
          return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastDay: function() {
          return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastWeek: function() {
          return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "en %s",
        past: "hace %s",
        s: "unos segundos",
        ss: "%d segundos",
        m: "un minuto",
        mm: "%d minutos",
        h: "una hora",
        hh: "%d horas",
        d: "un da",
        dd: "%d das",
        w: "una semana",
        ww: "%d semanas",
        M: "un mes",
        MM: "%d meses",
        y: "un ao",
        yy: "%d aos"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsShortDot$1 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
      "_"
    ), monthsShort$2 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$3 = [
      /^ene/i,
      /^feb/i,
      /^mar/i,
      /^abr/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^ago/i,
      /^sep/i,
      /^oct/i,
      /^nov/i,
      /^dic/i
    ], monthsRegex$4 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks2.defineLocale("es-mx", {
      months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
        "_"
      ),
      monthsShort: function(m, format2) {
        if (!m) {
          return monthsShortDot$1;
        } else if (/-MMM-/.test(format2)) {
          return monthsShort$2[m.month()];
        } else {
          return monthsShortDot$1[m.month()];
        }
      },
      monthsRegex: monthsRegex$4,
      monthsShortRegex: monthsRegex$4,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$3,
      longMonthsParse: monthsParse$3,
      shortMonthsParse: monthsParse$3,
      weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
      weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
      weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D [de] MMMM [de] YYYY",
        LLL: "D [de] MMMM [de] YYYY H:mm",
        LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
      },
      calendar: {
        sameDay: function() {
          return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextDay: function() {
          return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextWeek: function() {
          return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastDay: function() {
          return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastWeek: function() {
          return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "en %s",
        past: "hace %s",
        s: "unos segundos",
        ss: "%d segundos",
        m: "un minuto",
        mm: "%d minutos",
        h: "una hora",
        hh: "%d horas",
        d: "un da",
        dd: "%d das",
        w: "una semana",
        ww: "%d semanas",
        M: "un mes",
        MM: "%d meses",
        y: "un ao",
        yy: "%d aos"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      },
      invalidDate: "Fecha invlida"
    });
    //! moment.js locale configuration
    var monthsShortDot$2 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
      "_"
    ), monthsShort$3 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$4 = [
      /^ene/i,
      /^feb/i,
      /^mar/i,
      /^abr/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^ago/i,
      /^sep/i,
      /^oct/i,
      /^nov/i,
      /^dic/i
    ], monthsRegex$5 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks2.defineLocale("es-us", {
      months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
        "_"
      ),
      monthsShort: function(m, format2) {
        if (!m) {
          return monthsShortDot$2;
        } else if (/-MMM-/.test(format2)) {
          return monthsShort$3[m.month()];
        } else {
          return monthsShortDot$2[m.month()];
        }
      },
      monthsRegex: monthsRegex$5,
      monthsShortRegex: monthsRegex$5,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$4,
      longMonthsParse: monthsParse$4,
      shortMonthsParse: monthsParse$4,
      weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
      weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
      weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "MM/DD/YYYY",
        LL: "D [de] MMMM [de] YYYY",
        LLL: "D [de] MMMM [de] YYYY h:mm A",
        LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
      },
      calendar: {
        sameDay: function() {
          return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextDay: function() {
          return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextWeek: function() {
          return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastDay: function() {
          return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastWeek: function() {
          return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "en %s",
        past: "hace %s",
        s: "unos segundos",
        ss: "%d segundos",
        m: "un minuto",
        mm: "%d minutos",
        h: "una hora",
        hh: "%d horas",
        d: "un da",
        dd: "%d das",
        w: "una semana",
        ww: "%d semanas",
        M: "un mes",
        MM: "%d meses",
        y: "un ao",
        yy: "%d aos"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsShortDot$3 = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split(
      "_"
    ), monthsShort$4 = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"), monthsParse$5 = [
      /^ene/i,
      /^feb/i,
      /^mar/i,
      /^abr/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^ago/i,
      /^sep/i,
      /^oct/i,
      /^nov/i,
      /^dic/i
    ], monthsRegex$6 = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
    hooks2.defineLocale("es", {
      months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split(
        "_"
      ),
      monthsShort: function(m, format2) {
        if (!m) {
          return monthsShortDot$3;
        } else if (/-MMM-/.test(format2)) {
          return monthsShort$4[m.month()];
        } else {
          return monthsShortDot$3[m.month()];
        }
      },
      monthsRegex: monthsRegex$6,
      monthsShortRegex: monthsRegex$6,
      monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
      monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
      monthsParse: monthsParse$5,
      longMonthsParse: monthsParse$5,
      shortMonthsParse: monthsParse$5,
      weekdays: "domingo_lunes_martes_mircoles_jueves_viernes_sbado".split("_"),
      weekdaysShort: "dom._lun._mar._mi._jue._vie._sb.".split("_"),
      weekdaysMin: "do_lu_ma_mi_ju_vi_s".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D [de] MMMM [de] YYYY",
        LLL: "D [de] MMMM [de] YYYY H:mm",
        LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
      },
      calendar: {
        sameDay: function() {
          return "[hoy a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextDay: function() {
          return "[maana a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextWeek: function() {
          return "dddd [a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastDay: function() {
          return "[ayer a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        lastWeek: function() {
          return "[el] dddd [pasado a la" + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "en %s",
        past: "hace %s",
        s: "unos segundos",
        ss: "%d segundos",
        m: "un minuto",
        mm: "%d minutos",
        h: "una hora",
        hh: "%d horas",
        d: "un da",
        dd: "%d das",
        w: "una semana",
        ww: "%d semanas",
        M: "un mes",
        MM: "%d meses",
        y: "un ao",
        yy: "%d aos"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      },
      invalidDate: "Fecha invlida"
    });
    //! moment.js locale configuration
    function processRelativeTime$4(number, withoutSuffix, key, isFuture) {
      var format2 = {
        s: ["mne sekundi", "mni sekund", "paar sekundit"],
        ss: [number + "sekundi", number + "sekundit"],
        m: ["he minuti", "ks minut"],
        mm: [number + " minuti", number + " minutit"],
        h: ["he tunni", "tund aega", "ks tund"],
        hh: [number + " tunni", number + " tundi"],
        d: ["he peva", "ks pev"],
        M: ["kuu aja", "kuu aega", "ks kuu"],
        MM: [number + " kuu", number + " kuud"],
        y: ["he aasta", "aasta", "ks aasta"],
        yy: [number + " aasta", number + " aastat"]
      };
      if (withoutSuffix) {
        return format2[key][2] ? format2[key][2] : format2[key][1];
      }
      return isFuture ? format2[key][0] : format2[key][1];
    }
    hooks2.defineLocale("et", {
      months: "jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split(
        "_"
      ),
      monthsShort: "jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
      weekdays: "phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev".split(
        "_"
      ),
      weekdaysShort: "P_E_T_K_N_R_L".split("_"),
      weekdaysMin: "P_E_T_K_N_R_L".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY H:mm",
        LLLL: "dddd, D. MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[Tna,] LT",
        nextDay: "[Homme,] LT",
        nextWeek: "[Jrgmine] dddd LT",
        lastDay: "[Eile,] LT",
        lastWeek: "[Eelmine] dddd LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s prast",
        past: "%s tagasi",
        s: processRelativeTime$4,
        ss: processRelativeTime$4,
        m: processRelativeTime$4,
        mm: processRelativeTime$4,
        h: processRelativeTime$4,
        hh: processRelativeTime$4,
        d: processRelativeTime$4,
        dd: "%d peva",
        M: processRelativeTime$4,
        MM: processRelativeTime$4,
        y: processRelativeTime$4,
        yy: processRelativeTime$4
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("eu", {
      months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split(
        "_"
      ),
      monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split(
        "_"
      ),
      weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
      weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY-MM-DD",
        LL: "YYYY[ko] MMMM[ren] D[a]",
        LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
        LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
        l: "YYYY-M-D",
        ll: "YYYY[ko] MMM D[a]",
        lll: "YYYY[ko] MMM D[a] HH:mm",
        llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
      },
      calendar: {
        sameDay: "[gaur] LT[etan]",
        nextDay: "[bihar] LT[etan]",
        nextWeek: "dddd LT[etan]",
        lastDay: "[atzo] LT[etan]",
        lastWeek: "[aurreko] dddd LT[etan]",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s barru",
        past: "duela %s",
        s: "segundo batzuk",
        ss: "%d segundo",
        m: "minutu bat",
        mm: "%d minutu",
        h: "ordu bat",
        hh: "%d ordu",
        d: "egun bat",
        dd: "%d egun",
        M: "hilabete bat",
        MM: "%d hilabete",
        y: "urte bat",
        yy: "%d urte"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$7 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$6 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("fa", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split(
        "_"
      ),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      meridiemParse: /  |  /,
      isPM: function(input) {
        return /  /.test(input);
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "  ";
        } else {
          return "  ";
        }
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: "dddd [] [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[-]/g, function(match) {
          return numberMap$6[match];
        }).replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$7[match];
        }).replace(/,/g, "");
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 6,
        // Saturday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var numbersPast = "nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn".split(
      " "
    ), numbersFuture = [
      "nolla",
      "yhden",
      "kahden",
      "kolmen",
      "neljn",
      "viiden",
      "kuuden",
      numbersPast[7],
      numbersPast[8],
      numbersPast[9]
    ];
    function translate$2(number, withoutSuffix, key, isFuture) {
      var result = "";
      switch (key) {
        case "s":
          return isFuture ? "muutaman sekunnin" : "muutama sekunti";
        case "ss":
          result = isFuture ? "sekunnin" : "sekuntia";
          break;
        case "m":
          return isFuture ? "minuutin" : "minuutti";
        case "mm":
          result = isFuture ? "minuutin" : "minuuttia";
          break;
        case "h":
          return isFuture ? "tunnin" : "tunti";
        case "hh":
          result = isFuture ? "tunnin" : "tuntia";
          break;
        case "d":
          return isFuture ? "pivn" : "piv";
        case "dd":
          result = isFuture ? "pivn" : "piv";
          break;
        case "M":
          return isFuture ? "kuukauden" : "kuukausi";
        case "MM":
          result = isFuture ? "kuukauden" : "kuukautta";
          break;
        case "y":
          return isFuture ? "vuoden" : "vuosi";
        case "yy":
          result = isFuture ? "vuoden" : "vuotta";
          break;
      }
      result = verbalNumber(number, isFuture) + " " + result;
      return result;
    }
    function verbalNumber(number, isFuture) {
      return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
    }
    hooks2.defineLocale("fi", {
      months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split(
        "_"
      ),
      monthsShort: "tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu".split(
        "_"
      ),
      weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split(
        "_"
      ),
      weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
      weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
      longDateFormat: {
        LT: "HH.mm",
        LTS: "HH.mm.ss",
        L: "DD.MM.YYYY",
        LL: "Do MMMM[ta] YYYY",
        LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
        LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
        l: "D.M.YYYY",
        ll: "Do MMM YYYY",
        lll: "Do MMM YYYY, [klo] HH.mm",
        llll: "ddd, Do MMM YYYY, [klo] HH.mm"
      },
      calendar: {
        sameDay: "[tnn] [klo] LT",
        nextDay: "[huomenna] [klo] LT",
        nextWeek: "dddd [klo] LT",
        lastDay: "[eilen] [klo] LT",
        lastWeek: "[viime] dddd[na] [klo] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s pst",
        past: "%s sitten",
        s: translate$2,
        ss: translate$2,
        m: translate$2,
        mm: translate$2,
        h: translate$2,
        hh: translate$2,
        d: translate$2,
        dd: translate$2,
        M: translate$2,
        MM: translate$2,
        y: translate$2,
        yy: translate$2
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("fil", {
      months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split(
        "_"
      ),
      monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
      weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split(
        "_"
      ),
      weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
      weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "MM/D/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY HH:mm",
        LLLL: "dddd, MMMM DD, YYYY HH:mm"
      },
      calendar: {
        sameDay: "LT [ngayong araw]",
        nextDay: "[Bukas ng] LT",
        nextWeek: "LT [sa susunod na] dddd",
        lastDay: "LT [kahapon]",
        lastWeek: "LT [noong nakaraang] dddd",
        sameElse: "L"
      },
      relativeTime: {
        future: "sa loob ng %s",
        past: "%s ang nakalipas",
        s: "ilang segundo",
        ss: "%d segundo",
        m: "isang minuto",
        mm: "%d minuto",
        h: "isang oras",
        hh: "%d oras",
        d: "isang araw",
        dd: "%d araw",
        M: "isang buwan",
        MM: "%d buwan",
        y: "isang taon",
        yy: "%d taon"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function(number) {
        return number;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("fo", {
      months: "januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember".split(
        "_"
      ),
      monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
      weekdays: "sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur".split(
        "_"
      ),
      weekdaysShort: "sun_mn_ts_mik_hs_fr_ley".split("_"),
      weekdaysMin: "su_m_t_mi_h_fr_le".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D. MMMM, YYYY HH:mm"
      },
      calendar: {
        sameDay: "[ dag kl.] LT",
        nextDay: "[ morgin kl.] LT",
        nextWeek: "dddd [kl.] LT",
        lastDay: "[ gjr kl.] LT",
        lastWeek: "[sstu] dddd [kl] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "um %s",
        past: "%s sani",
        s: "f sekund",
        ss: "%d sekundir",
        m: "ein minuttur",
        mm: "%d minuttir",
        h: "ein tmi",
        hh: "%d tmar",
        d: "ein dagur",
        dd: "%d dagar",
        M: "ein mnaur",
        MM: "%d mnair",
        y: "eitt r",
        yy: "%d r"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("fr-ca", {
      months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split(
        "_"
      ),
      monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
      weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
      weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY-MM-DD",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Aujourdhui ] LT",
        nextDay: "[Demain ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[Hier ] LT",
        lastWeek: "dddd [dernier ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "dans %s",
        past: "il y a %s",
        s: "quelques secondes",
        ss: "%d secondes",
        m: "une minute",
        mm: "%d minutes",
        h: "une heure",
        hh: "%d heures",
        d: "un jour",
        dd: "%d jours",
        M: "un mois",
        MM: "%d mois",
        y: "un an",
        yy: "%d ans"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
      ordinal: function(number, period) {
        switch (period) {
          default:
          case "M":
          case "Q":
          case "D":
          case "DDD":
          case "d":
            return number + (number === 1 ? "er" : "e");
          case "w":
          case "W":
            return number + (number === 1 ? "re" : "e");
        }
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("fr-ch", {
      months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split(
        "_"
      ),
      monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
      weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
      weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Aujourdhui ] LT",
        nextDay: "[Demain ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[Hier ] LT",
        lastWeek: "dddd [dernier ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "dans %s",
        past: "il y a %s",
        s: "quelques secondes",
        ss: "%d secondes",
        m: "une minute",
        mm: "%d minutes",
        h: "une heure",
        hh: "%d heures",
        d: "un jour",
        dd: "%d jours",
        M: "un mois",
        MM: "%d mois",
        y: "un an",
        yy: "%d ans"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
      ordinal: function(number, period) {
        switch (period) {
          default:
          case "M":
          case "Q":
          case "D":
          case "DDD":
          case "d":
            return number + (number === 1 ? "er" : "e");
          case "w":
          case "W":
            return number + (number === 1 ? "re" : "e");
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsStrictRegex$1 = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsShortStrictRegex$1 = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i, monthsRegex$7 = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i, monthsParse$6 = [
      /^janv/i,
      /^fvr/i,
      /^mars/i,
      /^avr/i,
      /^mai/i,
      /^juin/i,
      /^juil/i,
      /^aot/i,
      /^sept/i,
      /^oct/i,
      /^nov/i,
      /^dc/i
    ];
    hooks2.defineLocale("fr", {
      months: "janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre".split(
        "_"
      ),
      monthsShort: "janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.".split(
        "_"
      ),
      monthsRegex: monthsRegex$7,
      monthsShortRegex: monthsRegex$7,
      monthsStrictRegex: monthsStrictRegex$1,
      monthsShortStrictRegex: monthsShortStrictRegex$1,
      monthsParse: monthsParse$6,
      longMonthsParse: monthsParse$6,
      shortMonthsParse: monthsParse$6,
      weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
      weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
      weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Aujourdhui ] LT",
        nextDay: "[Demain ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[Hier ] LT",
        lastWeek: "dddd [dernier ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "dans %s",
        past: "il y a %s",
        s: "quelques secondes",
        ss: "%d secondes",
        m: "une minute",
        mm: "%d minutes",
        h: "une heure",
        hh: "%d heures",
        d: "un jour",
        dd: "%d jours",
        w: "une semaine",
        ww: "%d semaines",
        M: "un mois",
        MM: "%d mois",
        y: "un an",
        yy: "%d ans"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
      ordinal: function(number, period) {
        switch (period) {
          case "D":
            return number + (number === 1 ? "er" : "");
          default:
          case "M":
          case "Q":
          case "DDD":
          case "d":
            return number + (number === 1 ? "er" : "e");
          case "w":
          case "W":
            return number + (number === 1 ? "re" : "e");
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"), monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
    hooks2.defineLocale("fy", {
      months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split(
        "_"
      ),
      monthsShort: function(m, format2) {
        if (!m) {
          return monthsShortWithDots;
        } else if (/-MMM-/.test(format2)) {
          return monthsShortWithoutDots[m.month()];
        } else {
          return monthsShortWithDots[m.month()];
        }
      },
      monthsParseExact: true,
      weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split(
        "_"
      ),
      weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
      weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD-MM-YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[hjoed om] LT",
        nextDay: "[moarn om] LT",
        nextWeek: "dddd [om] LT",
        lastDay: "[juster om] LT",
        lastWeek: "[frne] dddd [om] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "oer %s",
        past: "%s lyn",
        s: "in pear sekonden",
        ss: "%d sekonden",
        m: "ien mint",
        mm: "%d minuten",
        h: "ien oere",
        hh: "%d oeren",
        d: "ien dei",
        dd: "%d dagen",
        M: "ien moanne",
        MM: "%d moannen",
        y: "ien jier",
        yy: "%d jierren"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function(number) {
        return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var months$6 = [
      "Eanir",
      "Feabhra",
      "Mrta",
      "Aibren",
      "Bealtaine",
      "Meitheamh",
      "Iil",
      "Lnasa",
      "Men Fmhair",
      "Deireadh Fmhair",
      "Samhain",
      "Nollaig"
    ], monthsShort$5 = [
      "Ean",
      "Feabh",
      "Mrt",
      "Aib",
      "Beal",
      "Meith",
      "Iil",
      "Ln",
      "M.F.",
      "D.F.",
      "Samh",
      "Noll"
    ], weekdays$1 = [
      "D Domhnaigh",
      "D Luain",
      "D Mirt",
      "D Cadaoin",
      "Dardaoin",
      "D hAoine",
      "D Sathairn"
    ], weekdaysShort = ["Domh", "Luan", "Mirt", "Cad", "Dar", "Aoine", "Sath"], weekdaysMin = ["Do", "Lu", "M", "C", "D", "A", "Sa"];
    hooks2.defineLocale("ga", {
      months: months$6,
      monthsShort: monthsShort$5,
      monthsParseExact: true,
      weekdays: weekdays$1,
      weekdaysShort,
      weekdaysMin,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Inniu ag] LT",
        nextDay: "[Amrach ag] LT",
        nextWeek: "dddd [ag] LT",
        lastDay: "[Inn ag] LT",
        lastWeek: "dddd [seo caite] [ag] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "i %s",
        past: "%s  shin",
        s: "cpla soicind",
        ss: "%d soicind",
        m: "nimad",
        mm: "%d nimad",
        h: "uair an chloig",
        hh: "%d uair an chloig",
        d: "l",
        dd: "%d l",
        M: "m",
        MM: "%d monna",
        y: "bliain",
        yy: "%d bliain"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
      ordinal: function(number) {
        var output = number === 1 ? "d" : number % 10 === 2 ? "na" : "mh";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var months$7 = [
      "Am Faoilleach",
      "An Gearran",
      "Am Mrt",
      "An Giblean",
      "An Citean",
      "An t-gmhios",
      "An t-Iuchar",
      "An Lnastal",
      "An t-Sultain",
      "An Dmhair",
      "An t-Samhain",
      "An Dbhlachd"
    ], monthsShort$6 = [
      "Faoi",
      "Gear",
      "Mrt",
      "Gibl",
      "Cit",
      "gmh",
      "Iuch",
      "Ln",
      "Sult",
      "Dmh",
      "Samh",
      "Dbh"
    ], weekdays$2 = [
      "Didmhnaich",
      "Diluain",
      "Dimirt",
      "Diciadain",
      "Diardaoin",
      "Dihaoine",
      "Disathairne"
    ], weekdaysShort$1 = ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"], weekdaysMin$1 = ["D", "Lu", "M", "Ci", "Ar", "Ha", "Sa"];
    hooks2.defineLocale("gd", {
      months: months$7,
      monthsShort: monthsShort$6,
      monthsParseExact: true,
      weekdays: weekdays$2,
      weekdaysShort: weekdaysShort$1,
      weekdaysMin: weekdaysMin$1,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[An-diugh aig] LT",
        nextDay: "[A-mireach aig] LT",
        nextWeek: "dddd [aig] LT",
        lastDay: "[An-d aig] LT",
        lastWeek: "dddd [seo chaidh] [aig] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "ann an %s",
        past: "bho chionn %s",
        s: "beagan diogan",
        ss: "%d diogan",
        m: "mionaid",
        mm: "%d mionaidean",
        h: "uair",
        hh: "%d uairean",
        d: "latha",
        dd: "%d latha",
        M: "mos",
        MM: "%d mosan",
        y: "bliadhna",
        yy: "%d bliadhna"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
      ordinal: function(number) {
        var output = number === 1 ? "d" : number % 10 === 2 ? "na" : "mh";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("gl", {
      months: "xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro".split(
        "_"
      ),
      monthsShort: "xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "domingo_luns_martes_mrcores_xoves_venres_sbado".split("_"),
      weekdaysShort: "dom._lun._mar._mr._xov._ven._sb.".split("_"),
      weekdaysMin: "do_lu_ma_m_xo_ve_s".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D [de] MMMM [de] YYYY",
        LLL: "D [de] MMMM [de] YYYY H:mm",
        LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
      },
      calendar: {
        sameDay: function() {
          return "[hoxe " + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextDay: function() {
          return "[ma " + (this.hours() !== 1 ? "s" : "") + "] LT";
        },
        nextWeek: function() {
          return "dddd [" + (this.hours() !== 1 ? "s" : "a") + "] LT";
        },
        lastDay: function() {
          return "[onte " + (this.hours() !== 1 ? "" : "a") + "] LT";
        },
        lastWeek: function() {
          return "[o] dddd [pasado " + (this.hours() !== 1 ? "s" : "a") + "] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: function(str) {
          if (str.indexOf("un") === 0) {
            return "n" + str;
          }
          return "en " + str;
        },
        past: "hai %s",
        s: "uns segundos",
        ss: "%d segundos",
        m: "un minuto",
        mm: "%d minutos",
        h: "unha hora",
        hh: "%d horas",
        d: "un da",
        dd: "%d das",
        M: "un mes",
        MM: "%d meses",
        y: "un ano",
        yy: "%d anos"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$5(number, withoutSuffix, key, isFuture) {
      var format2 = {
        s: [" ", " "],
        ss: [number + " ", number + " "],
        m: [" ", " "],
        mm: [number + " ", number + " "],
        h: [" ", " "],
        hh: [number + " ", number + " "],
        d: [" ", " "],
        dd: [number + " ", number + " "],
        M: [" ", " "],
        MM: [number + " ", number + " "],
        y: [" ", " "],
        yy: [number + " ", number + " "]
      };
      return isFuture ? format2[key][0] : format2[key][1];
    }
    hooks2.defineLocale("gom-deva", {
      months: {
        standalone: "___________".split(
          "_"
        ),
        format: "___________".split(
          "_"
        ),
        isFormat: /MMMM(\s)+D[oD]?/
      },
      monthsShort: "._.__.___._._._._._.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split("_"),
      weekdaysShort: "._._._._._._.".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "A h:mm []",
        LTS: "A h:mm:ss []",
        L: "DD-MM-YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY A h:mm []",
        LLLL: "dddd, MMMM Do, YYYY, A h:mm []",
        llll: "ddd, D MMM YYYY, A h:mm []"
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[] dddd[,] LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd[,] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s",
        past: "%s ",
        s: processRelativeTime$5,
        ss: processRelativeTime$5,
        m: processRelativeTime$5,
        mm: processRelativeTime$5,
        h: processRelativeTime$5,
        hh: processRelativeTime$5,
        d: processRelativeTime$5,
        dd: processRelativeTime$5,
        M: processRelativeTime$5,
        MM: processRelativeTime$5,
        y: processRelativeTime$5,
        yy: processRelativeTime$5
      },
      dayOfMonthOrdinalParse: /\d{1,2}()/,
      ordinal: function(number, period) {
        switch (period) {
          case "D":
            return number + "";
          default:
          case "M":
          case "Q":
          case "DDD":
          case "d":
          case "w":
          case "W":
            return number;
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week
        doy: 3
        // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
      },
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour > 12 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 16) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$6(number, withoutSuffix, key, isFuture) {
      var format2 = {
        s: ["thoddea sekondamni", "thodde sekond"],
        ss: [number + " sekondamni", number + " sekond"],
        m: ["eka mintan", "ek minut"],
        mm: [number + " mintamni", number + " mintam"],
        h: ["eka voran", "ek vor"],
        hh: [number + " voramni", number + " voram"],
        d: ["eka disan", "ek dis"],
        dd: [number + " disamni", number + " dis"],
        M: ["eka mhoinean", "ek mhoino"],
        MM: [number + " mhoineamni", number + " mhoine"],
        y: ["eka vorsan", "ek voros"],
        yy: [number + " vorsamni", number + " vorsam"]
      };
      return isFuture ? format2[key][0] : format2[key][1];
    }
    hooks2.defineLocale("gom-latn", {
      months: {
        standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split(
          "_"
        ),
        format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split(
          "_"
        ),
        isFormat: /MMMM(\s)+D[oD]?/
      },
      monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
      monthsParseExact: true,
      weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
      weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
      weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "A h:mm [vazta]",
        LTS: "A h:mm:ss [vazta]",
        L: "DD-MM-YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY A h:mm [vazta]",
        LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
        llll: "ddd, D MMM YYYY, A h:mm [vazta]"
      },
      calendar: {
        sameDay: "[Aiz] LT",
        nextDay: "[Faleam] LT",
        nextWeek: "[Fuddlo] dddd[,] LT",
        lastDay: "[Kal] LT",
        lastWeek: "[Fattlo] dddd[,] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s",
        past: "%s adim",
        s: processRelativeTime$6,
        ss: processRelativeTime$6,
        m: processRelativeTime$6,
        mm: processRelativeTime$6,
        h: processRelativeTime$6,
        hh: processRelativeTime$6,
        d: processRelativeTime$6,
        dd: processRelativeTime$6,
        M: processRelativeTime$6,
        MM: processRelativeTime$6,
        y: processRelativeTime$6,
        yy: processRelativeTime$6
      },
      dayOfMonthOrdinalParse: /\d{1,2}(er)/,
      ordinal: function(number, period) {
        switch (period) {
          case "D":
            return number + "er";
          default:
          case "M":
          case "Q":
          case "DDD":
          case "d":
          case "w":
          case "W":
            return number;
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week
        doy: 3
        // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)
      },
      meridiemParse: /rati|sokallim|donparam|sanje/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "rati") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "sokallim") {
          return hour;
        } else if (meridiem2 === "donparam") {
          return hour > 12 ? hour : hour + 12;
        } else if (meridiem2 === "sanje") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "rati";
        } else if (hour < 12) {
          return "sokallim";
        } else if (hour < 16) {
          return "donparam";
        } else if (hour < 20) {
          return "sanje";
        } else {
          return "rati";
        }
      }
    });
    //! moment.js locale configuration
    var symbolMap$8 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$7 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("gu", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "._.__.___._._._._._.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm ",
        LTS: "A h:mm:ss ",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm ",
        LLLL: "dddd, D MMMM YYYY, A h:mm "
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$7[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$8[match];
        });
      },
      // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
      // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 10 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 10) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("he", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D []MMMM YYYY",
        LLL: "D []MMMM YYYY HH:mm",
        LLLL: "dddd, D []MMMM YYYY HH:mm",
        l: "D/M/YYYY",
        ll: "D MMM YYYY",
        lll: "D MMM YYYY HH:mm",
        llll: "ddd, D MMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[ ]LT",
        nextDay: "[ ]LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ]LT",
        lastWeek: "[] dddd [ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: " ",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: function(number) {
          if (number === 2) {
            return "";
          }
          return number + " ";
        },
        d: "",
        dd: function(number) {
          if (number === 2) {
            return "";
          }
          return number + " ";
        },
        M: "",
        MM: function(number) {
          if (number === 2) {
            return "";
          }
          return number + " ";
        },
        y: "",
        yy: function(number) {
          if (number === 2) {
            return "";
          } else if (number % 10 === 0 && number !== 10) {
            return number + " ";
          }
          return number + " ";
        }
      },
      meridiemParse: /"|"| | | ||/i,
      isPM: function(input) {
        return /^("| |)$/.test(input);
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 5) {
          return " ";
        } else if (hour < 10) {
          return "";
        } else if (hour < 12) {
          return isLower ? '"' : " ";
        } else if (hour < 18) {
          return isLower ? '"' : " ";
        } else {
          return "";
        }
      }
    });
    //! moment.js locale configuration
    var symbolMap$9 = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$8 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    }, monthsParse$7 = [
      /^/i,
      /^|/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^|/i,
      /^/i,
      /^|/i,
      /^|/i
    ], shortMonthsParse = [
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i
    ];
    hooks2.defineLocale("hi", {
      months: {
        format: "___________".split(
          "_"
        ),
        standalone: "___________".split(
          "_"
        )
      },
      monthsShort: "._.__.___._._._._._.".split("_"),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm ",
        LTS: "A h:mm:ss ",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm ",
        LLLL: "dddd, D MMMM YYYY, A h:mm "
      },
      monthsParse: monthsParse$7,
      longMonthsParse: monthsParse$7,
      shortMonthsParse,
      monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
      monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
      monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,
      monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: "  ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$8[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$9[match];
        });
      },
      // Hindi notation for meridiems are quite fuzzy in practice. While there exists
      // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 10 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 10) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function translate$3(number, withoutSuffix, key) {
      var result = number + " ";
      switch (key) {
        case "ss":
          if (number === 1) {
            result += "sekunda";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "sekunde";
          } else {
            result += "sekundi";
          }
          return result;
        case "m":
          return withoutSuffix ? "jedna minuta" : "jedne minute";
        case "mm":
          if (number === 1) {
            result += "minuta";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "minute";
          } else {
            result += "minuta";
          }
          return result;
        case "h":
          return withoutSuffix ? "jedan sat" : "jednog sata";
        case "hh":
          if (number === 1) {
            result += "sat";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "sata";
          } else {
            result += "sati";
          }
          return result;
        case "dd":
          if (number === 1) {
            result += "dan";
          } else {
            result += "dana";
          }
          return result;
        case "MM":
          if (number === 1) {
            result += "mjesec";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "mjeseca";
          } else {
            result += "mjeseci";
          }
          return result;
        case "yy":
          if (number === 1) {
            result += "godina";
          } else if (number === 2 || number === 3 || number === 4) {
            result += "godine";
          } else {
            result += "godina";
          }
          return result;
      }
    }
    hooks2.defineLocale("hr", {
      months: {
        format: "sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split(
          "_"
        ),
        standalone: "sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split(
          "_"
        )
      },
      monthsShort: "sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split(
        "_"
      ),
      weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
      weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "Do MMMM YYYY",
        LLL: "Do MMMM YYYY H:mm",
        LLLL: "dddd, Do MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[danas u] LT",
        nextDay: "[sutra u] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[u] [nedjelju] [u] LT";
            case 3:
              return "[u] [srijedu] [u] LT";
            case 6:
              return "[u] [subotu] [u] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[u] dddd [u] LT";
          }
        },
        lastDay: "[juer u] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
              return "[prolu] [nedjelju] [u] LT";
            case 3:
              return "[prolu] [srijedu] [u] LT";
            case 6:
              return "[prole] [subote] [u] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[proli] dddd [u] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "za %s",
        past: "prije %s",
        s: "par sekundi",
        ss: translate$3,
        m: translate$3,
        mm: translate$3,
        h: translate$3,
        hh: translate$3,
        d: "dan",
        dd: translate$3,
        M: "mjesec",
        MM: translate$3,
        y: "godinu",
        yy: translate$3
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var weekEndings = "vasrnap htfn kedden szerdn cstrtkn pnteken szombaton".split(" ");
    function translate$4(number, withoutSuffix, key, isFuture) {
      var num = number;
      switch (key) {
        case "s":
          return isFuture || withoutSuffix ? "nhny msodperc" : "nhny msodperce";
        case "ss":
          return num + (isFuture || withoutSuffix) ? " msodperc" : " msodperce";
        case "m":
          return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");
        case "mm":
          return num + (isFuture || withoutSuffix ? " perc" : " perce");
        case "h":
          return "egy" + (isFuture || withoutSuffix ? " ra" : " rja");
        case "hh":
          return num + (isFuture || withoutSuffix ? " ra" : " rja");
        case "d":
          return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");
        case "dd":
          return num + (isFuture || withoutSuffix ? " nap" : " napja");
        case "M":
          return "egy" + (isFuture || withoutSuffix ? " hnap" : " hnapja");
        case "MM":
          return num + (isFuture || withoutSuffix ? " hnap" : " hnapja");
        case "y":
          return "egy" + (isFuture || withoutSuffix ? " v" : " ve");
        case "yy":
          return num + (isFuture || withoutSuffix ? " v" : " ve");
      }
      return "";
    }
    function week(isFuture) {
      return (isFuture ? "" : "[mlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]";
    }
    hooks2.defineLocale("hu", {
      months: "janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december".split(
        "_"
      ),
      monthsShort: "jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat".split("_"),
      weekdaysShort: "vas_ht_kedd_sze_cst_pn_szo".split("_"),
      weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "YYYY.MM.DD.",
        LL: "YYYY. MMMM D.",
        LLL: "YYYY. MMMM D. H:mm",
        LLLL: "YYYY. MMMM D., dddd H:mm"
      },
      meridiemParse: /de|du/i,
      isPM: function(input) {
        return input.charAt(1).toLowerCase() === "u";
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 12) {
          return isLower === true ? "de" : "DE";
        } else {
          return isLower === true ? "du" : "DU";
        }
      },
      calendar: {
        sameDay: "[ma] LT[-kor]",
        nextDay: "[holnap] LT[-kor]",
        nextWeek: function() {
          return week.call(this, true);
        },
        lastDay: "[tegnap] LT[-kor]",
        lastWeek: function() {
          return week.call(this, false);
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "%s mlva",
        past: "%s",
        s: translate$4,
        ss: translate$4,
        m: translate$4,
        mm: translate$4,
        h: translate$4,
        hh: translate$4,
        d: translate$4,
        dd: translate$4,
        M: translate$4,
        MM: translate$4,
        y: translate$4,
        yy: translate$4
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("hy-am", {
      months: {
        format: "___________".split(
          "_"
        ),
        standalone: "___________".split(
          "_"
        )
      },
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY .",
        LLL: "D MMMM YYYY ., HH:mm",
        LLLL: "dddd, D MMMM YYYY ., HH:mm"
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        lastDay: "[] LT",
        nextWeek: function() {
          return "dddd [ ] LT";
        },
        lastWeek: function() {
          return "[] dddd [ ] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: "  ",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      meridiemParse: /|||/,
      isPM: function(input) {
        return /^(|)$/.test(input);
      },
      meridiem: function(hour) {
        if (hour < 4) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 17) {
          return "";
        } else {
          return "";
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
      ordinal: function(number, period) {
        switch (period) {
          case "DDD":
          case "w":
          case "W":
          case "DDDo":
            if (number === 1) {
              return number + "-";
            }
            return number + "-";
          default:
            return number;
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("id", {
      months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
      weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
      weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
      weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
      longDateFormat: {
        LT: "HH.mm",
        LTS: "HH.mm.ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY [pukul] HH.mm",
        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
      },
      meridiemParse: /pagi|siang|sore|malam/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "pagi") {
          return hour;
        } else if (meridiem2 === "siang") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "sore" || meridiem2 === "malam") {
          return hour + 12;
        }
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 11) {
          return "pagi";
        } else if (hours2 < 15) {
          return "siang";
        } else if (hours2 < 19) {
          return "sore";
        } else {
          return "malam";
        }
      },
      calendar: {
        sameDay: "[Hari ini pukul] LT",
        nextDay: "[Besok pukul] LT",
        nextWeek: "dddd [pukul] LT",
        lastDay: "[Kemarin pukul] LT",
        lastWeek: "dddd [lalu pukul] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "dalam %s",
        past: "%s yang lalu",
        s: "beberapa detik",
        ss: "%d detik",
        m: "semenit",
        mm: "%d menit",
        h: "sejam",
        hh: "%d jam",
        d: "sehari",
        dd: "%d hari",
        M: "sebulan",
        MM: "%d bulan",
        y: "setahun",
        yy: "%d tahun"
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function plural$2(n2) {
      if (n2 % 100 === 11) {
        return true;
      } else if (n2 % 10 === 1) {
        return false;
      }
      return true;
    }
    function translate$5(number, withoutSuffix, key, isFuture) {
      var result = number + " ";
      switch (key) {
        case "s":
          return withoutSuffix || isFuture ? "nokkrar sekndur" : "nokkrum sekndum";
        case "ss":
          if (plural$2(number)) {
            return result + (withoutSuffix || isFuture ? "sekndur" : "sekndum");
          }
          return result + "seknda";
        case "m":
          return withoutSuffix ? "mnta" : "mntu";
        case "mm":
          if (plural$2(number)) {
            return result + (withoutSuffix || isFuture ? "mntur" : "mntum");
          } else if (withoutSuffix) {
            return result + "mnta";
          }
          return result + "mntu";
        case "hh":
          if (plural$2(number)) {
            return result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum");
          }
          return result + "klukkustund";
        case "d":
          if (withoutSuffix) {
            return "dagur";
          }
          return isFuture ? "dag" : "degi";
        case "dd":
          if (plural$2(number)) {
            if (withoutSuffix) {
              return result + "dagar";
            }
            return result + (isFuture ? "daga" : "dgum");
          } else if (withoutSuffix) {
            return result + "dagur";
          }
          return result + (isFuture ? "dag" : "degi");
        case "M":
          if (withoutSuffix) {
            return "mnuur";
          }
          return isFuture ? "mnu" : "mnui";
        case "MM":
          if (plural$2(number)) {
            if (withoutSuffix) {
              return result + "mnuir";
            }
            return result + (isFuture ? "mnui" : "mnuum");
          } else if (withoutSuffix) {
            return result + "mnuur";
          }
          return result + (isFuture ? "mnu" : "mnui");
        case "y":
          return withoutSuffix || isFuture ? "r" : "ri";
        case "yy":
          if (plural$2(number)) {
            return result + (withoutSuffix || isFuture ? "r" : "rum");
          }
          return result + (withoutSuffix || isFuture ? "r" : "ri");
      }
    }
    hooks2.defineLocale("is", {
      months: "janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember".split(
        "_"
      ),
      monthsShort: "jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des".split("_"),
      weekdays: "sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur".split(
        "_"
      ),
      weekdaysShort: "sun_mn_ri_mi_fim_fs_lau".split("_"),
      weekdaysMin: "Su_M_r_Mi_Fi_F_La".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY [kl.] H:mm",
        LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
      },
      calendar: {
        sameDay: "[ dag kl.] LT",
        nextDay: "[ morgun kl.] LT",
        nextWeek: "dddd [kl.] LT",
        lastDay: "[ gr kl.] LT",
        lastWeek: "[sasta] dddd [kl.] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "eftir %s",
        past: "fyrir %s san",
        s: translate$5,
        ss: translate$5,
        m: translate$5,
        mm: translate$5,
        h: "klukkustund",
        hh: translate$5,
        d: translate$5,
        dd: translate$5,
        M: translate$5,
        MM: translate$5,
        y: translate$5,
        yy: translate$5
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("it-ch", {
      months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split(
        "_"
      ),
      monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
      weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split(
        "_"
      ),
      weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
      weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Oggi alle] LT",
        nextDay: "[Domani alle] LT",
        nextWeek: "dddd [alle] LT",
        lastDay: "[Ieri alle] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
              return "[la scorsa] dddd [alle] LT";
            default:
              return "[lo scorso] dddd [alle] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: function(s2) {
          return (/^[0-9].+$/.test(s2) ? "tra" : "in") + " " + s2;
        },
        past: "%s fa",
        s: "alcuni secondi",
        ss: "%d secondi",
        m: "un minuto",
        mm: "%d minuti",
        h: "un'ora",
        hh: "%d ore",
        d: "un giorno",
        dd: "%d giorni",
        M: "un mese",
        MM: "%d mesi",
        y: "un anno",
        yy: "%d anni"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("it", {
      months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split(
        "_"
      ),
      monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
      weekdays: "domenica_luned_marted_mercoled_gioved_venerd_sabato".split(
        "_"
      ),
      weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
      weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: function() {
          return "[Oggi a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
        },
        nextDay: function() {
          return "[Domani a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
        },
        nextWeek: function() {
          return "dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
        },
        lastDay: function() {
          return "[Ieri a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
        },
        lastWeek: function() {
          switch (this.day()) {
            case 0:
              return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
            default:
              return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : this.hours() === 0 ? " " : "ll'") + "]LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "tra %s",
        past: "%s fa",
        s: "alcuni secondi",
        ss: "%d secondi",
        m: "un minuto",
        mm: "%d minuti",
        h: "un'ora",
        hh: "%d ore",
        d: "un giorno",
        dd: "%d giorni",
        w: "una settimana",
        ww: "%d settimane",
        M: "un mese",
        MM: "%d mesi",
        y: "un anno",
        yy: "%d anni"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ja", {
      eras: [
        {
          since: "2019-05-01",
          offset: 1,
          name: "",
          narrow: "",
          abbr: "R"
        },
        {
          since: "1989-01-08",
          until: "2019-04-30",
          offset: 1,
          name: "",
          narrow: "",
          abbr: "H"
        },
        {
          since: "1926-12-25",
          until: "1989-01-07",
          offset: 1,
          name: "",
          narrow: "",
          abbr: "S"
        },
        {
          since: "1912-07-30",
          until: "1926-12-24",
          offset: 1,
          name: "",
          narrow: "",
          abbr: "T"
        },
        {
          since: "1873-01-01",
          until: "1912-07-29",
          offset: 6,
          name: "",
          narrow: "",
          abbr: "M"
        },
        {
          since: "0001-01-01",
          until: "1873-12-31",
          offset: 1,
          name: "",
          narrow: "AD",
          abbr: "AD"
        },
        {
          since: "0000-12-31",
          until: -Infinity,
          offset: 1,
          name: "",
          narrow: "BC",
          abbr: "BC"
        }
      ],
      eraYearOrdinalRegex: /(|\d+)/,
      eraYearOrdinalParse: function(input, match) {
        return match[1] === "" ? 1 : parseInt(match[1] || input, 10);
      },
      months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
      monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY/MM/DD",
        LL: "YYYYMD",
        LLL: "YYYYMD HH:mm",
        LLLL: "YYYYMD dddd HH:mm",
        l: "YYYY/MM/DD",
        ll: "YYYYMD",
        lll: "YYYYMD HH:mm",
        llll: "YYYYMD(ddd) HH:mm"
      },
      meridiemParse: /|/i,
      isPM: function(input) {
        return input === "";
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: function(now3) {
          if (now3.week() !== this.week()) {
            return "[]dddd LT";
          } else {
            return "dddd LT";
          }
        },
        lastDay: "[] LT",
        lastWeek: function(now3) {
          if (this.week() !== now3.week()) {
            return "[]dddd LT";
          } else {
            return "dddd LT";
          }
        },
        sameElse: "L"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function(number, period) {
        switch (period) {
          case "y":
            return number === 1 ? "" : number + "";
          case "d":
          case "D":
          case "DDD":
            return number + "";
          default:
            return number;
        }
      },
      relativeTime: {
        future: "%s",
        past: "%s",
        s: "",
        ss: "%d",
        m: "1",
        mm: "%d",
        h: "1",
        hh: "%d",
        d: "1",
        dd: "%d",
        M: "1",
        MM: "%d",
        y: "1",
        yy: "%d"
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("jv", {
      months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
      weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
      weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
      weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
      longDateFormat: {
        LT: "HH.mm",
        LTS: "HH.mm.ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY [pukul] HH.mm",
        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
      },
      meridiemParse: /enjing|siyang|sonten|ndalu/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "enjing") {
          return hour;
        } else if (meridiem2 === "siyang") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "sonten" || meridiem2 === "ndalu") {
          return hour + 12;
        }
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 11) {
          return "enjing";
        } else if (hours2 < 15) {
          return "siyang";
        } else if (hours2 < 19) {
          return "sonten";
        } else {
          return "ndalu";
        }
      },
      calendar: {
        sameDay: "[Dinten puniko pukul] LT",
        nextDay: "[Mbenjang pukul] LT",
        nextWeek: "dddd [pukul] LT",
        lastDay: "[Kala wingi pukul] LT",
        lastWeek: "dddd [kepengker pukul] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "wonten ing %s",
        past: "%s ingkang kepengker",
        s: "sawetawis detik",
        ss: "%d detik",
        m: "setunggal menit",
        mm: "%d menit",
        h: "setunggal jam",
        hh: "%d jam",
        d: "sedinten",
        dd: "%d dinten",
        M: "sewulan",
        MM: "%d wulan",
        y: "setaun",
        yy: "%d taun"
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ka", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: {
        standalone: "______".split(
          "_"
        ),
        format: "______".split(
          "_"
        ),
        isFormat: /(|)/
      },
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[] LT[-]",
        nextDay: "[] LT[-]",
        lastDay: "[] LT[-]",
        nextWeek: "[] dddd LT[-]",
        lastWeek: "[] dddd LT-",
        sameElse: "L"
      },
      relativeTime: {
        future: function(s2) {
          return s2.replace(
            /(|||||)(|)/,
            function($0, $1, $2) {
              return $2 === "" ? $1 + "" : $1 + $2 + "";
            }
          );
        },
        past: function(s2) {
          if (/(||||)/.test(s2)) {
            return s2.replace(/(|)$/, " ");
          }
          if (//.test(s2)) {
            return s2.replace(/$/, " ");
          }
          return s2;
        },
        s: " ",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
      ordinal: function(number) {
        if (number === 0) {
          return number;
        }
        if (number === 1) {
          return number + "-";
        }
        if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
          return "-" + number;
        }
        return number + "-";
      },
      week: {
        dow: 1,
        doy: 7
      }
    });
    //! moment.js locale configuration
    var suffixes$1 = {
      0: "-",
      1: "-",
      2: "-",
      3: "-",
      4: "-",
      5: "-",
      6: "-",
      7: "-",
      8: "-",
      9: "-",
      10: "-",
      20: "-",
      30: "-",
      40: "-",
      50: "-",
      60: "-",
      70: "-",
      80: "-",
      90: "-",
      100: "-"
    };
    hooks2.defineLocale("kk", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: "[ ] dddd [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
      ordinal: function(number) {
        var a = number % 10, b = number >= 100 ? 100 : null;
        return number + (suffixes$1[number] || suffixes$1[a] || suffixes$1[b]);
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$a = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$9 = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("km", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return input === "";
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: "dddd [] [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s",
        past: "%s",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$9[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$a[match];
        });
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$b = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$a = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("kn", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm",
        LTS: "A h:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm",
        LLLL: "dddd, D MMMM YYYY, A h:mm"
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$a[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$b[match];
        });
      },
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 10 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 10) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}()/,
      ordinal: function(number) {
        return number + "";
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ko", {
      months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
      monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm",
        LTS: "A h:mm:ss",
        L: "YYYY.MM.DD.",
        LL: "YYYY MMMM D",
        LLL: "YYYY MMMM D A h:mm",
        LLLL: "YYYY MMMM D dddd A h:mm",
        l: "YYYY.MM.DD.",
        ll: "YYYY MMMM D",
        lll: "YYYY MMMM D A h:mm",
        llll: "YYYY MMMM D dddd A h:mm"
      },
      calendar: {
        sameDay: " LT",
        nextDay: " LT",
        nextWeek: "dddd LT",
        lastDay: " LT",
        lastWeek: " dddd LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d",
        m: "1",
        mm: "%d",
        h: " ",
        hh: "%d",
        d: "",
        dd: "%d",
        M: " ",
        MM: "%d",
        y: " ",
        yy: "%d"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "DDD":
            return number + "";
          case "M":
            return number + "";
          case "w":
          case "W":
            return number + "";
          default:
            return number;
        }
      },
      meridiemParse: /|/,
      isPM: function(token2) {
        return token2 === "";
      },
      meridiem: function(hour, minute, isUpper) {
        return hour < 12 ? "" : "";
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$7(num, withoutSuffix, key, isFuture) {
      var format2 = {
        s: ["end sanye", "end sanyeyan"],
        ss: [num + " sanye", num + " sanyeyan"],
        m: ["deqqeyek", "deqqeyek"],
        mm: [num + " deqqe", num + " deqqeyan"],
        h: ["saetek", "saetek"],
        hh: [num + " saet", num + " saetan"],
        d: ["rojek", "rojek"],
        dd: [num + " roj", num + " rojan"],
        w: ["hefteyek", "hefteyek"],
        ww: [num + " hefte", num + " hefteyan"],
        M: ["mehek", "mehek"],
        MM: [num + " meh", num + " mehan"],
        y: ["salek", "salek"],
        yy: [num + " sal", num + " salan"]
      };
      return withoutSuffix ? format2[key][0] : format2[key][1];
    }
    function ezafeNumSuffix(num) {
      num = "" + num;
      var l = num.substring(num.length - 1), ll = num.length > 1 ? num.substring(num.length - 2) : "";
      if (!(ll == 12 || ll == 13) && (l == "2" || l == "3" || ll == "50" || l == "70" || l == "80"))
        return "y";
      return "";
    }
    hooks2.defineLocale("ku-kmr", {
      // According to the spelling rules defined by the work group of Weqfa Mezopotamyay (Mesopotamia Foundation)
      // this should be: 'Kanna Pan_Sibat_Adar_Nsan_Gulan_Hezran_Trmeh_Tebax_lon_irya Pn_irya Pan_Kanna Pn'
      // But the names below are more well known and handy
      months: "Rbendan_Sibat_Adar_Nsan_Gulan_Hezran_Trmeh_Tebax_lon_Cotmeh_Mijdar_Berfanbar".split(
        "_"
      ),
      monthsShort: "Rb_Sib_Ada_Ns_Gul_Hez_Tr_Teb_lo_Cot_Mij_Ber".split("_"),
      monthsParseExact: true,
      weekdays: "Yekem_Duem_Sem_arem_Pncem_n_em".split("_"),
      weekdaysShort: "Yek_Du_S_ar_Pn_n_em".split("_"),
      weekdaysMin: "Ye_Du_S_a_P_n_e".split("_"),
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 12) {
          return isLower ? "bn" : "BN";
        } else {
          return isLower ? "pn" : "PN";
        }
      },
      meridiemParse: /bn|BN|pn|PN/,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "Do MMMM[a] YYYY[an]",
        LLL: "Do MMMM[a] YYYY[an] HH:mm",
        LLLL: "dddd, Do MMMM[a] YYYY[an] HH:mm",
        ll: "Do MMM[.] YYYY[an]",
        lll: "Do MMM[.] YYYY[an] HH:mm",
        llll: "ddd[.], Do MMM[.] YYYY[an] HH:mm"
      },
      calendar: {
        sameDay: "[ro di saet] LT [de]",
        nextDay: "[Sib di saet] LT [de]",
        nextWeek: "dddd [di saet] LT [de]",
        lastDay: "[Duh di saet] LT [de]",
        lastWeek: "dddd[a bor di saet] LT [de]",
        sameElse: "L"
      },
      relativeTime: {
        future: "di %s de",
        past: "ber %s",
        s: processRelativeTime$7,
        ss: processRelativeTime$7,
        m: processRelativeTime$7,
        mm: processRelativeTime$7,
        h: processRelativeTime$7,
        hh: processRelativeTime$7,
        d: processRelativeTime$7,
        dd: processRelativeTime$7,
        w: processRelativeTime$7,
        ww: processRelativeTime$7,
        M: processRelativeTime$7,
        MM: processRelativeTime$7,
        y: processRelativeTime$7,
        yy: processRelativeTime$7
      },
      dayOfMonthOrdinalParse: /\d{1,2}(?:y||\.)/,
      ordinal: function(num, period) {
        var p = period.toLowerCase();
        if (p.includes("w") || p.includes("m")) return num + ".";
        return num + ezafeNumSuffix(num);
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$c = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$b = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    }, months$8 = [
      " ",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      " ",
      " ",
      " "
    ];
    hooks2.defineLocale("ku", {
      months: months$8,
      monthsShort: months$8,
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return //.test(input);
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: "dddd [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s",
        s: " ",
        ss: " %d",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$b[match];
        }).replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$c[match];
        }).replace(/,/g, "");
      },
      week: {
        dow: 6,
        // Saturday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var suffixes$2 = {
      0: "-",
      1: "-",
      2: "-",
      3: "-",
      4: "-",
      5: "-",
      6: "-",
      7: "-",
      8: "-",
      9: "-",
      10: "-",
      20: "-",
      30: "-",
      40: "-",
      50: "-",
      60: "-",
      70: "-",
      80: "-",
      90: "-",
      100: "-"
    };
    hooks2.defineLocale("ky", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: "[ ] dddd [] [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
      ordinal: function(number) {
        var a = number % 10, b = number >= 100 ? 100 : null;
        return number + (suffixes$2[number] || suffixes$2[a] || suffixes$2[b]);
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$8(number, withoutSuffix, key, isFuture) {
      var format2 = {
        m: ["eng Minutt", "enger Minutt"],
        h: ["eng Stonn", "enger Stonn"],
        d: ["een Dag", "engem Dag"],
        M: ["ee Mount", "engem Mount"],
        y: ["ee Joer", "engem Joer"]
      };
      return withoutSuffix ? format2[key][0] : format2[key][1];
    }
    function processFutureTime(string) {
      var number = string.substr(0, string.indexOf(" "));
      if (eifelerRegelAppliesToNumber(number)) {
        return "a " + string;
      }
      return "an " + string;
    }
    function processPastTime(string) {
      var number = string.substr(0, string.indexOf(" "));
      if (eifelerRegelAppliesToNumber(number)) {
        return "viru " + string;
      }
      return "virun " + string;
    }
    function eifelerRegelAppliesToNumber(number) {
      number = parseInt(number, 10);
      if (isNaN(number)) {
        return false;
      }
      if (number < 0) {
        return true;
      } else if (number < 10) {
        if (4 <= number && number <= 7) {
          return true;
        }
        return false;
      } else if (number < 100) {
        var lastDigit = number % 10, firstDigit = number / 10;
        if (lastDigit === 0) {
          return eifelerRegelAppliesToNumber(firstDigit);
        }
        return eifelerRegelAppliesToNumber(lastDigit);
      } else if (number < 1e4) {
        while (number >= 10) {
          number = number / 10;
        }
        return eifelerRegelAppliesToNumber(number);
      } else {
        number = number / 1e3;
        return eifelerRegelAppliesToNumber(number);
      }
    }
    hooks2.defineLocale("lb", {
      months: "Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split(
        "_"
      ),
      monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg".split(
        "_"
      ),
      weekdaysShort: "So._M._D._M._Do._Fr._Sa.".split("_"),
      weekdaysMin: "So_M_D_M_Do_Fr_Sa".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm [Auer]",
        LTS: "H:mm:ss [Auer]",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY H:mm [Auer]",
        LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
      },
      calendar: {
        sameDay: "[Haut um] LT",
        sameElse: "L",
        nextDay: "[Muer um] LT",
        nextWeek: "dddd [um] LT",
        lastDay: "[Gschter um] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 2:
            case 4:
              return "[Leschten] dddd [um] LT";
            default:
              return "[Leschte] dddd [um] LT";
          }
        }
      },
      relativeTime: {
        future: processFutureTime,
        past: processPastTime,
        s: "e puer Sekonnen",
        ss: "%d Sekonnen",
        m: processRelativeTime$8,
        mm: "%d Minutten",
        h: processRelativeTime$8,
        hh: "%d Stonnen",
        d: processRelativeTime$8,
        dd: "%d Deeg",
        M: processRelativeTime$8,
        MM: "%d Mint",
        y: processRelativeTime$8,
        yy: "%d Joer"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("lo", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return input === "";
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[]dddd[] LT",
        lastDay: "[] LT",
        lastWeek: "[]dddd[] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s",
        s: "",
        ss: "%d ",
        m: "1 ",
        mm: "%d ",
        h: "1 ",
        hh: "%d ",
        d: "1 ",
        dd: "%d ",
        M: "1 ",
        MM: "%d ",
        y: "1 ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /()\d{1,2}/,
      ordinal: function(number) {
        return "" + number;
      }
    });
    //! moment.js locale configuration
    var units = {
      ss: "sekund_sekundi_sekundes",
      m: "minut_minuts_minut",
      mm: "minuts_minui_minutes",
      h: "valanda_valandos_valand",
      hh: "valandos_valand_valandas",
      d: "diena_dienos_dien",
      dd: "dienos_dien_dienas",
      M: "mnuo_mnesio_mnes",
      MM: "mnesiai_mnesi_mnesius",
      y: "metai_met_metus",
      yy: "metai_met_metus"
    };
    function translateSeconds(number, withoutSuffix, key, isFuture) {
      if (withoutSuffix) {
        return "kelios sekunds";
      } else {
        return isFuture ? "keli sekundi" : "kelias sekundes";
      }
    }
    function translateSingular(number, withoutSuffix, key, isFuture) {
      return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
    }
    function special(number) {
      return number % 10 === 0 || number > 10 && number < 20;
    }
    function forms(key) {
      return units[key].split("_");
    }
    function translate$6(number, withoutSuffix, key, isFuture) {
      var result = number + " ";
      if (number === 1) {
        return result + translateSingular(number, withoutSuffix, key[0], isFuture);
      } else if (withoutSuffix) {
        return result + (special(number) ? forms(key)[1] : forms(key)[0]);
      } else {
        if (isFuture) {
          return result + forms(key)[1];
        } else {
          return result + (special(number) ? forms(key)[1] : forms(key)[2]);
        }
      }
    }
    hooks2.defineLocale("lt", {
      months: {
        format: "sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio".split(
          "_"
        ),
        standalone: "sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis".split(
          "_"
        ),
        isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
      },
      monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
      weekdays: {
        format: "sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien".split(
          "_"
        ),
        standalone: "sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis".split(
          "_"
        ),
        isFormat: /dddd HH:mm/
      },
      weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_e".split("_"),
      weekdaysMin: "S_P_A_T_K_Pn_".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY-MM-DD",
        LL: "YYYY [m.] MMMM D [d.]",
        LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
        LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
        l: "YYYY-MM-DD",
        ll: "YYYY [m.] MMMM D [d.]",
        lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
        llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
      },
      calendar: {
        sameDay: "[iandien] LT",
        nextDay: "[Rytoj] LT",
        nextWeek: "dddd LT",
        lastDay: "[Vakar] LT",
        lastWeek: "[Prajus] dddd LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "po %s",
        past: "prie %s",
        s: translateSeconds,
        ss: translate$6,
        m: translateSingular,
        mm: translate$6,
        h: translateSingular,
        hh: translate$6,
        d: translateSingular,
        dd: translate$6,
        M: translateSingular,
        MM: translate$6,
        y: translateSingular,
        yy: translate$6
      },
      dayOfMonthOrdinalParse: /\d{1,2}-oji/,
      ordinal: function(number) {
        return number + "-oji";
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var units$1 = {
      ss: "sekundes_sekundm_sekunde_sekundes".split("_"),
      m: "mintes_mintm_minte_mintes".split("_"),
      mm: "mintes_mintm_minte_mintes".split("_"),
      h: "stundas_stundm_stunda_stundas".split("_"),
      hh: "stundas_stundm_stunda_stundas".split("_"),
      d: "dienas_dienm_diena_dienas".split("_"),
      dd: "dienas_dienm_diena_dienas".split("_"),
      M: "mnea_mneiem_mnesis_mnei".split("_"),
      MM: "mnea_mneiem_mnesis_mnei".split("_"),
      y: "gada_gadiem_gads_gadi".split("_"),
      yy: "gada_gadiem_gads_gadi".split("_")
    };
    function format$1(forms2, number, withoutSuffix) {
      if (withoutSuffix) {
        return number % 10 === 1 && number % 100 !== 11 ? forms2[2] : forms2[3];
      } else {
        return number % 10 === 1 && number % 100 !== 11 ? forms2[0] : forms2[1];
      }
    }
    function relativeTimeWithPlural$1(number, withoutSuffix, key) {
      return number + " " + format$1(units$1[key], number, withoutSuffix);
    }
    function relativeTimeWithSingular(number, withoutSuffix, key) {
      return format$1(units$1[key], number, withoutSuffix);
    }
    function relativeSeconds(number, withoutSuffix) {
      return withoutSuffix ? "daas sekundes" : "dam sekundm";
    }
    hooks2.defineLocale("lv", {
      months: "janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris".split(
        "_"
      ),
      monthsShort: "jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec".split("_"),
      weekdays: "svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena".split(
        "_"
      ),
      weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
      weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY.",
        LL: "YYYY. [gada] D. MMMM",
        LLL: "YYYY. [gada] D. MMMM, HH:mm",
        LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
      },
      calendar: {
        sameDay: "[odien pulksten] LT",
        nextDay: "[Rt pulksten] LT",
        nextWeek: "dddd [pulksten] LT",
        lastDay: "[Vakar pulksten] LT",
        lastWeek: "[Pagju] dddd [pulksten] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "pc %s",
        past: "pirms %s",
        s: relativeSeconds,
        ss: relativeTimeWithPlural$1,
        m: relativeTimeWithSingular,
        mm: relativeTimeWithPlural$1,
        h: relativeTimeWithSingular,
        hh: relativeTimeWithPlural$1,
        d: relativeTimeWithSingular,
        dd: relativeTimeWithPlural$1,
        M: relativeTimeWithSingular,
        MM: relativeTimeWithPlural$1,
        y: relativeTimeWithSingular,
        yy: relativeTimeWithPlural$1
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var translator = {
      words: {
        //Different grammatical cases
        ss: ["sekund", "sekunda", "sekundi"],
        m: ["jedan minut", "jednog minuta"],
        mm: ["minut", "minuta", "minuta"],
        h: ["jedan sat", "jednog sata"],
        hh: ["sat", "sata", "sati"],
        dd: ["dan", "dana", "dana"],
        MM: ["mjesec", "mjeseca", "mjeseci"],
        yy: ["godina", "godine", "godina"]
      },
      correctGrammaticalCase: function(number, wordKey) {
        return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
      },
      translate: function(number, withoutSuffix, key) {
        var wordKey = translator.words[key];
        if (key.length === 1) {
          return withoutSuffix ? wordKey[0] : wordKey[1];
        } else {
          return number + " " + translator.correctGrammaticalCase(number, wordKey);
        }
      }
    };
    hooks2.defineLocale("me", {
      months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split(
        "_"
      ),
      monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
      monthsParseExact: true,
      weekdays: "nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota".split(
        "_"
      ),
      weekdaysShort: "ned._pon._uto._sri._et._pet._sub.".split("_"),
      weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY H:mm",
        LLLL: "dddd, D. MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[danas u] LT",
        nextDay: "[sjutra u] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[u] [nedjelju] [u] LT";
            case 3:
              return "[u] [srijedu] [u] LT";
            case 6:
              return "[u] [subotu] [u] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[u] dddd [u] LT";
          }
        },
        lastDay: "[jue u] LT",
        lastWeek: function() {
          var lastWeekDays = [
            "[prole] [nedjelje] [u] LT",
            "[prolog] [ponedjeljka] [u] LT",
            "[prolog] [utorka] [u] LT",
            "[prole] [srijede] [u] LT",
            "[prolog] [etvrtka] [u] LT",
            "[prolog] [petka] [u] LT",
            "[prole] [subote] [u] LT"
          ];
          return lastWeekDays[this.day()];
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "za %s",
        past: "prije %s",
        s: "nekoliko sekundi",
        ss: translator.translate,
        m: translator.translate,
        mm: translator.translate,
        h: translator.translate,
        hh: translator.translate,
        d: "dan",
        dd: translator.translate,
        M: "mjesec",
        MM: translator.translate,
        y: "godinu",
        yy: translator.translate
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("mi", {
      months: "Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea".split(
        "_"
      ),
      monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split(
        "_"
      ),
      monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
      monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
      monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
      monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
      weekdays: "Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei".split("_"),
      weekdaysShort: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
      weekdaysMin: "Ta_Ma_T_We_Ti_Pa_H".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY [i] HH:mm",
        LLLL: "dddd, D MMMM YYYY [i] HH:mm"
      },
      calendar: {
        sameDay: "[i teie mahana, i] LT",
        nextDay: "[apopo i] LT",
        nextWeek: "dddd [i] LT",
        lastDay: "[inanahi i] LT",
        lastWeek: "dddd [whakamutunga i] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "i roto i %s",
        past: "%s i mua",
        s: "te hkona ruarua",
        ss: "%d hkona",
        m: "he meneti",
        mm: "%d meneti",
        h: "te haora",
        hh: "%d haora",
        d: "he ra",
        dd: "%d ra",
        M: "he marama",
        MM: "%d marama",
        y: "he tau",
        yy: "%d tau"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("mk", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "e_o_____a".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "D.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY H:mm",
        LLLL: "dddd, D MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "[] dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
            case 3:
            case 6:
              return "[] dddd [] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[] dddd [] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
      ordinal: function(number) {
        var lastDigit = number % 10, last2Digits = number % 100;
        if (number === 0) {
          return number + "-";
        } else if (last2Digits === 0) {
          return number + "-";
        } else if (last2Digits > 10 && last2Digits < 20) {
          return number + "-";
        } else if (lastDigit === 1) {
          return number + "-";
        } else if (lastDigit === 2) {
          return number + "-";
        } else if (lastDigit === 7 || lastDigit === 8) {
          return number + "-";
        } else {
          return number + "-";
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ml", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "._._._.___._._._._._.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm -",
        LTS: "A h:mm:ss -",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm -",
        LLLL: "dddd, D MMMM YYYY, A h:mm -"
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      meridiemParse: /|| ||/i,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" && hour >= 4 || meridiem2 === " " || meridiem2 === "") {
          return hour + 12;
        } else {
          return hour;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 17) {
          return " ";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      }
    });
    //! moment.js locale configuration
    function translate$7(number, withoutSuffix, key, isFuture) {
      switch (key) {
        case "s":
          return withoutSuffix ? " " : " ";
        case "ss":
          return number + (withoutSuffix ? " " : " ");
        case "m":
        case "mm":
          return number + (withoutSuffix ? " " : " ");
        case "h":
        case "hh":
          return number + (withoutSuffix ? " " : " ");
        case "d":
        case "dd":
          return number + (withoutSuffix ? " " : " ");
        case "M":
        case "MM":
          return number + (withoutSuffix ? " " : " ");
        case "y":
        case "yy":
          return number + (withoutSuffix ? " " : " ");
        default:
          return number;
      }
    }
    hooks2.defineLocale("mn", {
      months: " _ _ _ _ _ _ _ _ _ _  _  ".split(
        "_"
      ),
      monthsShort: "1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 ".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY-MM-DD",
        LL: "YYYY  MMMM D",
        LLL: "YYYY  MMMM D HH:mm",
        LLLL: "dddd, YYYY  MMMM D HH:mm"
      },
      meridiemParse: /|/i,
      isPM: function(input) {
        return input === "";
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[] dddd LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: translate$7,
        ss: translate$7,
        m: translate$7,
        mm: translate$7,
        h: translate$7,
        hh: translate$7,
        d: translate$7,
        dd: translate$7,
        M: translate$7,
        MM: translate$7,
        y: translate$7,
        yy: translate$7
      },
      dayOfMonthOrdinalParse: /\d{1,2} /,
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "DDD":
            return number + " ";
          default:
            return number;
        }
      }
    });
    //! moment.js locale configuration
    var symbolMap$d = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$c = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    function relativeTimeMr(number, withoutSuffix, string, isFuture) {
      var output = "";
      if (withoutSuffix) {
        switch (string) {
          case "s":
            output = " ";
            break;
          case "ss":
            output = "%d ";
            break;
          case "m":
            output = " ";
            break;
          case "mm":
            output = "%d ";
            break;
          case "h":
            output = " ";
            break;
          case "hh":
            output = "%d ";
            break;
          case "d":
            output = " ";
            break;
          case "dd":
            output = "%d ";
            break;
          case "M":
            output = " ";
            break;
          case "MM":
            output = "%d ";
            break;
          case "y":
            output = " ";
            break;
          case "yy":
            output = "%d ";
            break;
        }
      } else {
        switch (string) {
          case "s":
            output = " ";
            break;
          case "ss":
            output = "%d ";
            break;
          case "m":
            output = " ";
            break;
          case "mm":
            output = "%d ";
            break;
          case "h":
            output = " ";
            break;
          case "hh":
            output = "%d ";
            break;
          case "d":
            output = " ";
            break;
          case "dd":
            output = "%d ";
            break;
          case "M":
            output = " ";
            break;
          case "MM":
            output = "%d ";
            break;
          case "y":
            output = " ";
            break;
          case "yy":
            output = "%d ";
            break;
        }
      }
      return output.replace(/%d/i, number);
    }
    hooks2.defineLocale("mr", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "._._._._._._._._._._._.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm ",
        LTS: "A h:mm:ss ",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm ",
        LLLL: "dddd, D MMMM YYYY, A h:mm "
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s",
        past: "%s",
        s: relativeTimeMr,
        ss: relativeTimeMr,
        m: relativeTimeMr,
        mm: relativeTimeMr,
        h: relativeTimeMr,
        hh: relativeTimeMr,
        d: relativeTimeMr,
        dd: relativeTimeMr,
        M: relativeTimeMr,
        MM: relativeTimeMr,
        y: relativeTimeMr,
        yy: relativeTimeMr
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$c[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$d[match];
        });
      },
      meridiemParse: /||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" || meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "" || meridiem2 === "" || meridiem2 === "") {
          return hour >= 12 ? hour : hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour >= 0 && hour < 6) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ms-my", {
      months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
      weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
      weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
      weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
      longDateFormat: {
        LT: "HH.mm",
        LTS: "HH.mm.ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY [pukul] HH.mm",
        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
      },
      meridiemParse: /pagi|tengahari|petang|malam/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "pagi") {
          return hour;
        } else if (meridiem2 === "tengahari") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "petang" || meridiem2 === "malam") {
          return hour + 12;
        }
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 11) {
          return "pagi";
        } else if (hours2 < 15) {
          return "tengahari";
        } else if (hours2 < 19) {
          return "petang";
        } else {
          return "malam";
        }
      },
      calendar: {
        sameDay: "[Hari ini pukul] LT",
        nextDay: "[Esok pukul] LT",
        nextWeek: "dddd [pukul] LT",
        lastDay: "[Kelmarin pukul] LT",
        lastWeek: "dddd [lepas pukul] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "dalam %s",
        past: "%s yang lepas",
        s: "beberapa saat",
        ss: "%d saat",
        m: "seminit",
        mm: "%d minit",
        h: "sejam",
        hh: "%d jam",
        d: "sehari",
        dd: "%d hari",
        M: "sebulan",
        MM: "%d bulan",
        y: "setahun",
        yy: "%d tahun"
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ms", {
      months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
      weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
      weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
      weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
      longDateFormat: {
        LT: "HH.mm",
        LTS: "HH.mm.ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY [pukul] HH.mm",
        LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
      },
      meridiemParse: /pagi|tengahari|petang|malam/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "pagi") {
          return hour;
        } else if (meridiem2 === "tengahari") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "petang" || meridiem2 === "malam") {
          return hour + 12;
        }
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 11) {
          return "pagi";
        } else if (hours2 < 15) {
          return "tengahari";
        } else if (hours2 < 19) {
          return "petang";
        } else {
          return "malam";
        }
      },
      calendar: {
        sameDay: "[Hari ini pukul] LT",
        nextDay: "[Esok pukul] LT",
        nextWeek: "dddd [pukul] LT",
        lastDay: "[Kelmarin pukul] LT",
        lastWeek: "dddd [lepas pukul] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "dalam %s",
        past: "%s yang lepas",
        s: "beberapa saat",
        ss: "%d saat",
        m: "seminit",
        mm: "%d minit",
        h: "sejam",
        hh: "%d jam",
        d: "sehari",
        dd: "%d hari",
        M: "sebulan",
        MM: "%d bulan",
        y: "setahun",
        yy: "%d tahun"
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("mt", {
      months: "Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru".split(
        "_"
      ),
      monthsShort: "Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di".split("_"),
      weekdays: "Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt".split(
        "_"
      ),
      weekdaysShort: "ad_Tne_Tli_Erb_am_im_Sib".split("_"),
      weekdaysMin: "a_Tn_Tl_Er_a_i_Si".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Illum fil-]LT",
        nextDay: "[Gada fil-]LT",
        nextWeek: "dddd [fil-]LT",
        lastDay: "[Il-biera fil-]LT",
        lastWeek: "dddd [li gadda] [fil-]LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "f %s",
        past: "%s ilu",
        s: "ftit sekondi",
        ss: "%d sekondi",
        m: "minuta",
        mm: "%d minuti",
        h: "siega",
        hh: "%d siegat",
        d: "urnata",
        dd: "%d ranet",
        M: "xahar",
        MM: "%d xhur",
        y: "sena",
        yy: "%d sni"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$e = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$d = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("my", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[.] LT []",
        nextDay: "[] LT []",
        nextWeek: "dddd LT []",
        lastDay: "[.] LT []",
        lastWeek: "[] dddd LT []",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s ",
        past: " %s ",
        s: ".",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d ",
        M: "",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$d[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$e[match];
        });
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("nb", {
      months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split(
        "_"
      ),
      monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
      monthsParseExact: true,
      weekdays: "sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag".split("_"),
      weekdaysShort: "s._ma._ti._on._to._fr._l.".split("_"),
      weekdaysMin: "s_ma_ti_on_to_fr_l".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY [kl.] HH:mm",
        LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
      },
      calendar: {
        sameDay: "[i dag kl.] LT",
        nextDay: "[i morgen kl.] LT",
        nextWeek: "dddd [kl.] LT",
        lastDay: "[i gr kl.] LT",
        lastWeek: "[forrige] dddd [kl.] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "om %s",
        past: "%s siden",
        s: "noen sekunder",
        ss: "%d sekunder",
        m: "ett minutt",
        mm: "%d minutter",
        h: "n time",
        hh: "%d timer",
        d: "n dag",
        dd: "%d dager",
        w: "n uke",
        ww: "%d uker",
        M: "n mned",
        MM: "%d mneder",
        y: "ett r",
        yy: "%d r"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$f = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$e = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("ne", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "._.__.___._._._._._.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "._._._._._._.".split("_"),
      weekdaysMin: "._._._._._._.".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "A h:mm ",
        LTS: "A h:mm:ss ",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm ",
        LLLL: "dddd, D MMMM YYYY, A h:mm "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$e[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$f[match];
        });
      },
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 10 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 3) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 16) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[] dddd[,] LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd[,] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsShortWithDots$1 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$1 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse$8 = [
      /^jan/i,
      /^feb/i,
      /^(maart|mrt\.?)$/i,
      /^apr/i,
      /^mei$/i,
      /^jun[i.]?$/i,
      /^jul[i.]?$/i,
      /^aug/i,
      /^sep/i,
      /^okt/i,
      /^nov/i,
      /^dec/i
    ], monthsRegex$8 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    hooks2.defineLocale("nl-be", {
      months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split(
        "_"
      ),
      monthsShort: function(m, format2) {
        if (!m) {
          return monthsShortWithDots$1;
        } else if (/-MMM-/.test(format2)) {
          return monthsShortWithoutDots$1[m.month()];
        } else {
          return monthsShortWithDots$1[m.month()];
        }
      },
      monthsRegex: monthsRegex$8,
      monthsShortRegex: monthsRegex$8,
      monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
      monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
      monthsParse: monthsParse$8,
      longMonthsParse: monthsParse$8,
      shortMonthsParse: monthsParse$8,
      weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
      weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
      weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[vandaag om] LT",
        nextDay: "[morgen om] LT",
        nextWeek: "dddd [om] LT",
        lastDay: "[gisteren om] LT",
        lastWeek: "[afgelopen] dddd [om] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "over %s",
        past: "%s geleden",
        s: "een paar seconden",
        ss: "%d seconden",
        m: "n minuut",
        mm: "%d minuten",
        h: "n uur",
        hh: "%d uur",
        d: "n dag",
        dd: "%d dagen",
        M: "n maand",
        MM: "%d maanden",
        y: "n jaar",
        yy: "%d jaar"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function(number) {
        return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsShortWithDots$2 = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"), monthsShortWithoutDots$2 = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"), monthsParse$9 = [
      /^jan/i,
      /^feb/i,
      /^(maart|mrt\.?)$/i,
      /^apr/i,
      /^mei$/i,
      /^jun[i.]?$/i,
      /^jul[i.]?$/i,
      /^aug/i,
      /^sep/i,
      /^okt/i,
      /^nov/i,
      /^dec/i
    ], monthsRegex$9 = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
    hooks2.defineLocale("nl", {
      months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split(
        "_"
      ),
      monthsShort: function(m, format2) {
        if (!m) {
          return monthsShortWithDots$2;
        } else if (/-MMM-/.test(format2)) {
          return monthsShortWithoutDots$2[m.month()];
        } else {
          return monthsShortWithDots$2[m.month()];
        }
      },
      monthsRegex: monthsRegex$9,
      monthsShortRegex: monthsRegex$9,
      monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
      monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
      monthsParse: monthsParse$9,
      longMonthsParse: monthsParse$9,
      shortMonthsParse: monthsParse$9,
      weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
      weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
      weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD-MM-YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[vandaag om] LT",
        nextDay: "[morgen om] LT",
        nextWeek: "dddd [om] LT",
        lastDay: "[gisteren om] LT",
        lastWeek: "[afgelopen] dddd [om] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "over %s",
        past: "%s geleden",
        s: "een paar seconden",
        ss: "%d seconden",
        m: "n minuut",
        mm: "%d minuten",
        h: "n uur",
        hh: "%d uur",
        d: "n dag",
        dd: "%d dagen",
        w: "n week",
        ww: "%d weken",
        M: "n maand",
        MM: "%d maanden",
        y: "n jaar",
        yy: "%d jaar"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
      ordinal: function(number) {
        return number + (number === 1 || number === 8 || number >= 20 ? "ste" : "de");
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("nn", {
      months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split(
        "_"
      ),
      monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
      monthsParseExact: true,
      weekdays: "sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
      weekdaysShort: "su._m._ty._on._to._fr._lau.".split("_"),
      weekdaysMin: "su_m_ty_on_to_fr_la".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY [kl.] H:mm",
        LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
      },
      calendar: {
        sameDay: "[I dag klokka] LT",
        nextDay: "[I morgon klokka] LT",
        nextWeek: "dddd [klokka] LT",
        lastDay: "[I gr klokka] LT",
        lastWeek: "[Fregande] dddd [klokka] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "om %s",
        past: "%s sidan",
        s: "nokre sekund",
        ss: "%d sekund",
        m: "eit minutt",
        mm: "%d minutt",
        h: "ein time",
        hh: "%d timar",
        d: "ein dag",
        dd: "%d dagar",
        w: "ei veke",
        ww: "%d veker",
        M: "ein mnad",
        MM: "%d mnader",
        y: "eit r",
        yy: "%d r"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("oc-lnc", {
      months: {
        standalone: "genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre".split(
          "_"
        ),
        format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split(
          "_"
        ),
        isFormat: /D[oD]?(\s)+MMMM/
      },
      monthsShort: "gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte".split(
        "_"
      ),
      weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
      weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM [de] YYYY",
        ll: "D MMM YYYY",
        LLL: "D MMMM [de] YYYY [a] H:mm",
        lll: "D MMM YYYY, H:mm",
        LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
        llll: "ddd D MMM YYYY, H:mm"
      },
      calendar: {
        sameDay: "[ui a] LT",
        nextDay: "[deman a] LT",
        nextWeek: "dddd [a] LT",
        lastDay: "[ir a] LT",
        lastWeek: "dddd [passat a] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "d'aqu %s",
        past: "fa %s",
        s: "unas segondas",
        ss: "%d segondas",
        m: "una minuta",
        mm: "%d minutas",
        h: "una ora",
        hh: "%d oras",
        d: "un jorn",
        dd: "%d jorns",
        M: "un mes",
        MM: "%d meses",
        y: "un an",
        yy: "%d ans"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
      ordinal: function(number, period) {
        var output = number === 1 ? "r" : number === 2 ? "n" : number === 3 ? "r" : number === 4 ? "t" : "";
        if (period === "w" || period === "W") {
          output = "a";
        }
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
      }
    });
    //! moment.js locale configuration
    var symbolMap$g = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$f = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("pa-in", {
      // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm ",
        LTS: "A h:mm:ss ",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm ",
        LLLL: "dddd, D MMMM YYYY, A h:mm "
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[] dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$f[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$g[match];
        });
      },
      // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
      // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 10 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 10) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var monthsNominative = "stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie".split(
      "_"
    ), monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia".split(
      "_"
    ), monthsParse$a = [
      /^sty/i,
      /^lut/i,
      /^mar/i,
      /^kwi/i,
      /^maj/i,
      /^cze/i,
      /^lip/i,
      /^sie/i,
      /^wrz/i,
      /^pa/i,
      /^lis/i,
      /^gru/i
    ];
    function plural$3(n2) {
      return n2 % 10 < 5 && n2 % 10 > 1 && ~~(n2 / 10) % 10 !== 1;
    }
    function translate$8(number, withoutSuffix, key) {
      var result = number + " ";
      switch (key) {
        case "ss":
          return result + (plural$3(number) ? "sekundy" : "sekund");
        case "m":
          return withoutSuffix ? "minuta" : "minut";
        case "mm":
          return result + (plural$3(number) ? "minuty" : "minut");
        case "h":
          return withoutSuffix ? "godzina" : "godzin";
        case "hh":
          return result + (plural$3(number) ? "godziny" : "godzin");
        case "ww":
          return result + (plural$3(number) ? "tygodnie" : "tygodni");
        case "MM":
          return result + (plural$3(number) ? "miesice" : "miesicy");
        case "yy":
          return result + (plural$3(number) ? "lata" : "lat");
      }
    }
    hooks2.defineLocale("pl", {
      months: function(momentToFormat, format2) {
        if (!momentToFormat) {
          return monthsNominative;
        } else if (/D MMMM/.test(format2)) {
          return monthsSubjective[momentToFormat.month()];
        } else {
          return monthsNominative[momentToFormat.month()];
        }
      },
      monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru".split("_"),
      monthsParse: monthsParse$a,
      longMonthsParse: monthsParse$a,
      shortMonthsParse: monthsParse$a,
      weekdays: "niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota".split("_"),
      weekdaysShort: "ndz_pon_wt_r_czw_pt_sob".split("_"),
      weekdaysMin: "Nd_Pn_Wt_r_Cz_Pt_So".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Dzi o] LT",
        nextDay: "[Jutro o] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[W niedziel o] LT";
            case 2:
              return "[We wtorek o] LT";
            case 3:
              return "[W rod o] LT";
            case 6:
              return "[W sobot o] LT";
            default:
              return "[W] dddd [o] LT";
          }
        },
        lastDay: "[Wczoraj o] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
              return "[W zesz niedziel o] LT";
            case 3:
              return "[W zesz rod o] LT";
            case 6:
              return "[W zesz sobot o] LT";
            default:
              return "[W zeszy] dddd [o] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "za %s",
        past: "%s temu",
        s: "kilka sekund",
        ss: translate$8,
        m: translate$8,
        mm: translate$8,
        h: translate$8,
        hh: translate$8,
        d: "1 dzie",
        dd: "%d dni",
        w: "tydzie",
        ww: translate$8,
        M: "miesic",
        MM: translate$8,
        y: "rok",
        yy: translate$8
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("pt-br", {
      months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split(
        "_"
      ),
      monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
      weekdays: "domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado".split(
        "_"
      ),
      weekdaysShort: "dom_seg_ter_qua_qui_sex_sb".split("_"),
      weekdaysMin: "do_2_3_4_5_6_s".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D [de] MMMM [de] YYYY",
        LLL: "D [de] MMMM [de] YYYY [s] HH:mm",
        LLLL: "dddd, D [de] MMMM [de] YYYY [s] HH:mm"
      },
      calendar: {
        sameDay: "[Hoje s] LT",
        nextDay: "[Amanh s] LT",
        nextWeek: "dddd [s] LT",
        lastDay: "[Ontem s] LT",
        lastWeek: function() {
          return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "em %s",
        past: "h %s",
        s: "poucos segundos",
        ss: "%d segundos",
        m: "um minuto",
        mm: "%d minutos",
        h: "uma hora",
        hh: "%d horas",
        d: "um dia",
        dd: "%d dias",
        M: "um ms",
        MM: "%d meses",
        y: "um ano",
        yy: "%d anos"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      invalidDate: "Data invlida"
    });
    //! moment.js locale configuration
    hooks2.defineLocale("pt", {
      months: "janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split(
        "_"
      ),
      monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
      weekdays: "Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado".split(
        "_"
      ),
      weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sb".split("_"),
      weekdaysMin: "Do_2_3_4_5_6_S".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D [de] MMMM [de] YYYY",
        LLL: "D [de] MMMM [de] YYYY HH:mm",
        LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Hoje s] LT",
        nextDay: "[Amanh s] LT",
        nextWeek: "dddd [s] LT",
        lastDay: "[Ontem s] LT",
        lastWeek: function() {
          return this.day() === 0 || this.day() === 6 ? "[ltimo] dddd [s] LT" : "[ltima] dddd [s] LT";
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "em %s",
        past: "h %s",
        s: "segundos",
        ss: "%d segundos",
        m: "um minuto",
        mm: "%d minutos",
        h: "uma hora",
        hh: "%d horas",
        d: "um dia",
        dd: "%d dias",
        w: "uma semana",
        ww: "%d semanas",
        M: "um ms",
        MM: "%d meses",
        y: "um ano",
        yy: "%d anos"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function relativeTimeWithPlural$2(number, withoutSuffix, key) {
      var format2 = {
        ss: "secunde",
        mm: "minute",
        hh: "ore",
        dd: "zile",
        ww: "sptmni",
        MM: "luni",
        yy: "ani"
      }, separator = " ";
      if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
        separator = " de ";
      }
      return number + separator + format2[key];
    }
    hooks2.defineLocale("ro", {
      months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split(
        "_"
      ),
      monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "duminic_luni_mari_miercuri_joi_vineri_smbt".split("_"),
      weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sm".split("_"),
      weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_S".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY H:mm",
        LLLL: "dddd, D MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[azi la] LT",
        nextDay: "[mine la] LT",
        nextWeek: "dddd [la] LT",
        lastDay: "[ieri la] LT",
        lastWeek: "[fosta] dddd [la] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "peste %s",
        past: "%s n urm",
        s: "cteva secunde",
        ss: relativeTimeWithPlural$2,
        m: "un minut",
        mm: relativeTimeWithPlural$2,
        h: "o or",
        hh: relativeTimeWithPlural$2,
        d: "o zi",
        dd: relativeTimeWithPlural$2,
        w: "o sptmn",
        ww: relativeTimeWithPlural$2,
        M: "o lun",
        MM: relativeTimeWithPlural$2,
        y: "un an",
        yy: relativeTimeWithPlural$2
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function plural$4(word, num) {
      var forms2 = word.split("_");
      return num % 10 === 1 && num % 100 !== 11 ? forms2[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms2[1] : forms2[2];
    }
    function relativeTimeWithPlural$3(number, withoutSuffix, key) {
      var format2 = {
        ss: withoutSuffix ? "__" : "__",
        mm: withoutSuffix ? "__" : "__",
        hh: "__",
        dd: "__",
        ww: "__",
        MM: "__",
        yy: "__"
      };
      if (key === "m") {
        return withoutSuffix ? "" : "";
      } else {
        return number + " " + plural$4(format2[key], +number);
      }
    }
    var monthsParse$b = [
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^[]/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i,
      /^/i
    ];
    hooks2.defineLocale("ru", {
      months: {
        format: "___________".split(
          "_"
        ),
        standalone: "___________".split(
          "_"
        )
      },
      monthsShort: {
        //  CLDR  "."  ".",       ?
        format: "._._._.____._._._._.".split(
          "_"
        ),
        standalone: "._.__.____._._._._.".split(
          "_"
        )
      },
      weekdays: {
        standalone: "______".split(
          "_"
        ),
        format: "______".split(
          "_"
        ),
        isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
      },
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      monthsParse: monthsParse$b,
      longMonthsParse: monthsParse$b,
      shortMonthsParse: monthsParse$b,
      //    ,   ,  ,  4 ,      
      monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
      //  
      monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
      //    
      monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
      // ,     
      monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY .",
        LLL: "D MMMM YYYY ., H:mm",
        LLLL: "dddd, D MMMM YYYY ., H:mm"
      },
      calendar: {
        sameDay: "[, ] LT",
        nextDay: "[, ] LT",
        lastDay: "[, ] LT",
        nextWeek: function(now3) {
          if (now3.week() !== this.week()) {
            switch (this.day()) {
              case 0:
                return "[ ] dddd, [] LT";
              case 1:
              case 2:
              case 4:
                return "[ ] dddd, [] LT";
              case 3:
              case 5:
              case 6:
                return "[ ] dddd, [] LT";
            }
          } else {
            if (this.day() === 2) {
              return "[] dddd, [] LT";
            } else {
              return "[] dddd, [] LT";
            }
          }
        },
        lastWeek: function(now3) {
          if (now3.week() !== this.week()) {
            switch (this.day()) {
              case 0:
                return "[ ] dddd, [] LT";
              case 1:
              case 2:
              case 4:
                return "[ ] dddd, [] LT";
              case 3:
              case 5:
              case 6:
                return "[ ] dddd, [] LT";
            }
          } else {
            if (this.day() === 2) {
              return "[] dddd, [] LT";
            } else {
              return "[] dddd, [] LT";
            }
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s ",
        s: " ",
        ss: relativeTimeWithPlural$3,
        m: relativeTimeWithPlural$3,
        mm: relativeTimeWithPlural$3,
        h: "",
        hh: relativeTimeWithPlural$3,
        d: "",
        dd: relativeTimeWithPlural$3,
        w: "",
        ww: relativeTimeWithPlural$3,
        M: "",
        MM: relativeTimeWithPlural$3,
        y: "",
        yy: relativeTimeWithPlural$3
      },
      meridiemParse: /|||/i,
      isPM: function(input) {
        return /^(|)$/.test(input);
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 17) {
          return "";
        } else {
          return "";
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
      ordinal: function(number, period) {
        switch (period) {
          case "M":
          case "d":
          case "DDD":
            return number + "-";
          case "D":
            return number + "-";
          case "w":
          case "W":
            return number + "-";
          default:
            return number;
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var months$9 = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ], days$1 = ["", "", "", "", "", "", ""];
    hooks2.defineLocale("sd", {
      months: months$9,
      monthsShort: months$9,
      weekdays: days$1,
      weekdaysShort: days$1,
      weekdaysMin: days$1,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        }
        return "";
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd [  ] LT",
        lastDay: "[] LT",
        lastWeek: "[ ] dddd [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/,/g, "");
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("se", {
      months: "oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu".split(
        "_"
      ),
      monthsShort: "oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov".split("_"),
      weekdays: "sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat".split(
        "_"
      ),
      weekdaysShort: "sotn_vuos_ma_gask_duor_bear_lv".split("_"),
      weekdaysMin: "s_v_m_g_d_b_L".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "MMMM D. [b.] YYYY",
        LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
        LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
      },
      calendar: {
        sameDay: "[otne ti] LT",
        nextDay: "[ihttin ti] LT",
        nextWeek: "dddd [ti] LT",
        lastDay: "[ikte ti] LT",
        lastWeek: "[ovddit] dddd [ti] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s geaes",
        past: "mait %s",
        s: "moadde sekunddat",
        ss: "%d sekunddat",
        m: "okta minuhta",
        mm: "%d minuhtat",
        h: "okta diimmu",
        hh: "%d diimmut",
        d: "okta beaivi",
        dd: "%d beaivvit",
        M: "okta mnnu",
        MM: "%d mnut",
        y: "okta jahki",
        yy: "%d jagit"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("si", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "a h:mm",
        LTS: "a h:mm:ss",
        L: "YYYY/MM/DD",
        LL: "YYYY MMMM D",
        LLL: "YYYY MMMM D, a h:mm",
        LLLL: "YYYY MMMM D [] dddd, a h:mm:ss"
      },
      calendar: {
        sameDay: "[] LT[]",
        nextDay: "[] LT[]",
        nextWeek: "dddd LT[]",
        lastDay: "[] LT[]",
        lastWeek: "[] dddd LT[]",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s",
        past: "%s ",
        s: " ",
        ss: " %d",
        m: "",
        mm: " %d",
        h: "",
        hh: " %d",
        d: "",
        dd: " %d",
        M: "",
        MM: " %d",
        y: "",
        yy: " %d"
      },
      dayOfMonthOrdinalParse: /\d{1,2} /,
      ordinal: function(number) {
        return number + " ";
      },
      meridiemParse: / | |.|../,
      isPM: function(input) {
        return input === ".." || input === " ";
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? ".." : " ";
        } else {
          return isLower ? ".." : " ";
        }
      }
    });
    //! moment.js locale configuration
    var months$a = "janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december".split(
      "_"
    ), monthsShort$7 = "jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec".split("_");
    function plural$5(n2) {
      return n2 > 1 && n2 < 5;
    }
    function translate$9(number, withoutSuffix, key, isFuture) {
      var result = number + " ";
      switch (key) {
        case "s":
          return withoutSuffix || isFuture ? "pr seknd" : "pr sekundami";
        case "ss":
          if (withoutSuffix || isFuture) {
            return result + (plural$5(number) ? "sekundy" : "seknd");
          } else {
            return result + "sekundami";
          }
        case "m":
          return withoutSuffix ? "minta" : isFuture ? "mintu" : "mintou";
        case "mm":
          if (withoutSuffix || isFuture) {
            return result + (plural$5(number) ? "minty" : "mint");
          } else {
            return result + "mintami";
          }
        case "h":
          return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
        case "hh":
          if (withoutSuffix || isFuture) {
            return result + (plural$5(number) ? "hodiny" : "hodn");
          } else {
            return result + "hodinami";
          }
        case "d":
          return withoutSuffix || isFuture ? "de" : "dom";
        case "dd":
          if (withoutSuffix || isFuture) {
            return result + (plural$5(number) ? "dni" : "dn");
          } else {
            return result + "dami";
          }
        case "M":
          return withoutSuffix || isFuture ? "mesiac" : "mesiacom";
        case "MM":
          if (withoutSuffix || isFuture) {
            return result + (plural$5(number) ? "mesiace" : "mesiacov");
          } else {
            return result + "mesiacmi";
          }
        case "y":
          return withoutSuffix || isFuture ? "rok" : "rokom";
        case "yy":
          if (withoutSuffix || isFuture) {
            return result + (plural$5(number) ? "roky" : "rokov");
          } else {
            return result + "rokmi";
          }
      }
    }
    hooks2.defineLocale("sk", {
      months: months$a,
      monthsShort: monthsShort$7,
      weekdays: "nedea_pondelok_utorok_streda_tvrtok_piatok_sobota".split("_"),
      weekdaysShort: "ne_po_ut_st_t_pi_so".split("_"),
      weekdaysMin: "ne_po_ut_st_t_pi_so".split("_"),
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY H:mm",
        LLLL: "dddd D. MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[dnes o] LT",
        nextDay: "[zajtra o] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[v nedeu o] LT";
            case 1:
            case 2:
              return "[v] dddd [o] LT";
            case 3:
              return "[v stredu o] LT";
            case 4:
              return "[vo tvrtok o] LT";
            case 5:
              return "[v piatok o] LT";
            case 6:
              return "[v sobotu o] LT";
          }
        },
        lastDay: "[vera o] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
              return "[minul nedeu o] LT";
            case 1:
            case 2:
              return "[minul] dddd [o] LT";
            case 3:
              return "[minul stredu o] LT";
            case 4:
            case 5:
              return "[minul] dddd [o] LT";
            case 6:
              return "[minul sobotu o] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "za %s",
        past: "pred %s",
        s: translate$9,
        ss: translate$9,
        m: translate$9,
        mm: translate$9,
        h: translate$9,
        hh: translate$9,
        d: translate$9,
        dd: translate$9,
        M: translate$9,
        MM: translate$9,
        y: translate$9,
        yy: translate$9
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function processRelativeTime$9(number, withoutSuffix, key, isFuture) {
      var result = number + " ";
      switch (key) {
        case "s":
          return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";
        case "ss":
          if (number === 1) {
            result += withoutSuffix ? "sekundo" : "sekundi";
          } else if (number === 2) {
            result += withoutSuffix || isFuture ? "sekundi" : "sekundah";
          } else if (number < 5) {
            result += withoutSuffix || isFuture ? "sekunde" : "sekundah";
          } else {
            result += "sekund";
          }
          return result;
        case "m":
          return withoutSuffix ? "ena minuta" : "eno minuto";
        case "mm":
          if (number === 1) {
            result += withoutSuffix ? "minuta" : "minuto";
          } else if (number === 2) {
            result += withoutSuffix || isFuture ? "minuti" : "minutama";
          } else if (number < 5) {
            result += withoutSuffix || isFuture ? "minute" : "minutami";
          } else {
            result += withoutSuffix || isFuture ? "minut" : "minutami";
          }
          return result;
        case "h":
          return withoutSuffix ? "ena ura" : "eno uro";
        case "hh":
          if (number === 1) {
            result += withoutSuffix ? "ura" : "uro";
          } else if (number === 2) {
            result += withoutSuffix || isFuture ? "uri" : "urama";
          } else if (number < 5) {
            result += withoutSuffix || isFuture ? "ure" : "urami";
          } else {
            result += withoutSuffix || isFuture ? "ur" : "urami";
          }
          return result;
        case "d":
          return withoutSuffix || isFuture ? "en dan" : "enim dnem";
        case "dd":
          if (number === 1) {
            result += withoutSuffix || isFuture ? "dan" : "dnem";
          } else if (number === 2) {
            result += withoutSuffix || isFuture ? "dni" : "dnevoma";
          } else {
            result += withoutSuffix || isFuture ? "dni" : "dnevi";
          }
          return result;
        case "M":
          return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";
        case "MM":
          if (number === 1) {
            result += withoutSuffix || isFuture ? "mesec" : "mesecem";
          } else if (number === 2) {
            result += withoutSuffix || isFuture ? "meseca" : "mesecema";
          } else if (number < 5) {
            result += withoutSuffix || isFuture ? "mesece" : "meseci";
          } else {
            result += withoutSuffix || isFuture ? "mesecev" : "meseci";
          }
          return result;
        case "y":
          return withoutSuffix || isFuture ? "eno leto" : "enim letom";
        case "yy":
          if (number === 1) {
            result += withoutSuffix || isFuture ? "leto" : "letom";
          } else if (number === 2) {
            result += withoutSuffix || isFuture ? "leti" : "letoma";
          } else if (number < 5) {
            result += withoutSuffix || isFuture ? "leta" : "leti";
          } else {
            result += withoutSuffix || isFuture ? "let" : "leti";
          }
          return result;
      }
    }
    hooks2.defineLocale("sl", {
      months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split(
        "_"
      ),
      monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota".split("_"),
      weekdaysShort: "ned._pon._tor._sre._et._pet._sob.".split("_"),
      weekdaysMin: "ne_po_to_sr_e_pe_so".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD. MM. YYYY",
        LL: "D. MMMM YYYY",
        LLL: "D. MMMM YYYY H:mm",
        LLLL: "dddd, D. MMMM YYYY H:mm"
      },
      calendar: {
        sameDay: "[danes ob] LT",
        nextDay: "[jutri ob] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[v] [nedeljo] [ob] LT";
            case 3:
              return "[v] [sredo] [ob] LT";
            case 6:
              return "[v] [soboto] [ob] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[v] dddd [ob] LT";
          }
        },
        lastDay: "[veraj ob] LT",
        lastWeek: function() {
          switch (this.day()) {
            case 0:
              return "[prejnjo] [nedeljo] [ob] LT";
            case 3:
              return "[prejnjo] [sredo] [ob] LT";
            case 6:
              return "[prejnjo] [soboto] [ob] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[prejnji] dddd [ob] LT";
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "ez %s",
        past: "pred %s",
        s: processRelativeTime$9,
        ss: processRelativeTime$9,
        m: processRelativeTime$9,
        mm: processRelativeTime$9,
        h: processRelativeTime$9,
        hh: processRelativeTime$9,
        d: processRelativeTime$9,
        dd: processRelativeTime$9,
        M: processRelativeTime$9,
        MM: processRelativeTime$9,
        y: processRelativeTime$9,
        yy: processRelativeTime$9
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("sq", {
      months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor".split(
        "_"
      ),
      monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj".split("_"),
      weekdays: "E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun".split(
        "_"
      ),
      weekdaysShort: "Die_Hn_Mar_Mr_Enj_Pre_Sht".split("_"),
      weekdaysMin: "D_H_Ma_M_E_P_Sh".split("_"),
      weekdaysParseExact: true,
      meridiemParse: /PD|MD/,
      isPM: function(input) {
        return input.charAt(0) === "M";
      },
      meridiem: function(hours2, minutes2, isLower) {
        return hours2 < 12 ? "PD" : "MD";
      },
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Sot n] LT",
        nextDay: "[Nesr n] LT",
        nextWeek: "dddd [n] LT",
        lastDay: "[Dje n] LT",
        lastWeek: "dddd [e kaluar n] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "n %s",
        past: "%s m par",
        s: "disa sekonda",
        ss: "%d sekonda",
        m: "nj minut",
        mm: "%d minuta",
        h: "nj or",
        hh: "%d or",
        d: "nj dit",
        dd: "%d dit",
        M: "nj muaj",
        MM: "%d muaj",
        y: "nj vit",
        yy: "%d vite"
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var translator$1 = {
      words: {
        //Different grammatical cases
        ss: ["", "", ""],
        m: [" ", " "],
        mm: ["", "", ""],
        h: [" ", " "],
        hh: ["", "", ""],
        d: [" ", " "],
        dd: ["", "", ""],
        M: [" ", " "],
        MM: ["", "", ""],
        y: [" ", " "],
        yy: ["", "", ""]
      },
      correctGrammaticalCase: function(number, wordKey) {
        if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
          return number % 10 === 1 ? wordKey[0] : wordKey[1];
        }
        return wordKey[2];
      },
      translate: function(number, withoutSuffix, key, isFuture) {
        var wordKey = translator$1.words[key], word;
        if (key.length === 1) {
          if (key === "y" && withoutSuffix) return " ";
          return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
        }
        word = translator$1.correctGrammaticalCase(number, wordKey);
        if (key === "yy" && withoutSuffix && word === "") {
          return number + " ";
        }
        return number + " " + word;
      }
    };
    hooks2.defineLocale("sr-cyrl", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "._._._.____._._._._.".split("_"),
      monthsParseExact: true,
      weekdays: "______".split("_"),
      weekdaysShort: "._._._._._._.".split("_"),
      weekdaysMin: "______".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "D. M. YYYY.",
        LL: "D. MMMM YYYY.",
        LLL: "D. MMMM YYYY. H:mm",
        LLLL: "dddd, D. MMMM YYYY. H:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[] [] [] LT";
            case 3:
              return "[] [] [] LT";
            case 6:
              return "[] [] [] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[] dddd [] LT";
          }
        },
        lastDay: "[ ] LT",
        lastWeek: function() {
          var lastWeekDays = [
            "[] [] [] LT",
            "[] [] [] LT",
            "[] [] [] LT",
            "[] [] [] LT",
            "[] [] [] LT",
            "[] [] [] LT",
            "[] [] [] LT"
          ];
          return lastWeekDays[this.day()];
        },
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: " %s",
        s: " ",
        ss: translator$1.translate,
        m: translator$1.translate,
        mm: translator$1.translate,
        h: translator$1.translate,
        hh: translator$1.translate,
        d: translator$1.translate,
        dd: translator$1.translate,
        M: translator$1.translate,
        MM: translator$1.translate,
        y: translator$1.translate,
        yy: translator$1.translate
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 1st is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var translator$2 = {
      words: {
        //Different grammatical cases
        ss: ["sekunda", "sekunde", "sekundi"],
        m: ["jedan minut", "jednog minuta"],
        mm: ["minut", "minuta", "minuta"],
        h: ["jedan sat", "jednog sata"],
        hh: ["sat", "sata", "sati"],
        d: ["jedan dan", "jednog dana"],
        dd: ["dan", "dana", "dana"],
        M: ["jedan mesec", "jednog meseca"],
        MM: ["mesec", "meseca", "meseci"],
        y: ["jednu godinu", "jedne godine"],
        yy: ["godinu", "godine", "godina"]
      },
      correctGrammaticalCase: function(number, wordKey) {
        if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
          return number % 10 === 1 ? wordKey[0] : wordKey[1];
        }
        return wordKey[2];
      },
      translate: function(number, withoutSuffix, key, isFuture) {
        var wordKey = translator$2.words[key], word;
        if (key.length === 1) {
          if (key === "y" && withoutSuffix) return "jedna godina";
          return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
        }
        word = translator$2.correctGrammaticalCase(number, wordKey);
        if (key === "yy" && withoutSuffix && word === "godinu") {
          return number + " godina";
        }
        return number + " " + word;
      }
    };
    hooks2.defineLocale("sr", {
      months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split(
        "_"
      ),
      monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
      monthsParseExact: true,
      weekdays: "nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota".split(
        "_"
      ),
      weekdaysShort: "ned._pon._uto._sre._et._pet._sub.".split("_"),
      weekdaysMin: "ne_po_ut_sr_e_pe_su".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "D. M. YYYY.",
        LL: "D. MMMM YYYY.",
        LLL: "D. MMMM YYYY. H:mm",
        LLLL: "dddd, D. MMMM YYYY. H:mm"
      },
      calendar: {
        sameDay: "[danas u] LT",
        nextDay: "[sutra u] LT",
        nextWeek: function() {
          switch (this.day()) {
            case 0:
              return "[u] [nedelju] [u] LT";
            case 3:
              return "[u] [sredu] [u] LT";
            case 6:
              return "[u] [subotu] [u] LT";
            case 1:
            case 2:
            case 4:
            case 5:
              return "[u] dddd [u] LT";
          }
        },
        lastDay: "[jue u] LT",
        lastWeek: function() {
          var lastWeekDays = [
            "[prole] [nedelje] [u] LT",
            "[prolog] [ponedeljka] [u] LT",
            "[prolog] [utorka] [u] LT",
            "[prole] [srede] [u] LT",
            "[prolog] [etvrtka] [u] LT",
            "[prolog] [petka] [u] LT",
            "[prole] [subote] [u] LT"
          ];
          return lastWeekDays[this.day()];
        },
        sameElse: "L"
      },
      relativeTime: {
        future: "za %s",
        past: "pre %s",
        s: "nekoliko sekundi",
        ss: translator$2.translate,
        m: translator$2.translate,
        mm: translator$2.translate,
        h: translator$2.translate,
        hh: translator$2.translate,
        d: translator$2.translate,
        dd: translator$2.translate,
        M: translator$2.translate,
        MM: translator$2.translate,
        y: translator$2.translate,
        yy: translator$2.translate
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ss", {
      months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split(
        "_"
      ),
      monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
      weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split(
        "_"
      ),
      weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
      weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY h:mm A",
        LLLL: "dddd, D MMMM YYYY h:mm A"
      },
      calendar: {
        sameDay: "[Namuhla nga] LT",
        nextDay: "[Kusasa nga] LT",
        nextWeek: "dddd [nga] LT",
        lastDay: "[Itolo nga] LT",
        lastWeek: "dddd [leliphelile] [nga] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "nga %s",
        past: "wenteka nga %s",
        s: "emizuzwana lomcane",
        ss: "%d mzuzwana",
        m: "umzuzu",
        mm: "%d emizuzu",
        h: "lihora",
        hh: "%d emahora",
        d: "lilanga",
        dd: "%d emalanga",
        M: "inyanga",
        MM: "%d tinyanga",
        y: "umnyaka",
        yy: "%d iminyaka"
      },
      meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 11) {
          return "ekuseni";
        } else if (hours2 < 15) {
          return "emini";
        } else if (hours2 < 19) {
          return "entsambama";
        } else {
          return "ebusuku";
        }
      },
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "ekuseni") {
          return hour;
        } else if (meridiem2 === "emini") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "entsambama" || meridiem2 === "ebusuku") {
          if (hour === 0) {
            return 0;
          }
          return hour + 12;
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("sv", {
      months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split(
        "_"
      ),
      monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
      weekdays: "sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag".split("_"),
      weekdaysShort: "sn_mn_tis_ons_tor_fre_lr".split("_"),
      weekdaysMin: "s_m_ti_on_to_fr_l".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY-MM-DD",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY [kl.] HH:mm",
        LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
        lll: "D MMM YYYY HH:mm",
        llll: "ddd D MMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Idag] LT",
        nextDay: "[Imorgon] LT",
        lastDay: "[Igr] LT",
        nextWeek: "[P] dddd LT",
        lastWeek: "[I] dddd[s] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "om %s",
        past: "fr %s sedan",
        s: "ngra sekunder",
        ss: "%d sekunder",
        m: "en minut",
        mm: "%d minuter",
        h: "en timme",
        hh: "%d timmar",
        d: "en dag",
        dd: "%d dagar",
        M: "en mnad",
        MM: "%d mnader",
        y: "ett r",
        yy: "%d r"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? ":e" : b === 1 ? ":a" : b === 2 ? ":a" : b === 3 ? ":e" : ":e";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("sw", {
      months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split(
        "_"
      ),
      monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
      weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split(
        "_"
      ),
      weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
      weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "hh:mm A",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[leo saa] LT",
        nextDay: "[kesho saa] LT",
        nextWeek: "[wiki ijayo] dddd [saat] LT",
        lastDay: "[jana] LT",
        lastWeek: "[wiki iliyopita] dddd [saat] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s baadaye",
        past: "tokea %s",
        s: "hivi punde",
        ss: "sekunde %d",
        m: "dakika moja",
        mm: "dakika %d",
        h: "saa limoja",
        hh: "masaa %d",
        d: "siku moja",
        dd: "siku %d",
        M: "mwezi mmoja",
        MM: "miezi %d",
        y: "mwaka mmoja",
        yy: "miaka %d"
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var symbolMap$h = {
      1: "",
      2: "",
      3: "",
      4: "",
      5: "",
      6: "",
      7: "",
      8: "",
      9: "",
      0: ""
    }, numberMap$g = {
      "": "1",
      "": "2",
      "": "3",
      "": "4",
      "": "5",
      "": "6",
      "": "7",
      "": "8",
      "": "9",
      "": "0"
    };
    hooks2.defineLocale("ta", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split(
        "_"
      ),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, HH:mm",
        LLLL: "dddd, D MMMM YYYY, HH:mm"
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[ ] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: "  ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: "  ",
        hh: "%d  ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function(number) {
        return number + "";
      },
      preparse: function(string) {
        return string.replace(/[]/g, function(match) {
          return numberMap$g[match];
        });
      },
      postformat: function(string) {
        return string.replace(/\d/g, function(match) {
          return symbolMap$h[match];
        });
      },
      // refer http://ta.wikipedia.org/s/1er1
      meridiemParse: /|||||/,
      meridiem: function(hour, minute, isLower) {
        if (hour < 2) {
          return " ";
        } else if (hour < 6) {
          return " ";
        } else if (hour < 10) {
          return " ";
        } else if (hour < 14) {
          return " ";
        } else if (hour < 18) {
          return " ";
        } else if (hour < 22) {
          return " ";
        } else {
          return " ";
        }
      },
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 2 ? hour : hour + 12;
        } else if (meridiem2 === "" || meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 10 ? hour : hour + 12;
        } else {
          return hour + 12;
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("te", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "._.__.____._._._._.".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "A h:mm",
        LTS: "A h:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY, A h:mm",
        LLLL: "dddd, D MMMM YYYY, A h:mm"
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "dddd, LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd, LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: "%d",
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 10 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 10) {
          return "";
        } else if (hour < 17) {
          return "";
        } else if (hour < 20) {
          return "";
        } else {
          return "";
        }
      },
      week: {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6
        // The week that contains Jan 6th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("tet", {
      months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split(
        "_"
      ),
      monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
      weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
      weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
      weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Ohin iha] LT",
        nextDay: "[Aban iha] LT",
        nextWeek: "dddd [iha] LT",
        lastDay: "[Horiseik iha] LT",
        lastWeek: "dddd [semana kotuk] [iha] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "iha %s",
        past: "%s liuba",
        s: "segundu balun",
        ss: "segundu %d",
        m: "minutu ida",
        mm: "minutu %d",
        h: "oras ida",
        hh: "oras %d",
        d: "loron ida",
        dd: "loron %d",
        M: "fulan ida",
        MM: "fulan %d",
        y: "tinan ida",
        yy: "tinan %d"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var suffixes$3 = {
      0: "-",
      1: "-",
      2: "-",
      3: "-",
      4: "-",
      5: "-",
      6: "-",
      7: "-",
      8: "-",
      9: "-",
      10: "-",
      12: "-",
      13: "-",
      20: "-",
      30: "-",
      40: "-",
      50: "-",
      60: "-",
      70: "-",
      80: "-",
      90: "-",
      100: "-"
    };
    hooks2.defineLocale("tg", {
      months: {
        format: "___________".split(
          "_"
        ),
        standalone: "___________".split(
          "_"
        )
      },
      monthsShort: "___________".split("_"),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        lastDay: "[ ] LT",
        nextWeek: "dddd[] [  ] LT",
        lastWeek: "dddd[] [  ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s ",
        s: " ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      meridiemParse: /|||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "") {
          return hour < 4 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 11) {
          return "";
        } else if (hour < 16) {
          return "";
        } else if (hour < 19) {
          return "";
        } else {
          return "";
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
      ordinal: function(number) {
        var a = number % 10, b = number >= 100 ? 100 : null;
        return number + (suffixes$3[number] || suffixes$3[a] || suffixes$3[b]);
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 1th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("th", {
      months: "___________".split(
        "_"
      ),
      monthsShort: ".._.._.._.._.._.._.._.._.._.._.._..".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      // yes, three characters difference
      weekdaysMin: "._._._._._._.".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "H:mm",
        LTS: "H:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY  H:mm",
        LLLL: "dddd D MMMM YYYY  H:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return input === "";
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd[ ] LT",
        lastDay: "[ ] LT",
        lastWeek: "[]dddd[ ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s",
        s: "",
        ss: "%d ",
        m: "1 ",
        mm: "%d ",
        h: "1 ",
        hh: "%d ",
        d: "1 ",
        dd: "%d ",
        w: "1 ",
        ww: "%d ",
        M: "1 ",
        MM: "%d ",
        y: "1 ",
        yy: "%d "
      }
    });
    //! moment.js locale configuration
    var suffixes$4 = {
      1: "'inji",
      5: "'inji",
      8: "'inji",
      70: "'inji",
      80: "'inji",
      2: "'nji",
      7: "'nji",
      20: "'nji",
      50: "'nji",
      3: "'nji",
      4: "'nji",
      100: "'nji",
      6: "'njy",
      9: "'unjy",
      10: "'unjy",
      30: "'unjy",
      60: "'ynjy",
      90: "'ynjy"
    };
    hooks2.defineLocale("tk", {
      months: "anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr".split(
        "_"
      ),
      monthsShort: "an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek".split("_"),
      weekdays: "ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe".split(
        "_"
      ),
      weekdaysShort: "ek_Du_Si_ar_Pen_Ann_en".split("_"),
      weekdaysMin: "k_D_S_r_Pn_An_n".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[bugn sagat] LT",
        nextDay: "[ertir sagat] LT",
        nextWeek: "[indiki] dddd [sagat] LT",
        lastDay: "[dn] LT",
        lastWeek: "[geen] dddd [sagat] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s so",
        past: "%s ",
        s: "birne sekunt",
        m: "bir minut",
        mm: "%d minut",
        h: "bir sagat",
        hh: "%d sagat",
        d: "bir gn",
        dd: "%d gn",
        M: "bir a",
        MM: "%d a",
        y: "bir yl",
        yy: "%d yl"
      },
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "Do":
          case "DD":
            return number;
          default:
            if (number === 0) {
              return number + "'unjy";
            }
            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
            return number + (suffixes$4[a] || suffixes$4[b] || suffixes$4[c]);
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("tl-ph", {
      months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split(
        "_"
      ),
      monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
      weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split(
        "_"
      ),
      weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
      weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "MM/D/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY HH:mm",
        LLLL: "dddd, MMMM DD, YYYY HH:mm"
      },
      calendar: {
        sameDay: "LT [ngayong araw]",
        nextDay: "[Bukas ng] LT",
        nextWeek: "LT [sa susunod na] dddd",
        lastDay: "LT [kahapon]",
        lastWeek: "LT [noong nakaraang] dddd",
        sameElse: "L"
      },
      relativeTime: {
        future: "sa loob ng %s",
        past: "%s ang nakalipas",
        s: "ilang segundo",
        ss: "%d segundo",
        m: "isang minuto",
        mm: "%d minuto",
        h: "isang oras",
        hh: "%d oras",
        d: "isang araw",
        dd: "%d araw",
        M: "isang buwan",
        MM: "%d buwan",
        y: "isang taon",
        yy: "%d taon"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function(number) {
        return number;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var numbersNouns = "pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");
    function translateFuture(output) {
      var time = output;
      time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "leS" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "waQ" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "nem" : time + " pIq";
      return time;
    }
    function translatePast(output) {
      var time = output;
      time = output.indexOf("jaj") !== -1 ? time.slice(0, -3) + "Hu" : output.indexOf("jar") !== -1 ? time.slice(0, -3) + "wen" : output.indexOf("DIS") !== -1 ? time.slice(0, -3) + "ben" : time + " ret";
      return time;
    }
    function translate$a(number, withoutSuffix, string, isFuture) {
      var numberNoun = numberAsNoun(number);
      switch (string) {
        case "ss":
          return numberNoun + " lup";
        case "mm":
          return numberNoun + " tup";
        case "hh":
          return numberNoun + " rep";
        case "dd":
          return numberNoun + " jaj";
        case "MM":
          return numberNoun + " jar";
        case "yy":
          return numberNoun + " DIS";
      }
    }
    function numberAsNoun(number) {
      var hundred = Math.floor(number % 1e3 / 100), ten = Math.floor(number % 100 / 10), one2 = number % 10, word = "";
      if (hundred > 0) {
        word += numbersNouns[hundred] + "vatlh";
      }
      if (ten > 0) {
        word += (word !== "" ? " " : "") + numbersNouns[ten] + "maH";
      }
      if (one2 > 0) {
        word += (word !== "" ? " " : "") + numbersNouns[one2];
      }
      return word === "" ? "pagh" : word;
    }
    hooks2.defineLocale("tlh", {
      months: "tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha".split(
        "_"
      ),
      monthsShort: "jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split(
        "_"
      ),
      weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
      weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[DaHjaj] LT",
        nextDay: "[waleS] LT",
        nextWeek: "LLL",
        lastDay: "[waHu] LT",
        lastWeek: "LLL",
        sameElse: "L"
      },
      relativeTime: {
        future: translateFuture,
        past: translatePast,
        s: "puS lup",
        ss: translate$a,
        m: "wa tup",
        mm: translate$a,
        h: "wa rep",
        hh: translate$a,
        d: "wa jaj",
        dd: translate$a,
        M: "wa jar",
        MM: translate$a,
        y: "wa DIS",
        yy: translate$a
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var suffixes$5 = {
      1: "'inci",
      5: "'inci",
      8: "'inci",
      70: "'inci",
      80: "'inci",
      2: "'nci",
      7: "'nci",
      20: "'nci",
      50: "'nci",
      3: "'nc",
      4: "'nc",
      100: "'nc",
      6: "'nc",
      9: "'uncu",
      10: "'uncu",
      30: "'uncu",
      60: "'nc",
      90: "'nc"
    };
    hooks2.defineLocale("tr", {
      months: "Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk".split(
        "_"
      ),
      monthsShort: "Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara".split("_"),
      weekdays: "Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi".split(
        "_"
      ),
      weekdaysShort: "Paz_Pzt_Sal_ar_Per_Cum_Cmt".split("_"),
      weekdaysMin: "Pz_Pt_Sa_a_Pe_Cu_Ct".split("_"),
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 12) {
          return isLower ? "" : "";
        } else {
          return isLower ? "s" : "S";
        }
      },
      meridiemParse: /||s|S/,
      isPM: function(input) {
        return input === "s" || input === "S";
      },
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[bugn saat] LT",
        nextDay: "[yarn saat] LT",
        nextWeek: "[gelecek] dddd [saat] LT",
        lastDay: "[dn] LT",
        lastWeek: "[geen] dddd [saat] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s sonra",
        past: "%s nce",
        s: "birka saniye",
        ss: "%d saniye",
        m: "bir dakika",
        mm: "%d dakika",
        h: "bir saat",
        hh: "%d saat",
        d: "bir gn",
        dd: "%d gn",
        w: "bir hafta",
        ww: "%d hafta",
        M: "bir ay",
        MM: "%d ay",
        y: "bir yl",
        yy: "%d yl"
      },
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "Do":
          case "DD":
            return number;
          default:
            if (number === 0) {
              return number + "'nc";
            }
            var a = number % 10, b = number % 100 - a, c = number >= 100 ? 100 : null;
            return number + (suffixes$5[a] || suffixes$5[b] || suffixes$5[c]);
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("tzl", {
      months: "Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar".split(
        "_"
      ),
      monthsShort: "Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
      weekdays: "Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi".split("_"),
      weekdaysShort: "Sl_Ln_Mai_Mr_Xh_Vi_St".split("_"),
      weekdaysMin: "S_L_Ma_M_Xh_Vi_S".split("_"),
      longDateFormat: {
        LT: "HH.mm",
        LTS: "HH.mm.ss",
        L: "DD.MM.YYYY",
        LL: "D. MMMM [dallas] YYYY",
        LLL: "D. MMMM [dallas] YYYY HH.mm",
        LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
      },
      meridiemParse: /d\'o|d\'a/i,
      isPM: function(input) {
        return "d'o" === input.toLowerCase();
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 > 11) {
          return isLower ? "d'o" : "D'O";
        } else {
          return isLower ? "d'a" : "D'A";
        }
      },
      calendar: {
        sameDay: "[oxhi ] LT",
        nextDay: "[dem ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ieiri ] LT",
        lastWeek: "[sr el] dddd [lasteu ] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "osprei %s",
        past: "ja%s",
        s: processRelativeTime$a,
        ss: processRelativeTime$a,
        m: processRelativeTime$a,
        mm: processRelativeTime$a,
        h: processRelativeTime$a,
        hh: processRelativeTime$a,
        d: processRelativeTime$a,
        dd: processRelativeTime$a,
        M: processRelativeTime$a,
        MM: processRelativeTime$a,
        y: processRelativeTime$a,
        yy: processRelativeTime$a
      },
      dayOfMonthOrdinalParse: /\d{1,2}\./,
      ordinal: "%d.",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    function processRelativeTime$a(number, withoutSuffix, key, isFuture) {
      var format2 = {
        s: ["viensas secunds", "'iensas secunds"],
        ss: [number + " secunds", "" + number + " secunds"],
        m: ["'n mut", "'iens mut"],
        mm: [number + " muts", "" + number + " muts"],
        h: ["'n ora", "'iensa ora"],
        hh: [number + " oras", "" + number + " oras"],
        d: ["'n ziua", "'iensa ziua"],
        dd: [number + " ziuas", "" + number + " ziuas"],
        M: ["'n mes", "'iens mes"],
        MM: [number + " mesen", "" + number + " mesen"],
        y: ["'n ar", "'iens ar"],
        yy: [number + " ars", "" + number + " ars"]
      };
      return isFuture ? format2[key][0] : withoutSuffix ? format2[key][0] : format2[key][1];
    }
    //! moment.js locale configuration
    hooks2.defineLocale("tzm-latn", {
      months: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split(
        "_"
      ),
      monthsShort: "innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir".split(
        "_"
      ),
      weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
      weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
      weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiyas".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[asdkh g] LT",
        nextDay: "[aska g] LT",
        nextWeek: "dddd [g] LT",
        lastDay: "[assant g] LT",
        lastWeek: "dddd [g] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "dadkh s yan %s",
        past: "yan %s",
        s: "imik",
        ss: "%d imik",
        m: "minu",
        mm: "%d minu",
        h: "saa",
        hh: "%d tassain",
        d: "ass",
        dd: "%d ossan",
        M: "ayowr",
        MM: "%d iyyirn",
        y: "asgas",
        yy: "%d isgasn"
      },
      week: {
        dow: 6,
        // Saturday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("tzm", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[ ] LT",
        lastWeek: "dddd [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "   %s",
        past: " %s",
        s: "",
        ss: "%d ",
        m: "",
        mm: "%d ",
        h: "",
        hh: "%d ",
        d: "",
        dd: "%d o",
        M: "o",
        MM: "%d ",
        y: "",
        yy: "%d "
      },
      week: {
        dow: 6,
        // Saturday is the first day of the week.
        doy: 12
        // The week that contains Jan 12th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("ug-cn", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: "______".split(
        "_"
      ),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY-MM-DD",
        LL: "YYYY-M-D-",
        LLL: "YYYY-M-D- HH:mm",
        LLLL: "dddd YYYY-M-D- HH:mm"
      },
      meridiemParse: / || || |/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === " " || meridiem2 === "" || meridiem2 === " ") {
          return hour;
        } else if (meridiem2 === " " || meridiem2 === "") {
          return hour + 12;
        } else {
          return hour >= 11 ? hour : hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
          return " ";
        } else if (hm < 900) {
          return "";
        } else if (hm < 1130) {
          return " ";
        } else if (hm < 1230) {
          return "";
        } else if (hm < 1800) {
          return " ";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "[] dddd [] LT",
        lastDay: "[] LT",
        lastWeek: "[] dddd [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "DDD":
            return number + "-";
          case "w":
          case "W":
            return number + "-";
          default:
            return number;
        }
      },
      preparse: function(string) {
        return string.replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/,/g, "");
      },
      week: {
        // GB/T 7408-1994ISO 8601:1988
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 1st is the first week of the year.
      }
    });
    //! moment.js locale configuration
    function plural$6(word, num) {
      var forms2 = word.split("_");
      return num % 10 === 1 && num % 100 !== 11 ? forms2[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms2[1] : forms2[2];
    }
    function relativeTimeWithPlural$4(number, withoutSuffix, key) {
      var format2 = {
        ss: withoutSuffix ? "__" : "__",
        mm: withoutSuffix ? "__" : "__",
        hh: withoutSuffix ? "__" : "__",
        dd: "__",
        MM: "__",
        yy: "__"
      };
      if (key === "m") {
        return withoutSuffix ? "" : "";
      } else if (key === "h") {
        return withoutSuffix ? "" : "";
      } else {
        return number + " " + plural$6(format2[key], +number);
      }
    }
    function weekdaysCaseReplace(m, format2) {
      var weekdays2 = {
        nominative: "______".split(
          "_"
        ),
        accusative: "______".split(
          "_"
        ),
        genitive: "______".split(
          "_"
        )
      }, nounCase;
      if (m === true) {
        return weekdays2["nominative"].slice(1, 7).concat(weekdays2["nominative"].slice(0, 1));
      }
      if (!m) {
        return weekdays2["nominative"];
      }
      nounCase = /(\[[]\]) ?dddd/.test(format2) ? "accusative" : /\[?(?:|)? ?\] ?dddd/.test(format2) ? "genitive" : "nominative";
      return weekdays2[nounCase][m.day()];
    }
    function processHoursFunction(str) {
      return function() {
        return str + "" + (this.hours() === 11 ? "" : "") + "] LT";
      };
    }
    hooks2.defineLocale("uk", {
      months: {
        format: "___________".split(
          "_"
        ),
        standalone: "___________".split(
          "_"
        )
      },
      monthsShort: "___________".split(
        "_"
      ),
      weekdays: weekdaysCaseReplace,
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD.MM.YYYY",
        LL: "D MMMM YYYY .",
        LLL: "D MMMM YYYY ., HH:mm",
        LLLL: "dddd, D MMMM YYYY ., HH:mm"
      },
      calendar: {
        sameDay: processHoursFunction("[ "),
        nextDay: processHoursFunction("[ "),
        lastDay: processHoursFunction("[ "),
        nextWeek: processHoursFunction("[] dddd ["),
        lastWeek: function() {
          switch (this.day()) {
            case 0:
            case 3:
            case 5:
            case 6:
              return processHoursFunction("[] dddd [").call(this);
            case 1:
            case 2:
            case 4:
              return processHoursFunction("[] dddd [").call(this);
          }
        },
        sameElse: "L"
      },
      relativeTime: {
        future: " %s",
        past: "%s ",
        s: " ",
        ss: relativeTimeWithPlural$4,
        m: relativeTimeWithPlural$4,
        mm: relativeTimeWithPlural$4,
        h: "",
        hh: relativeTimeWithPlural$4,
        d: "",
        dd: relativeTimeWithPlural$4,
        M: "",
        MM: relativeTimeWithPlural$4,
        y: "",
        yy: relativeTimeWithPlural$4
      },
      // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
      meridiemParse: /|||/,
      isPM: function(input) {
        return /^(|)$/.test(input);
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 4) {
          return "";
        } else if (hour < 12) {
          return "";
        } else if (hour < 17) {
          return "";
        } else {
          return "";
        }
      },
      dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
      ordinal: function(number, period) {
        switch (period) {
          case "M":
          case "d":
          case "DDD":
          case "w":
          case "W":
            return number + "-";
          case "D":
            return number + "-";
          default:
            return number;
        }
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    var months$b = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ], days$2 = ["", "", "", "", "", "", ""];
    hooks2.defineLocale("ur", {
      months: months$b,
      monthsShort: months$b,
      weekdays: days$2,
      weekdaysShort: days$2,
      weekdaysMin: days$2,
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd D MMMM YYYY HH:mm"
      },
      meridiemParse: /|/,
      isPM: function(input) {
        return "" === input;
      },
      meridiem: function(hour, minute, isLower) {
        if (hour < 12) {
          return "";
        }
        return "";
      },
      calendar: {
        sameDay: "[ ] LT",
        nextDay: "[ ] LT",
        nextWeek: "dddd [] LT",
        lastDay: "[  ] LT",
        lastWeek: "[] dddd [] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ",
        past: "%s ",
        s: " ",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      preparse: function(string) {
        return string.replace(//g, ",");
      },
      postformat: function(string) {
        return string.replace(/,/g, "");
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("uz-latn", {
      months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split(
        "_"
      ),
      monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
      weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split(
        "_"
      ),
      weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
      weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "D MMMM YYYY, dddd HH:mm"
      },
      calendar: {
        sameDay: "[Bugun soat] LT [da]",
        nextDay: "[Ertaga] LT [da]",
        nextWeek: "dddd [kuni soat] LT [da]",
        lastDay: "[Kecha soat] LT [da]",
        lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
        sameElse: "L"
      },
      relativeTime: {
        future: "Yaqin %s ichida",
        past: "Bir necha %s oldin",
        s: "soniya",
        ss: "%d soniya",
        m: "bir daqiqa",
        mm: "%d daqiqa",
        h: "bir soat",
        hh: "%d soat",
        d: "bir kun",
        dd: "%d kun",
        M: "bir oy",
        MM: "%d oy",
        y: "bir yil",
        yy: "%d yil"
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 7th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("uz", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "___________".split("_"),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "D MMMM YYYY, dddd HH:mm"
      },
      calendar: {
        sameDay: "[ ] LT []",
        nextDay: "[] LT []",
        nextWeek: "dddd [ ] LT []",
        lastDay: "[ ] LT []",
        lastWeek: "[] dddd [ ] LT []",
        sameElse: "L"
      },
      relativeTime: {
        future: " %s ",
        past: "  %s ",
        s: "",
        ss: "%d ",
        m: " ",
        mm: "%d ",
        h: " ",
        hh: "%d ",
        d: " ",
        dd: "%d ",
        M: " ",
        MM: "%d ",
        y: " ",
        yy: "%d "
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 7
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("vi", {
      months: "thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12".split(
        "_"
      ),
      monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "ch nht_th hai_th ba_th t_th nm_th su_th by".split(
        "_"
      ),
      weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
      weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
      weekdaysParseExact: true,
      meridiemParse: /sa|ch/i,
      isPM: function(input) {
        return /^ch$/i.test(input);
      },
      meridiem: function(hours2, minutes2, isLower) {
        if (hours2 < 12) {
          return isLower ? "sa" : "SA";
        } else {
          return isLower ? "ch" : "CH";
        }
      },
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "D MMMM [nm] YYYY",
        LLL: "D MMMM [nm] YYYY HH:mm",
        LLLL: "dddd, D MMMM [nm] YYYY HH:mm",
        l: "DD/M/YYYY",
        ll: "D MMM YYYY",
        lll: "D MMM YYYY HH:mm",
        llll: "ddd, D MMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[Hm nay lc] LT",
        nextDay: "[Ngy mai lc] LT",
        nextWeek: "dddd [tun ti lc] LT",
        lastDay: "[Hm qua lc] LT",
        lastWeek: "dddd [tun trc lc] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "%s ti",
        past: "%s trc",
        s: "vi giy",
        ss: "%d giy",
        m: "mt pht",
        mm: "%d pht",
        h: "mt gi",
        hh: "%d gi",
        d: "mt ngy",
        dd: "%d ngy",
        w: "mt tun",
        ww: "%d tun",
        M: "mt thng",
        MM: "%d thng",
        y: "mt nm",
        yy: "%d nm"
      },
      dayOfMonthOrdinalParse: /\d{1,2}/,
      ordinal: function(number) {
        return number;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("x-pseudo", {
      months: "J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr".split(
        "_"
      ),
      monthsShort: "J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc".split(
        "_"
      ),
      monthsParseExact: true,
      weekdays: "S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d".split(
        "_"
      ),
      weekdaysShort: "S~_~M_~T_~Wd_~Th_~Fr_~St".split("_"),
      weekdaysMin: "S~_M~_T_~W_T~h_Fr~_S".split("_"),
      weekdaysParseExact: true,
      longDateFormat: {
        LT: "HH:mm",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY HH:mm",
        LLLL: "dddd, D MMMM YYYY HH:mm"
      },
      calendar: {
        sameDay: "[T~d~ t] LT",
        nextDay: "[T~m~rr~w t] LT",
        nextWeek: "dddd [t] LT",
        lastDay: "[~st~rd~ t] LT",
        lastWeek: "[L~st] dddd [t] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "~ %s",
        past: "%s ~g",
        s: " ~fw ~sc~ds",
        ss: "%d s~c~ds",
        m: " ~m~t",
        mm: "%d m~~ts",
        h: "~ h~r",
        hh: "%d h~rs",
        d: " ~d",
        dd: "%d d~s",
        M: " ~m~th",
        MM: "%d m~t~hs",
        y: " ~r",
        yy: "%d ~rs"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
      ordinal: function(number) {
        var b = number % 10, output = ~~(number % 100 / 10) === 1 ? "th" : b === 1 ? "st" : b === 2 ? "nd" : b === 3 ? "rd" : "th";
        return number + output;
      },
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("yo", {
      months: "Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p".split(
        "_"
      ),
      monthsShort: "Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p".split("_"),
      weekdays: "Aiku_Aje_Isgun_jru_jb_ti_Abamta".split("_"),
      weekdaysShort: "Aik_Aje_Is_jr_jb_ti_Aba".split("_"),
      weekdaysMin: "Ai_Aj_Is_r_b_t_Ab".split("_"),
      longDateFormat: {
        LT: "h:mm A",
        LTS: "h:mm:ss A",
        L: "DD/MM/YYYY",
        LL: "D MMMM YYYY",
        LLL: "D MMMM YYYY h:mm A",
        LLLL: "dddd, D MMMM YYYY h:mm A"
      },
      calendar: {
        sameDay: "[Oni ni] LT",
        nextDay: "[la ni] LT",
        nextWeek: "dddd [s ton'b] [ni] LT",
        lastDay: "[Ana ni] LT",
        lastWeek: "dddd [s tol] [ni] LT",
        sameElse: "L"
      },
      relativeTime: {
        future: "ni %s",
        past: "%s kja",
        s: "isju aaya die",
        ss: "aaya %d",
        m: "isju kan",
        mm: "isju %d",
        h: "wakati kan",
        hh: "wakati %d",
        d: "j kan",
        dd: "j %d",
        M: "osu kan",
        MM: "osu %d",
        y: "dun kan",
        yy: "dun %d"
      },
      dayOfMonthOrdinalParse: /j\s\d{1,2}/,
      ordinal: "j %d",
      week: {
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("zh-cn", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY/MM/DD",
        LL: "YYYYMD",
        LLL: "YYYYMDAhmm",
        LLLL: "YYYYMDddddAhmm",
        l: "YYYY/M/D",
        ll: "YYYYMD",
        lll: "YYYYMD HH:mm",
        llll: "YYYYMDdddd HH:mm"
      },
      meridiemParse: /|||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" || meridiem2 === "" || meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "" || meridiem2 === "") {
          return hour + 12;
        } else {
          return hour >= 11 ? hour : hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
          return "";
        } else if (hm < 900) {
          return "";
        } else if (hm < 1130) {
          return "";
        } else if (hm < 1230) {
          return "";
        } else if (hm < 1800) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[]LT",
        nextDay: "[]LT",
        nextWeek: function(now3) {
          if (now3.week() !== this.week()) {
            return "[]dddLT";
          } else {
            return "[]dddLT";
          }
        },
        lastDay: "[]LT",
        lastWeek: function(now3) {
          if (this.week() !== now3.week()) {
            return "[]dddLT";
          } else {
            return "[]dddLT";
          }
        },
        sameElse: "L"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "DDD":
            return number + "";
          case "M":
            return number + "";
          case "w":
          case "W":
            return number + "";
          default:
            return number;
        }
      },
      relativeTime: {
        future: "%s",
        past: "%s",
        s: "",
        ss: "%d ",
        m: "1 ",
        mm: "%d ",
        h: "1 ",
        hh: "%d ",
        d: "1 ",
        dd: "%d ",
        w: "1 ",
        ww: "%d ",
        M: "1 ",
        MM: "%d ",
        y: "1 ",
        yy: "%d "
      },
      week: {
        // GB/T 7408-1994ISO 8601:1988
        dow: 1,
        // Monday is the first day of the week.
        doy: 4
        // The week that contains Jan 4th is the first week of the year.
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("zh-hk", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY/MM/DD",
        LL: "YYYYMD",
        LLL: "YYYYMD HH:mm",
        LLLL: "YYYYMDdddd HH:mm",
        l: "YYYY/M/D",
        ll: "YYYYMD",
        lll: "YYYYMD HH:mm",
        llll: "YYYYMDdddd HH:mm"
      },
      meridiemParse: /|||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" || meridiem2 === "" || meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "" || meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
          return "";
        } else if (hm < 900) {
          return "";
        } else if (hm < 1200) {
          return "";
        } else if (hm === 1200) {
          return "";
        } else if (hm < 1800) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[]LT",
        nextDay: "[]LT",
        nextWeek: "[]ddddLT",
        lastDay: "[]LT",
        lastWeek: "[]ddddLT",
        sameElse: "L"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "DDD":
            return number + "";
          case "M":
            return number + "";
          case "w":
          case "W":
            return number + "";
          default:
            return number;
        }
      },
      relativeTime: {
        future: "%s",
        past: "%s",
        s: "",
        ss: "%d ",
        m: "1 ",
        mm: "%d ",
        h: "1 ",
        hh: "%d ",
        d: "1 ",
        dd: "%d ",
        M: "1 ",
        MM: "%d ",
        y: "1 ",
        yy: "%d "
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("zh-mo", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "DD/MM/YYYY",
        LL: "YYYYMD",
        LLL: "YYYYMD HH:mm",
        LLLL: "YYYYMDdddd HH:mm",
        l: "D/M/YYYY",
        ll: "YYYYMD",
        lll: "YYYYMD HH:mm",
        llll: "YYYYMDdddd HH:mm"
      },
      meridiemParse: /|||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" || meridiem2 === "" || meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "" || meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
          return "";
        } else if (hm < 900) {
          return "";
        } else if (hm < 1130) {
          return "";
        } else if (hm < 1230) {
          return "";
        } else if (hm < 1800) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[]dddd LT",
        lastDay: "[] LT",
        lastWeek: "[]dddd LT",
        sameElse: "L"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "DDD":
            return number + "";
          case "M":
            return number + "";
          case "w":
          case "W":
            return number + "";
          default:
            return number;
        }
      },
      relativeTime: {
        future: "%s",
        past: "%s",
        s: "",
        ss: "%d ",
        m: "1 ",
        mm: "%d ",
        h: "1 ",
        hh: "%d ",
        d: "1 ",
        dd: "%d ",
        M: "1 ",
        MM: "%d ",
        y: "1 ",
        yy: "%d "
      }
    });
    //! moment.js locale configuration
    hooks2.defineLocale("zh-tw", {
      months: "___________".split(
        "_"
      ),
      monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split(
        "_"
      ),
      weekdays: "______".split("_"),
      weekdaysShort: "______".split("_"),
      weekdaysMin: "______".split("_"),
      longDateFormat: {
        LT: "HH:mm",
        LTS: "HH:mm:ss",
        L: "YYYY/MM/DD",
        LL: "YYYYMD",
        LLL: "YYYYMD HH:mm",
        LLLL: "YYYYMDdddd HH:mm",
        l: "YYYY/M/D",
        ll: "YYYYMD",
        lll: "YYYYMD HH:mm",
        llll: "YYYYMDdddd HH:mm"
      },
      meridiemParse: /|||||/,
      meridiemHour: function(hour, meridiem2) {
        if (hour === 12) {
          hour = 0;
        }
        if (meridiem2 === "" || meridiem2 === "" || meridiem2 === "") {
          return hour;
        } else if (meridiem2 === "") {
          return hour >= 11 ? hour : hour + 12;
        } else if (meridiem2 === "" || meridiem2 === "") {
          return hour + 12;
        }
      },
      meridiem: function(hour, minute, isLower) {
        var hm = hour * 100 + minute;
        if (hm < 600) {
          return "";
        } else if (hm < 900) {
          return "";
        } else if (hm < 1130) {
          return "";
        } else if (hm < 1230) {
          return "";
        } else if (hm < 1800) {
          return "";
        } else {
          return "";
        }
      },
      calendar: {
        sameDay: "[] LT",
        nextDay: "[] LT",
        nextWeek: "[]dddd LT",
        lastDay: "[] LT",
        lastWeek: "[]dddd LT",
        sameElse: "L"
      },
      dayOfMonthOrdinalParse: /\d{1,2}(||)/,
      ordinal: function(number, period) {
        switch (period) {
          case "d":
          case "D":
          case "DDD":
            return number + "";
          case "M":
            return number + "";
          case "w":
          case "W":
            return number + "";
          default:
            return number;
        }
      },
      relativeTime: {
        future: "%s",
        past: "%s",
        s: "",
        ss: "%d ",
        m: "1 ",
        mm: "%d ",
        h: "1 ",
        hh: "%d ",
        d: "1 ",
        dd: "%d ",
        M: "1 ",
        MM: "%d ",
        y: "1 ",
        yy: "%d "
      }
    });
    hooks2.locale("en");
    return hooks2;
  });
})(momentWithLocales);
var momentWithLocalesExports = momentWithLocales.exports;
const moment = /* @__PURE__ */ getDefaultExportFromCjs(momentWithLocalesExports);
var dist = {};
Object.defineProperty(dist, "__esModule", {
  value: true
});
dist.linkTo = dist.imagePath = dist.getRootUrl = dist.generateUrl = dist.generateRemoteUrl = dist.generateOcsUrl = dist.generateFilePath = void 0;
const linkTo = (app, file) => generateFilePath(app, "", file);
dist.linkTo = linkTo;
const linkToRemoteBase = (service) => getRootUrl() + "/remote.php/" + service;
const generateRemoteUrl = (service) => window.location.protocol + "//" + window.location.host + linkToRemoteBase(service);
dist.generateRemoteUrl = generateRemoteUrl;
const generateOcsUrl = (url, params, options) => {
  const allOptions = Object.assign({
    ocsVersion: 2
  }, options || {});
  const version2 = allOptions.ocsVersion === 1 ? 1 : 2;
  return window.location.protocol + "//" + window.location.host + getRootUrl() + "/ocs/v" + version2 + ".php" + _generateUrlPath(url, params, options);
};
dist.generateOcsUrl = generateOcsUrl;
const _generateUrlPath = (url, params, options) => {
  const allOptions = Object.assign({
    escape: true
  }, options || {});
  const _build = function(text, vars) {
    vars = vars || {};
    return text.replace(/{([^{}]*)}/g, function(a, b) {
      var r = vars[b];
      if (allOptions.escape) {
        return typeof r === "string" || typeof r === "number" ? encodeURIComponent(r.toString()) : encodeURIComponent(a);
      } else {
        return typeof r === "string" || typeof r === "number" ? r.toString() : a;
      }
    });
  };
  if (url.charAt(0) !== "/") {
    url = "/" + url;
  }
  return _build(url, params || {});
};
const generateUrl = (url, params, options) => {
  const allOptions = Object.assign({
    noRewrite: false
  }, options || {});
  if (window?.OC?.config?.modRewriteWorking === true && !allOptions.noRewrite) {
    return getRootUrl() + _generateUrlPath(url, params, options);
  }
  return getRootUrl() + "/index.php" + _generateUrlPath(url, params, options);
};
dist.generateUrl = generateUrl;
const imagePath = (app, file) => {
  if (file.indexOf(".") === -1) {
    return generateFilePath(app, "img", file + ".svg");
  }
  return generateFilePath(app, "img", file);
};
dist.imagePath = imagePath;
const generateFilePath = (app, type, file) => {
  const isCore = window?.OC?.coreApps?.indexOf(app) !== -1;
  let link2 = getRootUrl();
  if (file.substring(file.length - 3) === "php" && !isCore) {
    link2 += "/index.php/apps/" + app;
    if (file !== "index.php") {
      link2 += "/";
      if (type) {
        link2 += encodeURI(type + "/");
      }
      link2 += file;
    }
  } else if (file.substring(file.length - 3) !== "php" && !isCore) {
    link2 = window?.OC?.appswebroots?.[app];
    if (type) {
      link2 += "/" + type + "/";
    }
    if (link2.substring(link2.length - 1) !== "/") {
      link2 += "/";
    }
    link2 += file;
  } else {
    if ((app === "settings" || app === "core" || app === "search") && type === "ajax") {
      link2 += "/index.php/";
    } else {
      link2 += "/";
    }
    if (!isCore) {
      link2 += "apps/";
    }
    if (app !== "") {
      app += "/";
      link2 += app;
    }
    if (type) {
      link2 += type + "/";
    }
    link2 += file;
  }
  return link2;
};
dist.generateFilePath = generateFilePath;
const getRootUrl = () => window?.OC?.webroot || "";
dist.getRootUrl = getRootUrl;
function getLocale() {
  return document.documentElement.dataset.locale || "en";
}
const s = getLocale(), e = { ar: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, ast: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundos"] } } } }, az: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["saniy"] } } } }, br: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["eilenno"] } } } }, ca: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segons"] } } } }, cs_CZ: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekund(y)"] } } } }, da: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekunder"] } } } }, de: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["Sekunden"] } } } }, de_DE: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["Sekunden"] } } } }, el: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, en_GB: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["seconds"] } } } }, eo: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekundoj"] } } } }, es: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundos"] } } } }, es_AR: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundos"] } } } }, es_MX: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundos"] } } } }, et_EE: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekundid"] } } } }, eu: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundo"] } } } }, fa: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, fi_FI: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekuntia"] } } } }, fr: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["secondes"] } } } }, gl: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundos"] } } } }, he: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, hu_HU: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["msodperc"] } } } }, id: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["detik"] } } } }, is: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekndur"] } } } }, it: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["secondi"] } } } }, ja_JP: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, kab: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["tasinin"] } } } }, ko: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, lo: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, lt_LT: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sek."] } } } }, lv: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekundes"] } } } }, mk: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, mn: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, my: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, nb_NO: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekunder"] } } } }, nl: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["seconden"] } } } }, oc: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segondas"] } } } }, pl: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekundy"] } } } }, pt_BR: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundos"] } } } }, pt_PT: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["segundos"] } } } }, ro: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["secunde"] } } } }, ru: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, si: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, sk_SK: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekundy"] } } } }, sl: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekunde"] } } } }, sq: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekonda"] } } } }, sr: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, sv: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["sekunder"] } } } }, th_TH: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, tr: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["saniye"] } } } }, uk: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, vi: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: ["giy"] } } } }, zh_CN: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, zh_HK: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } }, zh_TW: { charset: "utf-8", translations: { "": { seconds: { msgid: "seconds", msgstr: [""] } } } } };
moment.locale(s);
if (s === "en" || s in e) {
  const t2 = new o();
  t2.addTranslations(s, "messages", e[s]), t2.setLocale(s), moment.updateLocale(moment.locale(), {
    relativeTime: {
      s: t2.gettext("seconds")
    }
  });
}
const _sfc_main$u = {
  name: "PropertyRev",
  props: {
    value: {
      type: Object,
      required: true
    }
  },
  computed: {
    relativeDate() {
      return moment.unix(this.value.toUnixTime()).fromNow();
    }
  }
};
var _sfc_render$u = function render51() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "property property--rev" }, [_c("div", { staticClass: "property__row" }, [_c("div", { staticClass: "property__label" }), _c("div", { staticClass: "property__value" }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Last modified")) + " " + _vm._s(_vm.relativeDate) + " ")]), _c("div", { staticClass: "property__actions" })])]);
};
var _sfc_staticRenderFns$u = [];
var __component__$u = /* @__PURE__ */ normalizeComponent(
  _sfc_main$u,
  _sfc_render$u,
  _sfc_staticRenderFns$u,
  false,
  null,
  "cdb3abf5"
);
const PropertyRev = __component__$u.exports;
const isTalkEnabled = loadState("contacts", "isTalkEnabled", false);
const { profileEnabled } = loadState("user_status", "profileEnabled", false);
const _sfc_main$t = {
  name: "ContactDetails",
  components: {
    Actions: NcActions,
    ActionButton: NcActionButton,
    ActionLink: NcActionLink,
    AddNewProp,
    AppContentDetails: NcAppContentDetails,
    ContactAvatar,
    ContactDetailsProperty,
    DetailsHeader,
    EmptyContent: NcEmptyContent,
    IconContact,
    IconMail: IconEmail,
    IconMessage,
    IconCall,
    IconAccount: IconUser,
    IconDownload,
    IconDelete,
    IconQr,
    CakeIcon,
    IconCopy: IconCopy$1,
    IconLoading: NcLoadingIcon,
    PencilIcon: IconRename$1,
    CheckIcon,
    Modal: NcModal,
    NcSelect,
    PropertyGroups,
    PropertyRev,
    PropertySelect,
    NcButton,
    NcRelatedResourcesPanel,
    NcEmptyContent,
    FolderMultipleImage
  },
  mixins: [index],
  props: {
    contactKey: {
      type: String,
      default: void 0
    },
    contacts: {
      type: Array,
      default: () => []
    },
    reloadBus: {
      type: Object,
      required: true
    },
    desc: {
      type: String,
      required: false,
      default: ""
    }
  },
  data() {
    return {
      // if true, the local contact have been fixed and requires a push
      fixed: false,
      /**
       * Local off-store clone of the selected contact for edition
       * because we can't edit contacts data outside the store.
       * Every change will be dispatched and updated on the real
       * store contact after a debounce.
       */
      localContact: void 0,
      loadingData: true,
      loadingUpdate: false,
      qrcode: "",
      showPickAddressbookModal: false,
      pickedAddressbook: null,
      editMode: false,
      newGroupsValue: [],
      contactDetailsSelector: ".contact-details",
      excludeFromBirthdayKey: "x-nc-exclude-from-birthday-calendar",
      // communication for ContactDetailsAddNewProp and ContactDetailsProperty
      bus: mitt(),
      showMenuPopover: false,
      profileEnabled,
      isTalkEnabled,
      hasFilesResources: false,
      hasTalkResources: false,
      hasCalendarResources: false,
      hasDeckResources: false,
      deckPanelHasError: false,
      filesPanelHasError: false,
      talkPanelHasError: false,
      calendarPanelHasError: false
    };
  },
  computed: {
    hasRelatedResources() {
      return this.hasFilesResources || this.hasTalkResources || this.hasCalendarResources || this.hasDeckResources;
    },
    /**
     * The address book is read-only (e.g. shared with me).
     *
     * @return {boolean}
     */
    addressbookIsReadOnly() {
      return this.contact.addressbook?.readOnly;
    },
    /**
     * The address book is read-only or the contact is in read-only mode.
     *
     * @return {boolean}
     */
    isReadOnly() {
      return this.addressbookIsReadOnly || !this.editMode;
    },
    /**
     * Warning messages
     *
     * @return {object | boolean}
     */
    warning() {
      if (this.addressbookIsReadOnly) {
        return {
          icon: EyeCircleIcon,
          classes: [],
          msg: t("contacts", "This contact is in read-only mode. You do not have permission to edit this contact.")
        };
      }
      return false;
    },
    /**
     * Conflict message
     *
     * @return {string|boolean}
     */
    conflict() {
      if (this.contact.conflict) {
        return t("contacts", "The contact you were trying to edit has changed. Please manually refresh the contact. Any further edits will be discarded.");
      }
      return false;
    },
    /**
     * Contact properties copied and sorted by rfcProps.fieldOrder
     *
     * @return {Array}
     */
    sortedProperties() {
      return this.localContact.properties.slice(0).sort((a, b) => {
        const nameA = a.name.split(".").pop();
        const nameB = b.name.split(".").pop();
        return rfcProps.fieldOrder.indexOf(nameA) - rfcProps.fieldOrder.indexOf(nameB);
      });
    },
    /**
     * Contact properties filtered and grouped by rfcProps.fieldOrder
     *
     * @return {object}
     */
    groupedProperties() {
      return this.sortedProperties.reduce((list, property) => {
        if (property.name === "x-socialprofile" || property.name === "cloud") {
          return list;
        }
        if (!this.canDisplay(property)) {
          return list;
        }
        if (!list[property.name]) {
          list[property.name] = [];
        }
        list[property.name].push(property);
        return list;
      }, {});
    },
    /**
     * Fake model to use the propertySelect component
     *
     * @return {object}
     */
    addressbookModel() {
      return {
        readableName: t("contacts", "Address book"),
        icon: "icon-address-book",
        options: this.addressbooksOptions
      };
    },
    /**
     * Usable addressbook object linked to the local contact
     *
     * @param {string} [addressbookId] set the addressbook id
     * @return {string}
     */
    addressbook: {
      get() {
        return this.contact.addressbook.id;
      },
      set(addressbookId) {
        if (this.contact.addressbook.id !== addressbookId) {
          this.moveContactToAddressbook(addressbookId);
        }
      }
    },
    /**
     * Fake model to use the propertyGroups component
     *
     * @return {object}
     */
    groupsModel() {
      return {
        readableName: t("contacts", "Contact groups"),
        icon: "icon-contacts-dark"
      };
    },
    /**
     * Store getters filtered and mapped to usable object
     * This is the list of addressbooks that are available
     *
     * @return {{id: string, name: string, readOnly: boolean}[]}
     */
    addressbooksOptions() {
      return this.addressbooks.filter((addressbook) => addressbook.enabled).map((addressbook) => {
        return {
          id: addressbook.id,
          name: addressbook.displayName,
          readOnly: addressbook.readOnly
        };
      });
    },
    /**
     * Store getters filtered and mapped to usable object
     * This is the list of addressbooks that are available to copy to
     *
     * @return {{id: string, name: string}[]}
     */
    copyableAddressbooksOptions() {
      return this.addressbooksOptions.filter((option) => !option.readOnly).filter((option) => option.id !== this.contact.addressbook.id).map((addressbook) => {
        return {
          id: addressbook.id,
          name: addressbook.name
        };
      });
    },
    // store getter
    addressbooks() {
      return this.$store.getters.getAddressbooks;
    },
    contact() {
      return this.$store.getters.getContact(this.contactKey);
    },
    excludeFromBirthdayLabel() {
      return this.localContact.vCard.hasProperty(this.excludeFromBirthdayKey) ? t("contacts", "Add contact to Birthday Calendar") : t("contacts", "Exclude contact from Birthday Calendar");
    },
    enableToggleBirthdayExclusion() {
      return parseInt(window.OC.config.version.split(".")[0]) >= 26 && this.localContact?.vCard;
    },
    /**
     * Read-only representation of the contact title and organization.
     *
     * @return {string}
     */
    formattedSubtitle() {
      const title = this.contact.title;
      const organization = this.contact.org;
      if (title && organization) {
        return t("contacts", "{title} at {organization}", {
          title,
          organization
        });
      } else if (title) {
        return title;
      } else if (organization) {
        return organization;
      }
      return "";
    },
    profilePageLink() {
      return this.contact.socialLink("NEXTCLOUD");
    },
    emailAddressProperties() {
      return this.localContact.properties.find((property) => property.name === "email");
    },
    emailAddress() {
      return this.emailAddressProperties?.getFirstValue();
    },
    phoneNumberProperties() {
      return this.localContact.properties.find((property) => property.name === "tel");
    },
    phoneNumberList() {
      return this.groupedProperties?.tel?.map((prop) => prop.getFirstValue()).filter((tel) => !!tel);
    },
    emailAddressList() {
      return this.groupedProperties?.email?.map((prop) => prop.getFirstValue()).filter((address) => !!address);
    },
    callUrl() {
      return _("/apps/spreed/?callUser={uid}", { uid: this.contact.uid });
    },
    isInSystemAddressBook() {
      return this.contact.addressbook.id === "z-server-generated--system";
    },
    nextcloudVersionAtLeast28() {
      return parseInt(window.OC.config.version.split(".")[0]) >= 28;
    }
  },
  watch: {
    contact(newContact, oldContact) {
      if (this.contactKey && newContact !== oldContact) {
        this.selectContact(this.contactKey);
      }
    }
  },
  beforeMount() {
    if (this.contactKey) {
      this.selectContact(this.contactKey);
    }
    document.addEventListener("keydown", this.onCtrlSave);
  },
  beforeDestroy() {
    document.removeEventListener("keydown", this.onCtrlSave);
  },
  methods: {
    updateGroups(value) {
      this.newGroupsValue = value;
    },
    /**
     * Send the local clone of contact to the store
     */
    async updateContact() {
      this.fixed = false;
      this.loadingUpdate = true;
      try {
        await this.$store.dispatch("updateContact", this.localContact);
      } finally {
        this.loadingUpdate = false;
      }
      if (!this.localContact.dav) {
        this.logger.debug("New contact synced!", { localContact: this.localContact });
        const contact = this.$store.getters.getContact(this.localContact.key);
        await this.updateLocalContact(contact);
      }
    },
    /**
     * Generate a qrcode for the contact
     */
    async showQRcode() {
      const jCal = this.contact.jCal.slice(0);
      jCal[1] = jCal[1].filter((props) => props[0] !== "photo");
      const data = ICALmodule.stringify(jCal);
      if (data.length > 0) {
        const svgBytes = await getSVG(data);
        const svgString = new TextDecoder().decode(svgBytes);
        this.qrcode = btoa(svgString);
      }
    },
    async toggleBirthdayExclusionForContact() {
      if (!this.localContact.vCard.hasProperty(this.excludeFromBirthdayKey)) {
        this.localContact.vCard.addPropertyWithValue(this.excludeFromBirthdayKey, true);
      } else {
        this.localContact.vCard.removeProperty(this.excludeFromBirthdayKey);
      }
      await this.updateContact();
    },
    /**
     * Select the text in the input if it is still set to 'Name'
     */
    selectInput() {
      if (this.$refs.fullname && this.$refs.fullname.value === t("contacts", "Name")) {
        this.$refs.fullname.select();
      }
    },
    /**
     * Select a contact, and update the localContact
     * Fetch updated data if necessary
     * Scroll to the selected contact if exists
     *
     * @param {string} key the contact key
     */
    async selectContact(key) {
      this.loadingData = true;
      this.editMode = false;
      const contact = this.$store.getters.getContact(key);
      if (contact) {
        if (contact.dav) {
          try {
            await this.$store.dispatch("fetchFullContact", { contact });
            await this.updateLocalContact(contact);
          } catch (error) {
            if (error.name === "ParserError") {
              showError(t("contacts", "Syntax error. Cannot open the contact."));
            } else if (error?.status === 404) {
              showError(t("contacts", "The contact does not exist on the server anymore."));
            } else {
              showError(t("contacts", "Unable to retrieve the contact from the server, please check your network connection."));
            }
            console.error(error);
            this.$store.dispatch("deleteContact", { contact: this.contact, dav: false });
          }
        } else {
          await this.updateLocalContact(contact);
          this.editMode = true;
        }
      }
      this.loadingData = false;
    },
    /**
     * Dispatch contact deletion request
     */
    deleteContact() {
      this.$store.dispatch("deleteContact", { contact: this.contact });
    },
    /**
     * Move contact to the specified addressbook
     *
     * @param {string} addressbookId the desired addressbook ID
     */
    async moveContactToAddressbook(addressbookId) {
      const addressbook = this.addressbooks.find((search) => search.id === addressbookId);
      this.loadingUpdate = true;
      if (addressbook) {
        try {
          const contact = await this.$store.dispatch("moveContactToAddressbook", {
            // we need to use the store contact, not the local contact
            // using this.contact and not this.localContact
            contact: this.contact,
            addressbook
          });
          this.$router.push({
            name: "contact",
            params: {
              selectedGroup: this.$route.params.selectedGroup,
              selectedContact: contact.key
            }
          });
        } catch (error) {
          console.error(error);
          showError(t("contacts", "An error occurred while trying to move the contact"));
        } finally {
          this.loadingUpdate = false;
        }
      }
    },
    /**
     * Copy contact to the specified addressbook
     *
     * @param {string} addressbookId the desired addressbook ID
     */
    async copyContactToAddressbook(addressbookId) {
      const addressbook = this.addressbooks.find((search) => search.id === addressbookId);
      this.loadingUpdate = true;
      if (addressbook) {
        try {
          const contact = await this.$store.dispatch("copyContactToAddressbook", {
            // we need to use the store contact, not the local contact
            // using this.contact and not this.localContact
            contact: this.contact,
            addressbook
          });
          this.$router.push({
            name: "contact",
            params: {
              selectedGroup: this.$route.params.selectedGroup,
              selectedContact: contact.key
            }
          });
        } catch (error) {
          console.error(error);
          showError(t("contacts", "An error occurred while trying to copy the contact"));
        } finally {
          this.loadingUpdate = false;
        }
      }
    },
    /**
     * Refresh the data of a contact
     */
    refreshContact() {
      this.$store.dispatch("fetchFullContact", { contact: this.contact, etag: this.conflict }).then(() => {
        this.contact.conflict = false;
      });
    },
    // reset the current qrcode
    closeQrModal() {
      this.qrcode = "";
    },
    /**
     *  Update this.localContact and set this.fixed
     *
     * @param {Contact} contact the contact to clone
     */
    async updateLocalContact(contact) {
      const localContact = Object.assign(
        Object.create(Object.getPrototypeOf(contact)),
        contact
      );
      this.fixed = validate(localContact);
      this.localContact = localContact;
      this.newGroupsValue = [...this.localContact.groups];
    },
    onCtrlSave(e2) {
      if (!this.editMode) {
        return;
      }
      if (e2.keyCode === 83 && (navigator.platform.match("Mac") ? e2.metaKey : e2.ctrlKey)) {
        e2.preventDefault();
        this.onSave();
      }
    },
    /**
     * Clone the current contact to another addressbook
     */
    async cloneContact() {
      if (this.pickedAddressbook && this.addressbooks.find((addressbook) => addressbook.id === this.pickedAddressbook.id)) {
        this.logger.debug("Cloning contact to", { name: this.pickedAddressbook.name });
        await this.copyContactToAddressbook(this.pickedAddressbook.id);
        this.closePickAddressbookModal();
      } else if (this.addressbooksOptions.length === 1) {
        this.logger.debug("Cloning contact to", { name: this.addressbooksOptions[0].name });
        await this.copyContactToAddressbook(this.addressbooksOptions[0].id);
      } else {
        this.showPickAddressbookModal = true;
      }
    },
    closePickAddressbookModal() {
      this.showPickAddressbookModal = false;
      this.pickedAddressbook = null;
    },
    /**
     * Should display the property
     *
     * @param {Property} property the property to check
     * @return {boolean}
     */
    canDisplay(property) {
      const propModel = rfcProps.properties[property.name.split(".").pop()];
      const propType = propModel && propModel.force ? propModel.force : property.getDefaultType();
      return propModel && propType !== "unknown";
    },
    /**
     * Save the contact. This handler is triggered by the save button.
     */
    async onSave() {
      try {
        this.localContact.groups = [...this.newGroupsValue];
        await this.$store.dispatch("updateContactGroups", {
          groupNames: this.newGroupsValue,
          contact: this.contact
        });
        await this.updateContact();
        this.editMode = false;
      } catch (error) {
        showError(t("contacts", "Unable to update contact"));
      }
    }
  }
};
var _sfc_render$t = function render52() {
  var _vm = this, _c = _vm._self._c;
  return _c("AppContentDetails", [!_vm.contact ? _c("EmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "No contact selected"), "description": _vm.t("contacts", "Select a contact on the list to begin") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconContact", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 3494319139) }) : [_c("DetailsHeader", { scopedSlots: _vm._u([{ key: "avatar", fn: function() {
    return [_c("ContactAvatar", { attrs: { "contact": _vm.contact, "is-read-only": _vm.isReadOnly, "reload-bus": _vm.reloadBus }, on: { "update-local-contact": _vm.updateLocalContact } })];
  }, proxy: true }, { key: "title", fn: function() {
    return [_vm.isReadOnly ? _c("div", { staticClass: "contact-title" }, [_vm._v(" " + _vm._s(_vm.contact.fullName) + " ")]) : _c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.contact.fullName, expression: "contact.fullName" }], ref: "fullname", attrs: { "id": "contact-fullname", "placeholder": _vm.t("contacts", "Name"), "type": "text", "autocomplete": "off", "autocorrect": "off", "spellcheck": "false", "name": "fullname" }, domProps: { "value": _vm.contact.fullName }, on: { "click": _vm.selectInput, "input": function($event) {
      if ($event.target.composing) return;
      _vm.$set(_vm.contact, "fullName", $event.target.value);
    } } })];
  }, proxy: true }, { key: "subtitle", fn: function() {
    return [_vm.isReadOnly ? [_c("span", { domProps: { "innerHTML": _vm._s(_vm.formattedSubtitle) } })] : [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.contact.title, expression: "contact.title" }], attrs: { "id": "contact-title", "placeholder": _vm.t("contacts", "Title"), "type": "text", "autocomplete": "off", "autocorrect": "off", "spellcheck": "false", "name": "title" }, domProps: { "value": _vm.contact.title }, on: { "input": function($event) {
      if ($event.target.composing) return;
      _vm.$set(_vm.contact, "title", $event.target.value);
    } } }), _c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.contact.org, expression: "contact.org" }], attrs: { "id": "contact-org", "placeholder": _vm.t("contacts", "Company"), "type": "text", "autocomplete": "off", "autocorrect": "off", "spellcheck": "false", "name": "org" }, domProps: { "value": _vm.contact.org }, on: { "input": function($event) {
      if ($event.target.composing) return;
      _vm.$set(_vm.contact, "org", $event.target.value);
    } } })]];
  }, proxy: true }, { key: "quick-actions", fn: function() {
    return [!_vm.editMode && !_vm.loadingData ? _c("div", [_c("Actions", { attrs: { "inline": 6, "type": "secondary" } }, [_vm.isTalkEnabled && _vm.isInSystemAddressBook ? _c("ActionButton", { staticClass: "icon-talk quick-action", attrs: { "aria-label": _vm.t("contacts", "Go to talk conversation"), "name": _vm.t("contacts", "Go to talk conversation"), "href": _vm.callUrl } }) : _vm._e(), _vm.profilePageLink ? _c("ActionButton", { staticClass: "quick-action", attrs: { "aria-label": _vm.t("contacts", "View profile"), "name": _vm.t("contacts", "View profile"), "href": _vm.profilePageLink }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconAccount", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 1136206178) }) : _vm._e(), _vm._l(_vm.emailAddressList, function(emailAddress) {
      return _c("ActionLink", { key: emailAddress, staticClass: "quick-action", attrs: { "href": "mailto:" + emailAddress }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
        return [_c("IconMail", { attrs: { "size": 20 } })];
      }, proxy: true }], null, true) }, [_vm._v(" " + _vm._s(emailAddress) + " ")]);
    }), _vm._l(_vm.phoneNumberList, function(phoneNumber) {
      return _c("ActionLink", { key: phoneNumber, staticClass: "quick-action", attrs: { "href": "tel:" + phoneNumber }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
        return [_c("IconCall", { attrs: { "size": 20 } })];
      }, proxy: true }], null, true) }, [_vm._v(" " + _vm._s(phoneNumber) + " ")]);
    })], 2)], 1) : _vm._e()];
  }, proxy: true }, { key: "actions", fn: function() {
    return [_vm.warning ? _c(_vm.warning.icon, { directives: [{ name: "tooltip", rawName: "v-tooltip.bottom", value: {
      content: _vm.warning ? _vm.warning.msg : "",
      trigger: "hover focus"
    }, expression: "{\n							content: warning ? warning.msg : '',\n							trigger: 'hover focus'\n						}", modifiers: { "bottom": true } }], tag: "component", staticClass: "header-icon", attrs: { "classes": _vm.warning.classes } }) : _vm._e(), _vm.conflict ? _c("div", { directives: [{ name: "tooltip", rawName: "v-tooltip", value: {
      content: _vm.conflict,
      show: true,
      trigger: "manual"
    }, expression: "{\n							content: conflict,\n							show: true,\n							trigger: 'manual',\n						}" }], staticClass: "header-icon header-icon--pulse icon-history", on: { "click": _vm.refreshContact } }) : _vm._e(), _vm.fixed ? _c("div", { directives: [{ name: "tooltip", rawName: "v-tooltip", value: {
      content: _vm.t("contacts", "This contact was broken and received a fix. Please review the content and click here to save it."),
      show: true,
      trigger: "manual"
    }, expression: "{\n							content: t('contacts', 'This contact was broken and received a fix. Please review the content and click here to save it.'),\n							show: true,\n							trigger: 'manual',\n						}" }], staticClass: "header-icon header-icon--pulse icon-up", on: { "click": _vm.updateContact } }) : _vm._e(), !_vm.addressbookIsReadOnly ? [!_vm.editMode ? _c("NcButton", { attrs: { "type": _vm.isMobile ? "secondary" : "tertiary" }, on: { "click": function($event) {
      _vm.editMode = true;
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("PencilIcon", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 4260349822) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Edit")) + " ")]) : _c("NcButton", { attrs: { "type": "secondary", "disabled": _vm.loadingUpdate }, on: { "click": _vm.onSave }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_vm.loadingUpdate ? _c("IconLoading", { attrs: { "size": 20 } }) : _c("CheckIcon", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 3908750157) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Save")) + " ")])] : _vm._e()];
  }, proxy: true }, { key: "actions-menu", fn: function() {
    return [_c("ActionLink", { attrs: { "href": _vm.contact.url, "download": `${_vm.contact.displayName}.vcf` }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconDownload", { attrs: { "size": 20 } })];
    }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Download")) + " ")]), _vm.isReadOnly && _vm.addressbooksOptions.length > 0 ? _c("ActionButton", { ref: "cloneAction", attrs: { "close-after-click": true }, on: { "click": _vm.cloneContact }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconCopy", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 1700567014) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Clone contact")) + " ")]) : _vm._e(), _c("ActionButton", { attrs: { "close-after-click": true }, on: { "click": _vm.showQRcode }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconQr", { attrs: { "size": 20 } })];
    }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Generate QR Code")) + " ")]), _vm.enableToggleBirthdayExclusion ? _c("ActionButton", { attrs: { "close-after-click": true }, on: { "click": _vm.toggleBirthdayExclusionForContact }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("CakeIcon", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 1060251055) }, [_vm._v(" " + _vm._s(_vm.excludeFromBirthdayLabel) + " ")]) : _vm._e(), !_vm.addressbookIsReadOnly ? _c("ActionButton", { on: { "click": _vm.deleteContact }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconDelete", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 881161434) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Delete")) + " ")]) : _vm._e()];
  }, proxy: true }]) }), _vm.qrcode ? _c("Modal", { attrs: { "id": "qrcode-modal", "size": "small", "clear-view-delay": -1, "name": _vm.contact.displayName, "close-button-contained": false }, on: { "close": _vm.closeQrModal } }, [_c("img", { staticClass: "qrcode", attrs: { "src": `data:image/svg+xml;base64,${_vm.qrcode}`, "alt": _vm.t("contacts", "Contact vCard as QR code"), "width": "400" } })]) : _vm._e(), _vm.showPickAddressbookModal ? _c("Modal", { attrs: { "id": "pick-addressbook-modal", "clear-view-delay": -1, "name": _vm.t("contacts", "Pick an address book") }, on: { "close": _vm.closePickAddressbookModal } }, [_c("NcSelect", { ref: "pickAddressbook", staticClass: "address-book", attrs: { "allow-empty": false, "options": _vm.copyableAddressbooksOptions, "placeholder": _vm.t("contacts", "Select address book"), "track-by": "id", "label": "name" }, model: { value: _vm.pickedAddressbook, callback: function($$v) {
    _vm.pickedAddressbook = $$v;
  }, expression: "pickedAddressbook" } }), _c("button", { on: { "click": _vm.closePickAddressbookModal } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Cancel")) + " ")]), _c("button", { staticClass: "primary", on: { "click": _vm.cloneContact } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Clone contact")) + " ")])], 1) : _vm._e(), _vm.loadingData ? _c("IconLoading", { staticClass: "contact-details", attrs: { "size": 20 } }) : !_vm.loadingData ? _c("div", { staticClass: "contact-details-wrapper test1" }, [_c("section", { staticClass: "contact-details" }, _vm._l(_vm.groupedProperties, function(properties, name) {
    return _c("div", { key: name, class: `${name}` }, _vm._l(properties, function(property, index2) {
      return _c("ContactDetailsProperty", { key: `${index2}-${_vm.contact.key}-${property.name}`, attrs: { "is-first-property": index2 === 0, "is-last-property": index2 === properties.length - 1, "property": property, "contact": _vm.contact, "local-contact": _vm.localContact, "contacts": _vm.contacts, "bus": _vm.bus, "is-read-only": _vm.isReadOnly } });
    }), 1);
  }), 0), _c("PropertySelect", { staticClass: "property--addressbooks property--last", attrs: { "prop-model": _vm.addressbookModel, "options": _vm.addressbooksOptions, "value": _vm.addressbook, "is-first-property": true, "is-last-property": true, "property": {}, "hide-actions": true, "is-read-only": _vm.isReadOnly }, on: { "update:value": function($event) {
    _vm.addressbook = $event;
  } } }), _c("PropertyGroups", { staticClass: "property--groups property--last", attrs: { "prop-model": _vm.groupsModel, "value": _vm.localContact.groups, "contact": _vm.contact, "is-read-only": _vm.isReadOnly }, on: { "update:value": [function($event) {
    return _vm.$set(_vm.localContact, "groups", $event);
  }, _vm.updateGroups] } })], 1) : _vm._e(), _vm.nextcloudVersionAtLeast28 && !_vm.editMode ? _c("div", { staticClass: "related-resources" }, [!_vm.filesPanelHasError ? _c("NcRelatedResourcesPanel", { attrs: { "provider-id": "account", "resource-type": "files", "description": _vm.desc, "limit": 5, "header": _vm.t("contacts", "Media shares with you"), "item-id": _vm.contact.uid, "primary": true }, on: { "has-resources": (value) => _vm.hasFilesResources = value, "has-error": (value) => _vm.filesPanelHasError = value } }) : _vm._e(), !_vm.talkPanelHasError ? _c("NcRelatedResourcesPanel", { attrs: { "provider-id": "account", "resource-type": "talk", "description": _vm.desc, "limit": 5, "header": _vm.t("contacts", "Talk conversations with you"), "item-id": _vm.contact.uid, "primary": true }, on: { "has-resources": (value) => _vm.hasTalkResources = value, "has-error": (value) => _vm.talkPanelHasError = value } }) : _vm._e(), !_vm.calendarPanelHasError ? _c("NcRelatedResourcesPanel", { attrs: { "provider-id": "account", "resource-type": "calendar", "description": _vm.desc, "limit": 5, "header": _vm.t("contacts", "Calendar events with you"), "item-id": _vm.contact.uid, "primary": true }, on: { "has-resources": (value) => _vm.hasCalendarResources = value, "has-error": (value) => _vm.calendarPanelHasError = value } }) : _vm._e(), !_vm.deckPanelHasError ? _c("NcRelatedResourcesPanel", { attrs: { "provider-id": "account", "resource-type": "deck", "description": _vm.desc, "limit": 5, "header": _vm.t("contacts", "Deck cards with you"), "item-id": _vm.contact.uid, "primary": true }, on: { "has-resources": (value) => _vm.hasDeckResources = value, "has-error": (value) => _vm.deckPanelHasError = value } }) : _vm._e(), !_vm.hasRelatedResources && !_vm.loadingData ? _c("NcEmptyContent", { attrs: { "name": _vm.t("contacts", "No shared items with this contact") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("FolderMultipleImage", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 3645725449) }) : _vm._e()], 1) : _vm._e(), !_vm.isReadOnly ? _c("AddNewProp", { staticClass: "last-edit", attrs: { "bus": _vm.bus, "contact": _vm.contact } }) : _vm._e(), _vm.contact.rev ? _c("PropertyRev", { staticClass: "last-edit", attrs: { "value": _vm.contact.rev } }) : _vm._e()]], 2);
};
var _sfc_staticRenderFns$t = [];
var __component__$t = /* @__PURE__ */ normalizeComponent(
  _sfc_main$t,
  _sfc_render$t,
  _sfc_staticRenderFns$t,
  false,
  null,
  "b3e26a83"
);
const ContactDetails = __component__$t.exports;
const _sfc_main$s = {
  name: "ContactsListItem",
  components: {
    ListItem: NcListItem,
    BaseAvatar: NcAvatar
  },
  props: {
    index: {
      type: Number,
      required: true
    },
    source: {
      type: Object,
      required: true
    },
    reloadBus: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      avatarUrl: void 0
    };
  },
  computed: {
    selectedGroup() {
      return this.$route.params.selectedGroup;
    },
    selectedContact() {
      return this.$route.params.selectedContact;
    },
    // contact is not draggable when it has not been saved on server as it can't be added to groups/circles before
    isDraggable() {
      return !!this.source.dav && this.source.addressbook.id !== "z-server-generated--system";
    },
    // usable and valid html id for scrollTo
    id() {
      return window.btoa(this.source.key).slice(0, -2);
    },
    getTel() {
      return this.source.properties.find((property) => property.name === "tel")?.getFirstValue();
    }
  },
  created() {
    this.reloadBus.on("reload-avatar", this.reloadAvatarUrl);
    this.reloadBus.on("delete-avatar", this.deleteAvatar);
  },
  destroyed() {
    this.reloadBus.off("reload-avatar", this.reloadAvatarUrl);
    this.reloadBus.off("delete-avatar", this.deleteAvatar);
  },
  async mounted() {
    await this.loadAvatarUrl();
  },
  methods: {
    startDrag(evt, item) {
      evt.dataTransfer.dropEffect = "move";
      evt.dataTransfer.effectAllowed = "move";
      evt.dataTransfer.setData("item", JSON.stringify({
        addressbookId: item.addressbook.id,
        displayName: item.displayName,
        groups: item.groups,
        url: item.url,
        uid: item.uid
      }));
    },
    /**
     * Is called on save in ContactDetails to reload Avatar,
     * url does not change, so trigger on source change don't work
     *
     * @param {string} key from contact
     */
    reloadAvatarUrl(key) {
      if (key === this.source.key) {
        this.loadAvatarUrl();
      }
    },
    /**
     * Is called on save in ContactDetails to delete Avatar,
     * somehow the avatarUrl is not unavailable immediately, so we just set undefined
     *
     * @param {string} key from contact
     */
    deleteAvatar(key) {
      if (key === this.source.key) {
        this.avatarUrl = void 0;
      }
    },
    async loadAvatarUrl() {
      this.avatarUrl = void 0;
      if (this.source.photo) {
        const photoUrl = await this.source.getPhotoUrl();
        if (!photoUrl) {
          console.warn("contact has an invalid photo");
          return;
        }
        this.avatarUrl = photoUrl;
      } else if (this.source.hasPhoto && this.source.url) {
        this.avatarUrl = `${this.source.url}?photo`;
      }
    },
    /**
     * Select this contact within the list
     */
    selectContact() {
      this.$router.push({
        name: "contact",
        params: { selectedGroup: this.selectedGroup, selectedContact: this.source.key }
      });
    }
  }
};
var _sfc_render$s = function render53() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "contacts-list__item-wrapper", attrs: { "draggable": _vm.isDraggable }, on: { "dragstart": function($event) {
    return _vm.startDrag($event, _vm.source);
  } } }, [_c("ListItem", { key: _vm.source.key, staticClass: "list-item-style envelope", attrs: { "id": _vm.id, "name": _vm.source.displayName, "to": { name: "contact", params: { selectedGroup: _vm.selectedGroup, selectedContact: _vm.source.key } } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("div", { staticClass: "app-content-list-item-icon" }, [_c("BaseAvatar", { attrs: { "display-name": _vm.source.displayName, "url": _vm.avatarUrl, "size": 40 } })], 1)];
  }, proxy: true }, { key: "subname", fn: function() {
    return [_c("div", { staticClass: "envelope__subtitle" }, [_c("span", { staticClass: "envelope__subtitle__subject" }, [_vm._v(" " + _vm._s(_vm.source.email ? _vm.source.email : _vm.getTel) + " ")])])];
  }, proxy: true }]) })], 1);
};
var _sfc_staticRenderFns$s = [];
var __component__$s = /* @__PURE__ */ normalizeComponent(
  _sfc_main$s,
  _sfc_render$s,
  _sfc_staticRenderFns$s,
  false,
  null,
  "31d4d23b"
);
const ContactsListItem = __component__$s.exports;
const _sfc_main$r = {
  name: "ContactsList",
  components: {
    AppContentList: NcAppContentList,
    VirtualList
  },
  props: {
    list: {
      type: Array,
      required: true
    },
    contacts: {
      type: Object,
      required: true
    },
    searchQuery: {
      type: String,
      default: ""
    },
    reloadBus: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      ContactsListItem,
      query: ""
    };
  },
  computed: {
    selectedContact() {
      return this.$route.params.selectedContact;
    },
    selectedGroup() {
      return this.$route.params.selectedGroup;
    },
    filteredList() {
      return this.list.filter((item) => this.matchSearch(this.contacts[item.key])).map((item) => this.contacts[item.key]);
    }
  },
  watch: {
    selectedContact(key) {
      this.$nextTick(() => {
        this.scrollToContact(key);
      });
    },
    list(val, old) {
      if (val.length !== 0 && old.length === 0 && this.selectedContact) {
        this.$nextTick(() => {
          this.scrollToContact(this.selectedContact);
        });
      }
    }
  },
  mounted() {
    this.query = this.searchQuery;
  },
  methods: {
    // Select closest contact on deletion
    selectContact(oldIndex) {
      if (this.list.length > 0 && oldIndex < this.list.length) {
        const newContact = oldIndex === 0 ? this.list[oldIndex + 1] : this.list[oldIndex - 1];
        if (newContact) {
          this.$router.push({ name: "contact", params: { selectedGroup: this.selectedGroup, selectedContact: newContact.key } });
        }
      }
    },
    /**
     * Scroll to the desired contact if in the list and not visible
     *
     * @param {string} key the contact unique key
     */
    scrollToContact(key) {
      const item = this.$el.querySelector("#" + btoa(key).slice(0, -2));
      if (!(item && item.getBoundingClientRect().y > 50)) {
        const index2 = this.list.findIndex((contact) => contact.key === key);
        if (index2 > -1) {
          this.$refs.scroller.scrollToIndex(index2);
        }
      }
      if (item) {
        const pos = item.getBoundingClientRect().y + this.itemHeight - (this.$el.offsetHeight + 50);
        if (pos > 0) {
          const scroller = this.$refs.scroller.$el;
          scroller.scrollToOffset(scroller.scrollTop + pos);
        }
      }
    },
    /**
     * Is this matching the current search ?
     *
     * @param {Contact} contact the contact to search
     * @return {boolean}
     */
    matchSearch(contact) {
      if (this.query.trim() !== "") {
        return contact.searchData.toString().toLowerCase().search(this.query.trim().toLowerCase()) !== -1;
      }
      return true;
    }
  }
};
var _sfc_render$r = function render54() {
  var _vm = this, _c = _vm._self._c;
  return _c("AppContentList", { staticClass: "content-list" }, [_c("div", { staticClass: "contacts-list__header" }, [_c("div", { staticClass: "search-contacts-field" }, [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.query, expression: "query" }], attrs: { "type": "text", "placeholder": _vm.t("contacts", "Search contacts ") }, domProps: { "value": _vm.query }, on: { "input": function($event) {
    if ($event.target.composing) return;
    _vm.query = $event.target.value;
  } } })])]), _c("VirtualList", { ref: "scroller", staticClass: "contacts-list", attrs: { "data-key": "key", "data-sources": _vm.filteredList, "data-component": _vm.ContactsListItem, "estimate-size": 68, "extra-props": { reloadBus: _vm.reloadBus } } })], 1);
};
var _sfc_staticRenderFns$r = [];
var __component__$r = /* @__PURE__ */ normalizeComponent(
  _sfc_main$r,
  _sfc_render$r,
  _sfc_staticRenderFns$r,
  false,
  null,
  "f38948c9"
);
const ContactsList = __component__$r.exports;
const _sfc_main$q = {
  name: "ContactsContent",
  components: {
    AppContent: NcAppContent,
    Button: NcButton,
    ContactDetails,
    ContactsList,
    EmptyContent: NcEmptyContent,
    IconContact,
    IconLoading: NcLoadingIcon
  },
  mixins: [RouterMixin],
  props: {
    loading: {
      type: Boolean,
      default: true
    },
    contactsList: {
      type: Array,
      required: true
    }
  },
  data() {
    return {
      searchQuery: "",
      // communication for ContactListItem and ContactDetails (reload avatar)
      reloadBus: mitt()
    };
  },
  computed: {
    // store variables
    contacts() {
      return this.$store.getters.getContacts;
    },
    groups() {
      return this.$store.getters.getGroups;
    },
    sortedContacts() {
      return this.$store.getters.getSortedContacts;
    },
    selectedContact() {
      return this.$route.params.selectedContact;
    },
    /**
     * Is this a real group ?
     * Aka not a dynamically generated one like `All contacts`
     *
     * @return {boolean}
     */
    isRealGroup() {
      return this.groups.findIndex((group) => group.name === this.selectedGroup) > -1;
    },
    /**
     * Is the current group empty
     *
     * @return {boolean}
     */
    isEmptyGroup() {
      return this.contactsList.length === 0;
    },
    showDetails() {
      return !!this.selectedContact;
    }
  },
  methods: {
    /**
     * Forward the addContactsToGroup event to the parent
     *
     * @param {string} groupName the group name
     */
    addContactsToGroup(groupName) {
      emit("contacts:group:append", groupName);
    },
    /**
     * Forward the newContact event to the parent
     */
    newContact() {
      this.$emit("new-contact");
    },
    /**
     * Show the list and deselect contact
     */
    hideDetails() {
      this.$router.push({
        name: "group",
        params: {
          selectedGroup: this.selectedGroup
        }
      });
    }
  }
};
var _sfc_render$q = function render55() {
  var _vm = this, _c = _vm._self._c;
  return _vm.loading ? _c("AppContent", [_c("EmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "Loading contacts ") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconLoading", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 3081367109) })], 1) : _vm.isEmptyGroup && !_vm.isRealGroup ? _c("AppContent", [_c("EmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "There are no contacts yet") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconContact", { attrs: { "size": 20 } })];
  }, proxy: true }, { key: "desc", fn: function() {
    return [_c("Button", { attrs: { "type": "primary" }, on: { "click": _vm.newContact } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Create contact")) + " ")])];
  }, proxy: true }]) })], 1) : _vm.isEmptyGroup && _vm.isRealGroup ? _c("AppContent", [_c("EmptyContent", { staticClass: "empty-content", attrs: { "name": _vm.t("contacts", "There are no contacts in this group") }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconContact", { attrs: { "size": 20 } })];
  }, proxy: true }, { key: "desc", fn: function() {
    return [_vm.contacts.length === 0 ? _c("Button", { attrs: { "type": "primary" }, on: { "click": function($event) {
      return _vm.addContactsToGroup(_vm.selectedGroup);
    } } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Create contacts")) + " ")]) : _c("Button", { attrs: { "type": "primary" }, on: { "click": function($event) {
      return _vm.addContactsToGroup(_vm.selectedGroup);
    } } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Add contacts")) + " ")])];
  }, proxy: true }]) })], 1) : _c("AppContent", { attrs: { "show-details": _vm.showDetails }, on: { "update:showDetails": _vm.hideDetails }, scopedSlots: _vm._u([{ key: "list", fn: function() {
    return [_c("ContactsList", { attrs: { "list": _vm.contactsList, "contacts": _vm.contacts, "search-query": _vm.searchQuery, "reload-bus": _vm.reloadBus } })];
  }, proxy: true }]) }, [_c("ContactDetails", { attrs: { "contact-key": _vm.selectedContact, "contacts": _vm.sortedContacts, "reload-bus": _vm.reloadBus } })], 1);
};
var _sfc_staticRenderFns$q = [];
var __component__$q = /* @__PURE__ */ normalizeComponent(
  _sfc_main$q,
  _sfc_render$q,
  _sfc_staticRenderFns$q,
  false,
  null,
  "d3c63676"
);
const ContactsContent = __component__$q.exports;
const _sfc_main$p = {
  name: "ProcessingScreen",
  components: {
    EmptyContent: NcEmptyContent,
    IconContact
  },
  props: {
    total: {
      type: Number,
      required: true
    },
    progress: {
      type: Number,
      required: true
    },
    desc: {
      type: String,
      required: true
    },
    title: {
      type: String,
      required: true
    }
  }
};
var _sfc_render$p = function render56() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", [_c("EmptyContent", { staticClass: "processing-screen__wrapper", attrs: { "description": _vm.desc, "name": _vm.title }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconContact", { attrs: { "size": 20 } })];
  }, proxy: true }]) }), _c("div", { staticClass: "processing-screen__progress" }, [_c("progress", { attrs: { "max": _vm.total }, domProps: { "value": _vm.progress } })])], 1);
};
var _sfc_staticRenderFns$p = [];
var __component__$p = /* @__PURE__ */ normalizeComponent(
  _sfc_main$p,
  _sfc_render$p,
  _sfc_staticRenderFns$p,
  false,
  null,
  "7b0ed3c4"
);
const ProcessingScreen = __component__$p.exports;
const _sfc_main$o = {
  name: "AddToGroupView",
  components: {
    ProcessingScreen,
    Button: NcButton
  },
  props: {
    failed: {
      type: Number,
      default: 0
    },
    progress: {
      type: Number,
      default: 0
    },
    success: {
      type: Number,
      default: 0
    },
    total: {
      type: Number,
      default: 0
    },
    name: {
      type: String,
      default: ""
    }
  },
  computed: {
    progressHeader() {
      return n(
        "contacts",
        "{success} contact added to {name}",
        "{success} contacts added to {name}",
        this.success,
        { success: this.success, name: this.name }
      );
    },
    finishedHeader() {
      return n(
        "contacts",
        "Adding {success} contact to {name}",
        "Adding {success} contacts to {name}",
        this.success,
        { success: this.success, name: this.name }
      );
    },
    messageFailed() {
      return n(
        "contacts",
        "{count} error",
        "{count} errors",
        this.failed,
        { count: this.failed }
      );
    }
  },
  methods: {
    onClose() {
      this.$emit("close");
    }
  }
};
var _sfc_render$o = function render57() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", [_c("ProcessingScreen", { attrs: { "progress": _vm.progress, "total": _vm.total, "desc": _vm.failed > 0 ? _vm.messageFailed : "", "title": _vm.total === _vm.progress ? _vm.finishedHeader : _vm.progressHeader } }), _c("div", { staticClass: "close__button" }, [_vm.total === _vm.progress ? _c("Button", { staticClass: "primary", on: { "click": _vm.onClose } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Close")) + " ")]) : _vm._e()], 1)], 1);
};
var _sfc_staticRenderFns$o = [];
var __component__$o = /* @__PURE__ */ normalizeComponent(
  _sfc_main$o,
  _sfc_render$o,
  _sfc_staticRenderFns$o,
  false,
  null,
  "75b65f6b"
);
const AddToGroupView = __component__$o.exports;
const appendContactToGroup = async function(contact, groupName) {
  const groups = contact.groups;
  groups.push(groupName);
  return cancelableClient.patch(contact.url, {}, {
    headers: {
      "X-PROPERTY": "CATEGORIES",
      "X-PROPERTY-REPLACE": groups.map((groupName2) => encodeURIComponent(groupName2)).join(",")
    }
  });
};
const _sfc_main$n = {
  name: "ContactsPicker",
  components: {
    AddToGroupView,
    EntityPicker,
    Modal: NcModal
  },
  data() {
    return {
      // Entity picker
      showPicker: false,
      pickerforGroup: null,
      pickerData: [],
      pickerTypes: [{
        id: "contact",
        label: t("contacts", "Contacts")
      }],
      // Bulk processing
      isProcessing: false,
      isProcessDone: false,
      processStatus: {
        failed: 0,
        progress: 0,
        success: 0,
        total: 0,
        name: ""
      },
      passedGroupName: ""
    };
  },
  computed: {
    contacts() {
      return this.$store.getters.getContacts;
    },
    groups() {
      return this.$store.getters.getGroups;
    },
    sortedContacts() {
      return this.$store.getters.getSortedContacts;
    }
  },
  mounted() {
    subscribe("contacts:group:append", this.addContactsToGroup);
  },
  methods: {
    // Bulk contacts group management handlers
    addContactsToGroup(group) {
      console.debug("Contacts picker opened for group", group);
      this.passedGroupName = group.name ? group.name : group;
      if (typeof group === "string") {
        group = this.groups.find((a) => a.name === group);
        if (!group) {
          console.error("Cannot add contact to an undefined group", group);
          return;
        }
      }
      this.pickerData = this.sortedContacts.map(({ key }) => {
        const contact = this.contacts[key];
        return {
          id: contact.key,
          label: contact.displayName,
          type: "contact",
          readOnly: contact.addressbook.readOnly,
          groups: contact.groups
        };
      }).filter((contact) => !contact.readOnly).filter((contact) => contact.groups.indexOf(group.name) === -1);
      this.showPicker = true;
      this.pickerforGroup = group;
    },
    onContactPickerClose() {
      this.pickerData = [];
      this.showPicker = false;
    },
    onContactPickerPick(selection2) {
      console.debug("Adding", selection2, "to group", this.pickerforGroup);
      const groupName = this.pickerforGroup.name;
      this.isProcessing = true;
      this.showPicker = false;
      this.processStatus.total = selection2.length;
      this.processStatus.name = this.pickerforGroup.name;
      this.processStatus.progress = 0;
      this.processStatus.failed = 0;
      const limit = pLimit(3);
      const requests = [];
      selection2.map(async (entity) => {
        try {
          const contact = this.contacts[entity.id];
          requests.push(limit(
            () => appendContactToGroup(contact, groupName).then(() => {
              this.$store.dispatch("addContactToGroup", { contact, groupName });
              this.processStatus.progress++;
              this.processStatus.success++;
            }).catch((error) => {
              this.processStatus.progress++;
              this.processStatus.error++;
              console.error(error);
            })
          ));
        } catch (e2) {
          console.error(e2);
        }
      });
      Promise.all(requests).then(() => {
        this.isProcessDone = true;
        this.showPicker = false;
        this.$router.push({
          name: "group",
          params: {
            selectedGroup: typeof this.passedGroupName === "string" ? this.passedGroupName : this.passedGroupName.name
          }
        });
        if (this.processStatus.failed === 0) {
          setTimeout(this.closeProcess, 3e3);
        }
      });
    },
    closeProcess() {
      this.pickerforGroup = null;
      this.isProcessing = false;
      this.isProcessDone = false;
      this.processStatus.failed = 0;
      this.processStatus.progress = 0;
      this.processStatus.success = 0;
      this.processStatus.total = 0;
      if (this.passedGroupName === "" || this.passedGroupName === void 0) {
        return;
      }
      this.$router.push({
        name: "group",
        params: {
          selectedGroup: typeof this.passedGroupName === "string" ? this.passedGroupName : this.passedGroupName.name
        }
      });
    }
  }
};
var _sfc_render$n = function render58() {
  var _vm = this, _c = _vm._self._c;
  return _vm.isProcessing || _vm.isProcessDone ? _c("Modal", { attrs: { "clear-view-delay": -1, "can-close": _vm.isProcessDone }, on: { "close": _vm.closeProcess } }, [_c("AddToGroupView", _vm._b({ on: { "close": _vm.closeProcess } }, "AddToGroupView", _vm.processStatus, false))], 1) : _vm.showPicker ? _c("EntityPicker", { attrs: { "confirm-label": _vm.t("contacts", "Add to {group}", { group: _vm.pickerforGroup.name }), "data-types": _vm.pickerTypes, "data-set": _vm.pickerData }, on: { "close": _vm.onContactPickerClose, "submit": _vm.onContactPickerPick } }) : _vm._e();
};
var _sfc_staticRenderFns$n = [];
var __component__$n = /* @__PURE__ */ normalizeComponent(
  _sfc_main$n,
  _sfc_render$n,
  _sfc_staticRenderFns$n,
  false,
  null,
  null
);
const ContactsPicker = __component__$n.exports;
const _sfc_main$m = {
  name: "ImportView",
  components: {
    ProcessingScreen,
    Button: NcButton
  },
  computed: {
    importState() {
      return this.$store.getters.getImportState;
    },
    addressbook() {
      return this.importState.addressbook;
    },
    total() {
      return this.importState.total;
    },
    accepted() {
      return this.importState.accepted;
    },
    failed() {
      return this.importState.denied;
    },
    progress() {
      return this.accepted + this.failed;
    },
    importingHeader() {
      return n(
        "contacts",
        "Importing %n contact into {addressbook}",
        "Importing %n contacts into {addressbook}",
        this.total,
        {
          addressbook: this.addressbook
        }
      );
    },
    importedHeader() {
      return n(
        "contacts",
        "Done importing %n contact into {addressbook}",
        "Done importing %n contacts into {addressbook}",
        this.total,
        {
          addressbook: this.addressbook
        }
      );
    },
    importFailed() {
      return n(
        "contacts",
        "{count} error",
        "{count} errors",
        this.failed,
        { count: this.failed }
      );
    }
  },
  methods: {
    onClose() {
      this.$emit("close");
    }
  }
};
var _sfc_render$m = function render59() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", [_c("ProcessingScreen", { attrs: { "progress": _vm.progress, "total": _vm.total, "desc": _vm.failed > 0 ? _vm.importFailed : "", "title": _vm.total === _vm.progress ? _vm.importedHeader : _vm.importingHeader } }), _c("div", { staticClass: "close__button" }, [_vm.total === _vm.progress ? _c("Button", { staticClass: "primary", on: { "click": _vm.onClose } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Close")) + " ")]) : _vm._e()], 1)], 1);
};
var _sfc_staticRenderFns$m = [];
var __component__$m = /* @__PURE__ */ normalizeComponent(
  _sfc_main$m,
  _sfc_render$m,
  _sfc_staticRenderFns$m,
  false,
  null,
  "7132ae6a"
);
const ImportView = __component__$m.exports;
const _sfc_main$l = {
  name: "LocationEnterIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$l = function render60() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon location-enter-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M14 12L10 8V11H2V13H10V16M22 12A10 10 0 0 1 2.46 15H4.59A8 8 0 1 0 4.59 9H2.46A10 10 0 0 1 22 12Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$l = [];
var __component__$l = /* @__PURE__ */ normalizeComponent(
  _sfc_main$l,
  _sfc_render$l,
  _sfc_staticRenderFns$l,
  false,
  null,
  null
);
const LocationEnter = __component__$l.exports;
const _sfc_main$k = {
  name: "AccountStarIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$k = function render61() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon account-star-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M15,14C12.33,14 7,15.33 7,18V20H23V18C23,15.33 17.67,14 15,14M15,12A4,4 0 0,0 19,8A4,4 0 0,0 15,4A4,4 0 0,0 11,8A4,4 0 0,0 15,12M5,13.28L7.45,14.77L6.8,11.96L9,10.08L6.11,9.83L5,7.19L3.87,9.83L1,10.08L3.18,11.96L2.5,14.77L5,13.28Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$k = [];
var __component__$k = /* @__PURE__ */ normalizeComponent(
  _sfc_main$k,
  _sfc_render$k,
  _sfc_staticRenderFns$k,
  false,
  null,
  null
);
const AccountStar = __component__$k.exports;
const _sfc_main$j = {
  name: "AccountGroupOutlineIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$j = function render62() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon account-group-outline-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,5A3.5,3.5 0 0,0 8.5,8.5A3.5,3.5 0 0,0 12,12A3.5,3.5 0 0,0 15.5,8.5A3.5,3.5 0 0,0 12,5M12,7A1.5,1.5 0 0,1 13.5,8.5A1.5,1.5 0 0,1 12,10A1.5,1.5 0 0,1 10.5,8.5A1.5,1.5 0 0,1 12,7M5.5,8A2.5,2.5 0 0,0 3,10.5C3,11.44 3.53,12.25 4.29,12.68C4.65,12.88 5.06,13 5.5,13C5.94,13 6.35,12.88 6.71,12.68C7.08,12.47 7.39,12.17 7.62,11.81C6.89,10.86 6.5,9.7 6.5,8.5C6.5,8.41 6.5,8.31 6.5,8.22C6.2,8.08 5.86,8 5.5,8M18.5,8C18.14,8 17.8,8.08 17.5,8.22C17.5,8.31 17.5,8.41 17.5,8.5C17.5,9.7 17.11,10.86 16.38,11.81C16.5,12 16.63,12.15 16.78,12.3C16.94,12.45 17.1,12.58 17.29,12.68C17.65,12.88 18.06,13 18.5,13C18.94,13 19.35,12.88 19.71,12.68C20.47,12.25 21,11.44 21,10.5A2.5,2.5 0 0,0 18.5,8M12,14C9.66,14 5,15.17 5,17.5V19H19V17.5C19,15.17 14.34,14 12,14M4.71,14.55C2.78,14.78 0,15.76 0,17.5V19H3V17.07C3,16.06 3.69,15.22 4.71,14.55M19.29,14.55C20.31,15.22 21,16.06 21,17.07V19H24V17.5C24,15.76 21.22,14.78 19.29,14.55M12,16C13.53,16 15.24,16.5 16.23,17H7.77C8.76,16.5 10.47,16 12,16Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$j = [];
var __component__$j = /* @__PURE__ */ normalizeComponent(
  _sfc_main$j,
  _sfc_render$j,
  _sfc_staticRenderFns$j,
  false,
  null,
  null
);
const AccountGroupOutline = __component__$j.exports;
const _sfc_main$i = {
  name: "CircleNavigationItem",
  components: {
    ActionButton: NcActionButton,
    ActionLink: NcActionLink,
    ActionText: NcActionText,
    NcCounterBubble,
    AppNavigationItem: NcAppNavigationItem,
    ExitToApp,
    IconCog: Cog,
    IconDelete,
    LocationEnter,
    AccountStar,
    AccountGroup,
    AccountGroupOutline,
    IconLoading: NcLoadingIcon
  },
  mixins: [CircleActionsMixin],
  props: {
    circle: {
      type: Circle,
      required: true
    }
  },
  computed: {
    memberCount() {
      const count2 = Object.keys(this.circle?.members || []).length;
      if (count2 === 0 && this.circle.population > 0) {
        return this.circle.population;
      }
      return count2;
    }
  }
};
var _sfc_render$i = function render63() {
  var _vm = this, _c = _vm._self._c;
  return _c("AppNavigationItem", { key: _vm.circle.key, attrs: { "name": _vm.circle.displayName, "to": _vm.circle.router }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.circle.isOwner ? _c("AccountStar", { attrs: { "size": 20 } }) : _vm.circle.isMember ? _c("AccountGroup", { attrs: { "size": 20 } }) : _c("AccountGroupOutline", { attrs: { "size": 20 } })];
  }, proxy: true }, { key: "actions", fn: function() {
    return [_vm.loadingAction ? _c("ActionText", { scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconLoading", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 3081367109) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Loading ")) + " ")]) : [_vm.circle.canManageMembers ? _c("ActionButton", { attrs: { "close-after-click": true }, on: { "click": _vm.addMemberToCircle }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconCog", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 4087142664) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Manage team")) + " ")]) : _vm._e(), _c("ActionLink", { attrs: { "href": _vm.circleUrl, "icon": _vm.copyLinkIcon }, on: { "click": function($event) {
      $event.stopPropagation();
      $event.preventDefault();
      return _vm.copyToClipboard(_vm.circleUrl);
    } } }, [_vm._v(" " + _vm._s(_vm.copyButtonText) + " ")]), _vm.circle.canLeave ? _c("ActionButton", { on: { "click": _vm.confirmLeaveCircle }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("ExitToApp", { attrs: { "size": 16 } })];
    }, proxy: true }], null, false, 3893118231) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Leave team")) + " ")]) : !_vm.circle.isMember && _vm.circle.canJoin ? _c("ActionButton", { attrs: { "disabled": _vm.loadingJoin }, on: { "click": _vm.joinCircle }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("LocationEnter", { attrs: { "size": 16 } })];
    }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.joinButtonTitle) + " ")]) : _vm._e(), _vm.circle.canDelete ? _c("ActionButton", { on: { "click": _vm.confirmDeleteCircle }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconDelete", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 881161434) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Delete team")) + " ")]) : _vm._e()]];
  }, proxy: true }, { key: "counter", fn: function() {
    return [_vm.memberCount > 0 ? _c("NcCounterBubble", [_vm._v(" " + _vm._s(_vm.memberCount) + " ")]) : _vm._e()];
  }, proxy: true }]) });
};
var _sfc_staticRenderFns$i = [];
var __component__$i = /* @__PURE__ */ normalizeComponent(
  _sfc_main$i,
  _sfc_render$i,
  _sfc_staticRenderFns$i,
  false,
  null,
  null
);
const CircleNavigationItem = __component__$i.exports;
const _sfc_main$h = {
  name: "AccountMultiplePlusIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$h = function render64() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon account-multiple-plus-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19 17V19H7V17S7 13 13 13 19 17 19 17M16 8A3 3 0 1 0 13 11A3 3 0 0 0 16 8M19.2 13.06A5.6 5.6 0 0 1 21 17V19H24V17S24 13.55 19.2 13.06M18 5A2.91 2.91 0 0 0 17.11 5.14A5 5 0 0 1 17.11 10.86A2.91 2.91 0 0 0 18 11A3 3 0 0 0 18 5M8 10H5V7H3V10H0V12H3V15H5V12H8Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$h = [];
var __component__$h = /* @__PURE__ */ normalizeComponent(
  _sfc_main$h,
  _sfc_render$h,
  _sfc_staticRenderFns$h,
  false,
  null,
  null
);
const IconContactPlus = __component__$h.exports;
const _sfc_main$g = {
  name: "ShareVariantIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$g = function render65() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon share-variant-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M18,16.08C17.24,16.08 16.56,16.38 16.04,16.85L8.91,12.7C8.96,12.47 9,12.24 9,12C9,11.76 8.96,11.53 8.91,11.3L15.96,7.19C16.5,7.69 17.21,8 18,8A3,3 0 0,0 21,5A3,3 0 0,0 18,2A3,3 0 0,0 15,5C15,5.24 15.04,5.47 15.09,5.7L8.04,9.81C7.5,9.31 6.79,9 6,9A3,3 0 0,0 3,12A3,3 0 0,0 6,15C6.79,15 7.5,14.69 8.04,14.19L15.16,18.34C15.11,18.55 15.08,18.77 15.08,19C15.08,20.61 16.39,21.91 18,21.91C19.61,21.91 20.92,20.61 20.92,19A2.92,2.92 0 0,0 18,16.08Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$g = [];
var __component__$g = /* @__PURE__ */ normalizeComponent(
  _sfc_main$g,
  _sfc_render$g,
  _sfc_staticRenderFns$g,
  false,
  null,
  null
);
const IconShare = __component__$g.exports;
const isGroupSharingEnabled = loadState("contacts", "isGroupSharingEnabled", false);
const _sfc_main$f = {
  name: "SettingsAddressbookSharee",
  components: {
    Button: NcButton,
    IconDelete,
    IconGroup: IconContact,
    IconLoading: NcLoadingIcon,
    IconUser
  },
  props: {
    addressbook: {
      type: Object,
      required: true
    },
    sharee: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      loading: false
    };
  },
  computed: {
    writeable() {
      return this.sharee.writeable;
    },
    // generated id for this sharee
    uid() {
      return this.sharee.id + this.addressbook.id + Math.floor(Math.random() * 1e3);
    }
  },
  methods: {
    async deleteSharee() {
      if (this.loading) {
        return false;
      }
      this.loading = true;
      try {
        await this.$store.dispatch("removeSharee", {
          addressbook: this.addressbook,
          uri: this.sharee.uri
        });
      } catch (error) {
        console.error(error);
        showError(t("contacts", "Unable to delete the share"));
      } finally {
        this.loading = false;
      }
    },
    async editSharee() {
      if (this.loading) {
        return false;
      }
      this.loading = true;
      try {
        await this.$store.dispatch("toggleShareeWritable", {
          addressbook: this.addressbook,
          uri: this.sharee.uri,
          writeable: !this.sharee.writeable
        });
      } catch (error) {
        console.error(error);
        showError(t("contacts", "Unable to change permissions"));
      } finally {
        this.loading = false;
      }
    }
  }
};
var _sfc_render$f = function render66() {
  var _vm = this, _c = _vm._self._c;
  return _c("li", { staticClass: "addressbook-sharee" }, [_vm.loading ? _c("IconLoading", { attrs: { "size": 20 } }) : _vm.sharee.isGroup && !_vm.loading ? _c("IconGroup") : !_vm.sharee.isGroup && !_vm.loading ? _c("IconUser") : _vm._e(), _c("span", { staticClass: "addressbook-sharee__identifier", attrs: { "title": _vm.sharee.displayName } }, [_vm._v(" " + _vm._s(_vm.sharee.displayName) + " ")]), _c("span", { staticClass: "addressbook-sharee__utils" }, [_c("input", { staticClass: "checkbox", attrs: { "id": _vm.uid, "disabled": _vm.loading, "name": "editable", "type": "checkbox" }, domProps: { "checked": _vm.writeable }, on: { "change": _vm.editSharee } }), _c("label", { attrs: { "for": _vm.uid, "title": _vm.t("contacts", "can edit") } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "can edit")) + " ")]), _c("Button", { class: { "addressbook-sharee__utils--disabled": _vm.loading }, attrs: { "href": "#", "title": "Delete" }, on: { "click": _vm.deleteSharee }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconDelete", { attrs: { "size": 20 } })];
  }, proxy: true }]) })], 1)], 1);
};
var _sfc_staticRenderFns$f = [];
var __component__$f = /* @__PURE__ */ normalizeComponent(
  _sfc_main$f,
  _sfc_render$f,
  _sfc_staticRenderFns$f,
  false,
  null,
  "dc0cbef7"
);
const addressBookSharee = __component__$f.exports;
function urldecode(url) {
  return decodeURIComponent(url.replace(/\+/g, " "));
}
const _sfc_main$e = {
  name: "SettingsAddressbookShare",
  components: {
    NcSelect,
    addressBookSharee
  },
  props: {
    addressbook: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      isLoading: false,
      inputGiven: false,
      usersOrGroups: []
    };
  },
  computed: {
    placeholder() {
      if (isGroupSharingEnabled) {
        return t("contacts", "Share with users or groups");
      } else {
        return t("contacts", "Share with users");
      }
    },
    noResult() {
      return t("contacts", "No users or groups");
    }
  },
  mounted() {
    document.getElementById("users-groups-search").focus();
  },
  methods: {
    /**
     * Share addressbook
     *
     * @param {object} data destructuring object
     * @param {string} data.user the userId
     * @param {string} data.displayName the displayName
     * @param {string} data.uri the sharing principalScheme uri
     * @param {boolean} data.isGroup is this a group ?
     */
    shareAddressbook({ user, displayName, uri, isGroup }) {
      this.$store.dispatch("shareAddressbook", { addressbook: this.addressbook, user, displayName, uri, isGroup });
    },
    /**
     * Use the cdav client call to find matches to the query from the existing Users & Groups
     *
     * @param {string} query
     */
    findSharee: debounce(async function(query) {
      this.isLoading = true;
      this.usersOrGroups = [];
      if (query.length > 0) {
        const results = await client.principalPropertySearchByDisplayname(query);
        this.usersOrGroups = results.filter((result) => {
          const allowedCalendarUserTypes = ["INDIVIDUAL"];
          if (isGroupSharingEnabled) {
            allowedCalendarUserTypes.push("GROUP");
          }
          return allowedCalendarUserTypes.includes(result.calendarUserType) && !this.addressbook.shares.some((share) => share.uri === result.principalScheme);
        }).map((result) => {
          const isGroup = result.calendarUserType === "GROUP";
          return {
            user: urldecode(result[isGroup ? "groupId" : "userId"]),
            displayName: result.displayname,
            icon: isGroup ? "icon-group" : "icon-user",
            uri: urldecode(result.principalScheme),
            isGroup
          };
        });
        this.isLoading = false;
        this.inputGiven = true;
      } else {
        this.inputGiven = false;
        this.isLoading = false;
      }
    }, 500)
  }
};
var _sfc_render$e = function render67() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "addressbook-shares" }, [_c("NcSelect", { class: { "showContent": _vm.inputGiven, "icon-loading": _vm.isLoading }, attrs: { "id": "users-groups-search", "options": _vm.usersOrGroups, "searchable": true, "internal-search": false, "max-height": 600, "show-no-results": true, "placeholder": _vm.placeholder, "user-select": true, "open-direction": "bottom", "track-by": "user", "label": "displayName" }, on: { "search": _vm.findSharee, "input": _vm.shareAddressbook } }), _vm.addressbook.shares.length > 0 ? _c("ul", { staticClass: "addressbook-shares__list" }, _vm._l(_vm.addressbook.shares, function(sharee) {
    return _c("address-book-sharee", { key: sharee.uri, attrs: { "sharee": sharee, "addressbook": _vm.addressbook } });
  }), 1) : _vm._e()], 1);
};
var _sfc_staticRenderFns$e = [];
var __component__$e = /* @__PURE__ */ normalizeComponent(
  _sfc_main$e,
  _sfc_render$e,
  _sfc_staticRenderFns$e,
  false,
  null,
  "ec1cf7e2"
);
const ShareAddressBook = __component__$e.exports;
const _sfc_main$d = {
  name: "SettingsAddressbook",
  components: {
    ActionButton: NcActionButton,
    ActionCheckbox: NcActionCheckbox,
    ActionInput: NcActionInput,
    ActionLink: NcActionLink,
    Actions: NcActions,
    Button: NcButton,
    IconDelete,
    IconDownload,
    IconRename: IconRename$1,
    IconContactPlus,
    IconShare,
    IconLoading: NcLoadingIcon,
    ShareAddressBook
  },
  mixins: [CopyToClipboardMixin],
  props: {
    addressbook: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      deleteAddressbookLoading: false,
      editingName: false,
      menuOpen: false,
      renameLoading: false,
      shareOpen: false,
      toggleEnabledLoading: false
    };
  },
  computed: {
    enabled() {
      return this.addressbook.enabled;
    },
    hasShares() {
      return this.addressbook.shares.length > 0;
    },
    addressbooks() {
      return this.$store.getters.getAddressbooks;
    },
    hasMultipleAddressbooks() {
      return this.addressbooks.length > 1;
    },
    // info tooltip about number of shares
    sharedWithTooltip() {
      return this.hasShares ? n(
        "contacts",
        "Shared with {num} entity",
        "Shared with {num} entities",
        this.addressbook.shares.length,
        {
          num: this.addressbook.shares.length
        }
      ) : "";
    },
    copyButtonText() {
      if (this.copied) {
        return this.copySuccess ? t("contacts", "Copied") : t("contacts", "Cannot copy");
      }
      return t("contacts", "Copy link");
    },
    addressbookUrl() {
      return window.location.origin + this.addressbook.url;
    },
    contacts() {
      return Object.values(this.addressbook.contacts);
    },
    groups() {
      const allGroups = this.contacts.flatMap((contact) => contact.vCard.getAllProperties("categories").map((prop) => prop.getFirstValue()));
      return [...new Set(allGroups)];
    },
    contactsCount() {
      return this.contacts.length;
    },
    groupsCount() {
      return this.groups.length;
    },
    principalUrl() {
      const principalsStore = usePrincipalsStore();
      return principalsStore.currentUserPrincipal.principalUrl;
    }
  },
  watch: {
    menuOpen() {
      if (this.menuOpen === false) {
        this.editingName = false;
      }
    }
  },
  mounted() {
    this.popupItem = this.$el;
  },
  methods: {
    closeMenu() {
      this.menuOpen = false;
    },
    toggleMenu() {
      this.menuOpen = !this.menuOpen;
    },
    toggleShare() {
      this.shareOpen = !this.shareOpen;
    },
    async toggleAddressbookEnabled() {
      this.toggleEnabledLoading = true;
      try {
        await this.$store.dispatch("toggleAddressbookEnabled", this.addressbook);
      } catch (err) {
        console.error(err);
        showError(t("contacts", "Toggling of address book was not successful"));
      } finally {
        this.toggleEnabledLoading = false;
      }
    },
    confirmDeletion() {
      window.OC.dialogs.confirm(
        t("contacts", "This will delete the address book and every contacts within it"),
        t("contacts", "Delete {addressbook}?", { addressbook: this.addressbook.displayName }),
        this.deleteAddressbook,
        true
      );
    },
    confirmUnshare() {
      window.OC.dialogs.confirm(
        t("contacts", "This will unshare the address book and every contacts within it"),
        t("contacts", "Unshare {addressbook}?", { addressbook: this.addressbook.displayName }),
        this.deleteAddressbook,
        true
      );
    },
    async deleteAddressbook(confirm2) {
      if (confirm2) {
        this.deleteAddressbookLoading = true;
        try {
          await this.$store.dispatch("deleteAddressbook", this.addressbook);
        } catch (err) {
          console.error(err);
          showError(t("contacts", "Deletion of address book was not successful."));
        } finally {
          this.deleteAddressbookLoading = false;
        }
      }
    },
    renameAddressbook() {
      this.editingName = true;
    },
    async updateAddressbookName() {
      const addressbook = this.addressbook;
      const newName = this.$refs.renameInput.$el.querySelector('input[type="text"]').value;
      this.renameLoading = true;
      try {
        await this.$store.dispatch("renameAddressbook", { addressbook, newName });
      } catch (err) {
        console.error(err);
        showError(t("contacts", "Renaming of address book was not successful."));
      } finally {
        this.editingName = false;
        this.renameLoading = false;
        this.menuOpen = false;
      }
    }
  }
};
var _sfc_render$d = function render68() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "settings-addressbook-list" }, [_c("IconContactPlus", { staticClass: "settings-line__icon" }), _c("li", { staticClass: "addressbook", class: { "addressbook--disabled": !_vm.addressbook.enabled } }, [_c("div", { staticClass: "addressbook__content" }, [_c("span", { staticClass: "addressbook__name", attrs: { "title": _vm.addressbook.displayName } }, [_vm._v(" " + _vm._s(_vm.addressbook.enabled ? _vm.addressbook.displayName : _vm.t("contacts", "{addressbookname} (Disabled)", { addressbookname: _vm.addressbook.displayName })) + " ")]), _vm.addressbook.dav.description ? _c("div", { staticClass: "addressbook__description" }, [_vm._v(" " + _vm._s(_vm.addressbook.dav.description) + " ")]) : _vm._e(), _c("div", { staticClass: "addressbook__count-wrapper" }, [_c("span", { staticClass: "addressbook__count" }, [_vm._v(_vm._s(_vm.n("contacts", "%n contact", "%n contacts", _vm.contactsCount)))]), _c("span", { staticClass: "addressbook__count" }, [_vm._v("- " + _vm._s(_vm.n("contacts", "%n group", "%n groups", _vm.groupsCount)))])])]), !_vm.addressbook.readOnly ? _c("Button", { directives: [{ name: "tooltip", rawName: "v-tooltip.top", value: _vm.sharedWithTooltip, expression: "sharedWithTooltip", modifiers: { "top": true } }], staticClass: "addressbook__share", class: { "addressbook__share--shared": _vm.hasShares }, attrs: { "name": _vm.sharedWithTooltip, "href": "#" }, on: { "click": _vm.toggleShare }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconShare", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 165512238) }) : _vm._e(), _c("Actions", { staticClass: "addressbook__menu", attrs: { "menu-align": "right" } }, [_c("ActionLink", { attrs: { "href": _vm.addressbook.url, "icon": _vm.copyLinkIcon }, on: { "click": function($event) {
    $event.stopPropagation();
    $event.preventDefault();
    return _vm.copyToClipboard(_vm.addressbookUrl);
  } } }, [_vm._v(" " + _vm._s(_vm.copyButtonText) + " ")]), _c("ActionLink", { attrs: { "href": _vm.addressbook.url + "?export" }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconDownload", { attrs: { "size": 20 } })];
  }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Download")) + " ")]), _vm.addressbook.writeProps ? [!_vm.toggleEnabledLoading ? _c("ActionCheckbox", { attrs: { "checked": _vm.enabled }, on: { "change": function($event) {
    $event.stopPropagation();
    $event.preventDefault();
    return _vm.toggleAddressbookEnabled.apply(null, arguments);
  } } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Show")) + " ")]) : _c("ActionButton", { scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconLoading", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 3081367109) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Show")) + " ")])] : _vm._e(), !_vm.addressbook.readOnly ? [!_vm.editingName ? _c("ActionButton", { on: { "click": function($event) {
    $event.stopPropagation();
    $event.preventDefault();
    return _vm.renameAddressbook.apply(null, arguments);
  } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconRename", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 4207163347) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Rename")) + " ")]) : _c("ActionInput", { ref: "renameInput", attrs: { "disabled": _vm.renameLoading, "value": _vm.addressbook.displayName }, on: { "submit": _vm.updateAddressbookName }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.renameLoading ? _c("IconLoading", { attrs: { "size": 20 } }) : _vm._e(), _c("IconRename", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 1193466029) })] : _vm._e(), _vm.hasMultipleAddressbooks && _vm.addressbook.owner !== _vm.principalUrl && _vm.addressbook.owner !== "/remote.php/dav/principals/system/system/" ? _c("ActionButton", { on: { "click": _vm.confirmUnshare }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.deleteAddressbookLoading ? _c("IconLoading", { attrs: { "size": 20 } }) : _vm._e(), _c("IconDelete", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 4278421522) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Unshare from me")) + " ")]) : _vm.hasMultipleAddressbooks && _vm.addressbook.owner !== "/remote.php/dav/principals/system/system/" ? _c("ActionButton", { on: { "click": _vm.confirmDeletion }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.deleteAddressbookLoading ? _c("IconLoading", { attrs: { "size": 20 } }) : _vm._e(), _c("IconDelete", { attrs: { "size": 20 } })];
  }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Delete")) + " ")]) : _vm._e()], 2), _vm.shareOpen && !_vm.addressbook.readOnly ? _c("ShareAddressBook", { attrs: { "addressbook": _vm.addressbook } }) : _vm._e()], 1)], 1);
};
var _sfc_staticRenderFns$d = [];
var __component__$d = /* @__PURE__ */ normalizeComponent(
  _sfc_main$d,
  _sfc_render$d,
  _sfc_staticRenderFns$d,
  false,
  null,
  "5d9acc5f"
);
const SettingsAddressbook = __component__$d.exports;
const _sfc_main$c = {
  name: "LoadingIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$c = function render69() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon loading-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$c = [];
var __component__$c = /* @__PURE__ */ normalizeComponent(
  _sfc_main$c,
  _sfc_render$c,
  _sfc_staticRenderFns$c,
  false,
  null,
  null
);
const IconLoading = __component__$c.exports;
const _sfc_main$b = {
  name: "SettingsNewAddressbook",
  components: {
    NcTextField,
    IconAdd,
    IconLoading
  },
  data() {
    return {
      loading: false,
      displayName: "",
      // no slashes!
      // eslint-disable-next-line
      addressBookRegex: "[^/\\\\]+"
    };
  },
  methods: {
    /**
     * Add a new address book
     */
    addAddressbook() {
      if (this.displayName === "") {
        return;
      }
      this.loading = true;
      this.$store.dispatch("appendAddressbook", { displayName: this.displayName }).then(() => {
        this.displayName = "";
        this.loading = false;
      }).catch((error) => {
        console.error(error);
        showError(t("contacts", "An error occurred, unable to create the address book"));
        this.loading = false;
      });
    }
  }
};
var _sfc_render$b = function render70() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "new-addressbook-entry" }, [_vm.loading ? _c("IconLoading", { attrs: { "size": 20 } }) : _vm._e(), _c("NcTextField", { staticClass: "new-addressbook", attrs: { "value": _vm.displayName, "disabled": _vm.loading, "label": _vm.t("contacts", "Add new address book"), "pattern": _vm.addressBookRegex, "show-trailing-button": true, "trailing-button-label": _vm.t("contacts", "Add"), "trailing-button-icon": "arrowRight", "type": "text", "autocomplete": "off", "autocorrect": "off", "spellcheck": "false" }, on: { "update:value": function($event) {
    _vm.displayName = $event;
  }, "trailing-button-click": _vm.addAddressbook } }, [_c("IconAdd", { attrs: { "size": 20 } })], 1)], 1);
};
var _sfc_staticRenderFns$b = [];
var __component__$b = /* @__PURE__ */ normalizeComponent(
  _sfc_main$b,
  _sfc_render$b,
  _sfc_staticRenderFns$b,
  false,
  null,
  null
);
const SettingsNewAddressbook = __component__$b.exports;
const _sfc_main$a = {
  name: "AlertCircleIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$a = function render71() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon alert-circle-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$a = [];
var __component__$a = /* @__PURE__ */ normalizeComponent(
  _sfc_main$a,
  _sfc_render$a,
  _sfc_staticRenderFns$a,
  false,
  null,
  null
);
const IconError = __component__$a.exports;
const CancelToken = cancelableClient.CancelToken;
const picker = getFilePickerBuilder(t("contacts", "Choose a vCard file to import")).setMultiSelect(false).setType(1).allowDirectories(false).addMimeTypeFilter("text/vcard").build();
const _sfc_main$9 = {
  name: "SettingsImportContacts",
  components: {
    Button: NcButton,
    Modal: NcModal,
    NcSelect,
    IconUpload,
    IconError,
    IconFolder,
    IconLoading: NcLoadingIcon
  },
  data() {
    return {
      cancelRequest: () => {
      },
      importDestination: false,
      isOpened: false,
      loading: false
    };
  },
  computed: {
    // getter for the store addressbooks
    addressbooks() {
      return this.$store.getters.getAddressbooks;
    },
    // filter out disabled and read-only addressbooks
    availableAddressbooks() {
      return this.addressbooks.filter((addressbook) => !addressbook.readOnly && addressbook.enabled);
    },
    // available options for the multiselect
    options() {
      return this.availableAddressbooks.map((addressbook) => {
        return {
          id: addressbook.id,
          displayName: addressbook.displayName
        };
      });
    },
    selectedAddressbook: {
      get() {
        if (this.importDestination) {
          return this.availableAddressbooks.find((addressbook) => addressbook.id === this.importDestination.id);
        }
        return this.availableAddressbooks[0];
      },
      set(value) {
        this.importDestination = value;
      }
    },
    /**
     * The selected address book option for the select component.
     * We can't use the actual address book here as it can't be converted to JSON.
     */
    selectedAddressbookOption: {
      get() {
        return this.options.find((option) => option.id === this.selectedAddressbook.id);
      },
      set(value) {
        this.selectedAddressbook = this.availableAddressbooks.find((addressbook) => addressbook.id === value.id);
      }
    },
    // disable multiselect when there is only one address book
    isSingleAddressbook() {
      return this.options.length === 1;
    },
    isNoAddressbookAvailable() {
      return this.options.length < 1;
    },
    // importing state store getter
    importState() {
      return this.$store.getters.getImportState;
    },
    // are we currently importing ?
    isImporting() {
      return this.importState.stage !== "default";
    }
  },
  async mounted() {
    if (this.$route.name === "import") {
      const path2 = this.$route.query.file;
      await this.processLocalFile(path2);
      this.$router.push({
        name: "group",
        params: { selectedGroup: t("contacts", "All contacts") }
      });
    }
  },
  methods: {
    /**
     * Process input type file change
     *
     * @param {Event} event the input change event
     */
    processFile(event) {
      this.loading = true;
      this.$store.dispatch("changeStage", "parsing");
      const file = event.target.files[0];
      const reader = new FileReader();
      const addressbook = this.selectedAddressbook;
      this.$store.dispatch("setAddressbook", addressbook.displayName);
      reader.onload = () => {
        this.isOpened = false;
        this.$store.dispatch("importContactsIntoAddressbook", { vcf: reader.result, addressbook });
        event.target.value = "";
        this.resetState();
      };
      reader.readAsText(file);
    },
    async processLocalFile(path2) {
      console.debug("Importing", path2);
      try {
        this.cancelRequest();
        const source = CancelToken.source();
        this.cancelRequest = source.cancel;
        const file = await cancelableClient.get(U(`dav/files/${getCurrentUser().uid}`) + encodePath(path2), {
          cancelToken: source.token
        });
        const addressbook = this.selectedAddressbook;
        this.$store.dispatch("changeStage", "parsing");
        this.$store.dispatch("setAddressbook", addressbook.displayName);
        if (file.data) {
          await this.$store.dispatch("importContactsIntoAddressbook", { vcf: file.data, addressbook });
        }
      } catch (error) {
        console.error("Something wrong happened while processing local file", error);
      }
    },
    toggleModal() {
      this.isOpened = !this.isOpened;
      if (!this.isOpened) {
        this.cancelRequest();
      }
    },
    clickImportInput() {
      this.$refs["contact-import-input"].click();
    },
    /**
     * Open nextcloud file picker
     */
    async openPicker() {
      try {
        this.cancelRequest();
        const path2 = await picker.pick();
        if (path2) {
          this.loading = true;
          await this.processLocalFile(path2);
        }
        this.resetState();
      } catch (error) {
        this.loading = false;
        console.error("Something wrong happened while picking a file", error);
      }
    },
    /**
     * Reset default component state
     */
    resetState() {
      this.cancelRequest = () => {
      };
      this.importDestination = false;
      this.isOpened = false;
      this.loading = false;
    }
  }
};
var _sfc_render$9 = function render72() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "import-contact" }, [!_vm.isNoAddressbookAvailable ? [_c("Button", { staticClass: "import-contact__button-main", on: { "click": _vm.toggleModal }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconUpload", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 337456192) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Import contacts")) + " ")]), _vm.isOpened ? _c("Modal", { ref: "modal", staticClass: "import-contact__modal", attrs: { "name": _vm.t("contacts", "Import contacts") }, on: { "close": _vm.toggleModal } }, [_c("section", { staticClass: "import-contact__modal-addressbook" }, [_c("h2", [_vm._v(_vm._s(_vm.t("contacts", "Import contacts")))]), !_vm.isSingleAddressbook ? _c("NcSelect", { staticClass: "import-contact__modal-addressbook__select", attrs: { "id": "select-addressbook", "allow-empty": false, "clearable": false, "options": _vm.options, "disabled": _vm.isSingleAddressbook || _vm.isImporting, "placeholder": _vm.t("contacts", "Contacts"), "label": "displayName" }, scopedSlots: _vm._u([{ key: "selected-option", fn: function({ displayName }) {
    return [_c("span", [_vm._v(_vm._s(_vm.t("contacts", "Import into the {addressbookName} address book", { addressbookName: displayName })))])];
  } }], null, false, 3598663645), model: { value: _vm.selectedAddressbookOption, callback: function($$v) {
    _vm.selectedAddressbookOption = $$v;
  }, expression: "selectedAddressbookOption" } }) : _vm._e()], 1), _c("section", { staticClass: "import-contact__modal-pick" }, [_c("input", { ref: "contact-import-input", staticClass: "hidden-visually", attrs: { "id": "contact-import", "disabled": _vm.loading || _vm.isImporting, "type": "file" }, on: { "change": _vm.processFile } }), _c("Button", { staticClass: "import-contact__button import-contact__button--local", attrs: { "disabled": _vm.loading }, on: { "click": _vm.clickImportInput }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconUpload", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 337456192) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Select local file")) + " ")]), _c("Button", { staticClass: "import-contact__button import-contact__button--files", attrs: { "type": "primary", "disabled": _vm.loading }, on: { "click": _vm.openPicker }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.loading ? _c("IconLoading", { attrs: { "size": 20 } }) : _vm._e(), _c("IconFolder", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 457734779) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Import from files")) + " ")])], 1)]) : _vm._e()] : _c("Button", { staticClass: "button import-contact__button-disabled import-contact__multiselect-label import-contact__multiselect--no-select", attrs: { "id": "upload", "for": "contact-import" }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconError", { attrs: { "size": 20 } })];
  }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Importing is disabled because there are no address books available")) + " ")])], 2);
};
var _sfc_staticRenderFns$9 = [];
var __component__$9 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$9,
  _sfc_render$9,
  _sfc_staticRenderFns$9,
  false,
  null,
  "15a60b0f"
);
const SettingsImportContacts = __component__$9.exports;
const _sfc_main$8 = {
  name: "FormatListBulletedSquareIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$8 = function render73() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon format-list-bulleted-square-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M3,4H7V8H3V4M9,5V7H21V5H9M3,10H7V14H3V10M9,11V13H21V11H9M3,16H7V20H3V16M9,17V19H21V17H9" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$8 = [];
var __component__$8 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$8,
  _sfc_render$8,
  _sfc_staticRenderFns$8,
  false,
  null,
  null
);
const IconList = __component__$8.exports;
const _sfc_main$7 = {
  name: "SettingsSortContacts",
  components: {
    NcSelect,
    IconList
  },
  computed: {
    /* Order Keys */
    options() {
      return [
        {
          label: t("contacts", "First name"),
          key: "firstName"
        },
        {
          label: t("contacts", "Last name"),
          key: "lastName"
        },
        {
          label: t("contacts", "Phonetic first name"),
          key: "phoneticFirstName"
        },
        {
          label: t("contacts", "Phonetic last name"),
          key: "phoneticLastName"
        },
        {
          label: t("contacts", "Display name"),
          key: "displayName"
        },
        {
          label: t("contacts", "Last modified"),
          key: "rev"
        }
      ];
    },
    /* Current order Key */
    orderKey() {
      return this.$store.getters.getOrderKey;
    },
    orderKeyOption() {
      return this.options.filter((option) => option.key === this.orderKey)[0];
    }
  },
  methods: {
    sortContacts(orderKey) {
      const key = orderKey && orderKey.key ? orderKey.key : "displayName";
      this.$store.commit("setOrder", key);
      this.$store.commit("sortContacts");
      localStorage.setItem("orderKey", key);
    },
    formatSortByLabel(option) {
      return t("contacts", "Sort by {sorting}", { sorting: option.label });
    }
  }
};
var _sfc_render$7 = function render74() {
  var _vm = this, _c = _vm._self._c;
  return _c("div", { staticClass: "sort-contacts" }, [_c("IconList", { staticClass: "settings-line__icon" }), _c("NcSelect", { attrs: { "id": "sort-by", "value": _vm.orderKeyOption, "searchable": false, "allow-empty": false, "options": _vm.options, "custom-label": _vm.formatSortByLabel, "track-by": "key", "label": "label" }, on: { "input": _vm.sortContacts } })], 1);
};
var _sfc_staticRenderFns$7 = [];
var __component__$7 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$7,
  _sfc_render$7,
  _sfc_staticRenderFns$7,
  false,
  null,
  "8819b273"
);
const SettingsSortContacts = __component__$7.exports;
const _sfc_main$6 = {
  name: "ContactsSettings",
  components: {
    AppSettingsDialog: NcAppSettingsDialog,
    AppSettingsSection: NcAppSettingsSection,
    SettingsAddressbook,
    SettingsNewAddressbook,
    SettingsImportContacts,
    SettingsSortContacts,
    CheckboxRadioSwitch: NcCheckboxRadioSwitch
  },
  props: {
    open: {
      required: true,
      type: Boolean
    }
  },
  data() {
    return {
      CONTACTS_SETTINGS,
      allowSocialSync: loadState("contacts", "allowSocialSync") !== "no",
      enableSocialSync: loadState("contacts", "enableSocialSync") !== "no",
      enableSocialSyncLoading: false,
      showSettings: false
    };
  },
  computed: {
    // store getters
    addressbooks() {
      return this.$store.getters.getAddressbooks;
    }
  },
  watch: {
    showSettings(value) {
      if (!value) {
        this.$emit("update:open", value);
      }
    },
    async open(value) {
      if (value) {
        await this.onOpen();
      }
    }
  },
  methods: {
    onClickImport(event) {
      this.$emit("clicked", event);
    },
    async toggleSocialSync() {
      this.enableSocialSync = !this.enableSocialSync;
      this.enableSocialSyncLoading = true;
      let setting = "yes";
      this.enableSocialSync ? setting = "yes" : setting = "no";
      try {
        await cancelableClient.put(_("apps/contacts/api/v1/social/config/user/enableSocialSync"), {
          allow: setting
        });
      } finally {
        this.enableSocialSyncLoading = false;
      }
    },
    onLoad() {
      this.$emit("file-loaded", false);
    },
    async onOpen() {
      this.showSettings = true;
    }
  }
};
var _sfc_render$6 = function render75() {
  var _vm = this, _c = _vm._self._c;
  return _c("AppSettingsDialog", { attrs: { "id": "app-settings-dialog", "name": _vm.t("contacts", "Contacts settings"), "show-navigation": true, "open": _vm.showSettings }, on: { "update:open": function($event) {
    _vm.showSettings = $event;
  } } }, [_c("AppSettingsSection", { attrs: { "id": "general-settings", "name": _vm.t("contacts", "General settings") } }, [_c("CheckboxRadioSwitch", { staticClass: "social-sync__checkbox contacts-settings-modal__form__row", attrs: { "checked": _vm.enableSocialSync, "loading": _vm.enableSocialSyncLoading, "disabled": _vm.enableSocialSyncLoading }, on: { "update:checked": _vm.toggleSocialSync } }, [_c("div", { staticClass: "social-sync__checkbox__label" }, [_c("span", [_vm._v(" " + _vm._s(_vm.t("contacts", "Update avatars from social media")) + " "), _c("em", [_vm._v(_vm._s(_vm.t("contacts", "(refreshed once per week)")))])])])]), _c("SettingsSortContacts", { staticClass: "contacts-settings-modal__form__row" })], 1), _c("AppSettingsSection", { attrs: { "id": "address-books", "name": _vm.t("contacts", "Address books") } }, [_c("div", { staticClass: "contacts-settings-modal__form" }, [_c("div", { staticClass: "contacts-settings-modal__form__row" }, [_c("ul", { staticClass: "addressbook-list", attrs: { "id": "addressbook-list" } }, _vm._l(_vm.addressbooks, function(addressbook) {
    return _c("SettingsAddressbook", { key: addressbook.id, attrs: { "addressbook": addressbook } });
  }), 1)]), _c("SettingsNewAddressbook", { staticClass: "contacts-settings-modal__form__row settings-new-addressbook", attrs: { "addressbooks": _vm.addressbooks } }), _c("SettingsImportContacts", { staticClass: "contacts-settings-modal__form__row", attrs: { "addressbooks": _vm.addressbooks }, on: { "clicked": _vm.onClickImport, "file-loaded": _vm.onLoad } })], 1)])], 1);
};
var _sfc_staticRenderFns$6 = [];
var __component__$6 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$6,
  _sfc_render$6,
  _sfc_staticRenderFns$6,
  false,
  null,
  "f05a700d"
);
const ContactsSettings = __component__$6.exports;
var download$1 = { exports: {} };
(function(module2, exports) {
  (function(root2, factory) {
    {
      module2.exports = factory();
    }
  })(commonjsGlobal, function() {
    return function download2(data, strFileName, strMimeType) {
      var self = window, defaultMime = "application/octet-stream", mimeType = strMimeType || defaultMime, payload = data, url = !strFileName && !strMimeType && payload, anchor = document.createElement("a"), toString = function(a) {
        return String(a);
      }, myBlob = self.Blob || self.MozBlob || self.WebKitBlob || toString, fileName = strFileName || "download", blob, reader;
      myBlob = myBlob.call ? myBlob.bind(self) : Blob;
      if (String(this) === "true") {
        payload = [payload, mimeType];
        mimeType = payload[0];
        payload = payload[1];
      }
      if (url && url.length < 2048) {
        fileName = url.split("/").pop().split("?")[0];
        anchor.href = url;
        if (anchor.href.indexOf(url) !== -1) {
          var ajax = new XMLHttpRequest();
          ajax.open("GET", url, true);
          ajax.responseType = "blob";
          ajax.onload = function(e2) {
            download2(e2.target.response, fileName, defaultMime);
          };
          setTimeout(function() {
            ajax.send();
          }, 0);
          return ajax;
        }
      }
      if (/^data:([\w+-]+\/[\w+.-]+)?[,;]/.test(payload)) {
        if (payload.length > 1024 * 1024 * 1.999 && myBlob !== toString) {
          payload = dataUrlToBlob(payload);
          mimeType = payload.type || defaultMime;
        } else {
          return navigator.msSaveBlob ? (
            // IE10 can't do a[download], only Blobs:
            navigator.msSaveBlob(dataUrlToBlob(payload), fileName)
          ) : saver(payload);
        }
      } else {
        if (/([\x80-\xff])/.test(payload)) {
          var i = 0, tempUiArr = new Uint8Array(payload.length), mx = tempUiArr.length;
          for (i; i < mx; ++i) tempUiArr[i] = payload.charCodeAt(i);
          payload = new myBlob([tempUiArr], { type: mimeType });
        }
      }
      blob = payload instanceof myBlob ? payload : new myBlob([payload], { type: mimeType });
      function dataUrlToBlob(strUrl) {
        var parts = strUrl.split(/[:;,]/), type = parts[1], decoder = parts[2] == "base64" ? atob : decodeURIComponent, binData = decoder(parts.pop()), mx2 = binData.length, i2 = 0, uiArr = new Uint8Array(mx2);
        for (i2; i2 < mx2; ++i2) uiArr[i2] = binData.charCodeAt(i2);
        return new myBlob([uiArr], { type });
      }
      function saver(url2, winMode) {
        if ("download" in anchor) {
          anchor.href = url2;
          anchor.setAttribute("download", fileName);
          anchor.className = "download-js-link";
          anchor.innerHTML = "downloading...";
          anchor.style.display = "none";
          document.body.appendChild(anchor);
          setTimeout(function() {
            anchor.click();
            document.body.removeChild(anchor);
            if (winMode === true) {
              setTimeout(function() {
                self.URL.revokeObjectURL(anchor.href);
              }, 250);
            }
          }, 66);
          return true;
        }
        if (/(Version)\/(\d+)\.(\d+)(?:\.(\d+))?.*Safari\//.test(navigator.userAgent)) {
          if (/^data:/.test(url2)) url2 = "data:" + url2.replace(/^data:([\w\/\-\+]+)/, defaultMime);
          if (!window.open(url2)) {
            if (confirm("Displaying New Document\n\nUse Save As... to download, then click back to return to this page.")) {
              location.href = url2;
            }
          }
          return true;
        }
        var f = document.createElement("iframe");
        document.body.appendChild(f);
        if (!winMode && /^data:/.test(url2)) {
          url2 = "data:" + url2.replace(/^data:([\w\/\-\+]+)/, defaultMime);
        }
        f.src = url2;
        setTimeout(function() {
          document.body.removeChild(f);
        }, 333);
      }
      if (navigator.msSaveBlob) {
        return navigator.msSaveBlob(blob, fileName);
      }
      if (self.URL) {
        saver(self.URL.createObjectURL(blob), true);
      } else {
        if (typeof blob === "string" || blob.constructor === toString) {
          try {
            return saver("data:" + mimeType + ";base64," + self.btoa(blob));
          } catch (y2) {
            return saver("data:" + mimeType + "," + encodeURIComponent(blob));
          }
        }
        reader = new FileReader();
        reader.onload = function(e2) {
          saver(this.result);
        };
        reader.readAsDataURL(blob);
      }
      return true;
    };
  });
})(download$1);
var downloadExports = download$1.exports;
const download = /* @__PURE__ */ getDefaultExportFromCjs(downloadExports);
const renameContactFromGroup = async function(contact, oldGroupName, newGroupName) {
  const foundGroups = contact.groups;
  foundGroups.push(newGroupName);
  let currentGroups = foundGroups.map((groupName) => encodeURIComponent(groupName));
  currentGroups = currentGroups.filter((e2) => e2 !== encodeURIComponent(oldGroupName));
  return cancelableClient.patch(contact.url, {}, {
    headers: {
      "X-PROPERTY": "CATEGORIES",
      "X-PROPERTY-REPLACE": currentGroups.join(",")
    }
  });
};
const removeContactFromGroup = async function(contact, groupName) {
  const foundGroups = contact.groups;
  let currentGroups = foundGroups.map((groupName2) => encodeURIComponent(groupName2));
  currentGroups = currentGroups.filter((e2) => e2 !== encodeURIComponent(groupName));
  return cancelableClient.patch(contact.url, {}, {
    headers: {
      "X-PROPERTY": "CATEGORIES",
      "X-PROPERTY-REPLACE": currentGroups.join(",")
    }
  });
};
const _sfc_main$5 = {
  name: "FolderEditIcon",
  emits: ["click"],
  props: {
    title: {
      type: String
    },
    fillColor: {
      type: String,
      default: "currentColor"
    },
    size: {
      type: Number,
      default: 24
    }
  }
};
var _sfc_render$5 = function render76() {
  var _vm = this, _c = _vm._self._c;
  return _c("span", _vm._b({ staticClass: "material-design-icon folder-edit-icon", attrs: { "aria-hidden": _vm.title ? null : "true", "aria-label": _vm.title, "role": "img" }, on: { "click": function($event) {
    return _vm.$emit("click", $event);
  } } }, "span", _vm.$attrs, false), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.fillColor, "width": _vm.size, "height": _vm.size, "viewBox": "0 0 24 24" } }, [_c("path", { attrs: { "d": "M19.39 10.74L11 19.13V20H4C2.9 20 2 19.11 2 18V6C2 4.89 2.89 4 4 4H10L12 6H20C21.1 6 22 6.89 22 8V10.15C21.74 10.06 21.46 10 21.17 10C20.5 10 19.87 10.26 19.39 10.74M13 19.96V22H15.04L21.17 15.88L19.13 13.83L13 19.96M22.85 13.47L21.53 12.15C21.33 11.95 21 11.95 20.81 12.15L19.83 13.13L21.87 15.17L22.85 14.19C23.05 14 23.05 13.67 22.85 13.47Z" } }, [_vm.title ? _c("title", [_vm._v(_vm._s(_vm.title))]) : _vm._e()])])]);
};
var _sfc_staticRenderFns$5 = [];
var __component__$5 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$5,
  _sfc_render$5,
  _sfc_staticRenderFns$5,
  false,
  null,
  null
);
const IconRename = __component__$5.exports;
const _sfc_main$4 = {
  name: "GroupNavigationItem",
  components: {
    ActionButton: NcActionButton,
    NcCounterBubble,
    AppNavigationItem: NcAppNavigationItem,
    ActionInput: NcActionInput,
    IconContact,
    IconAdd,
    IconDownload,
    IconEmail,
    IconRename,
    IconDelete,
    IconLoading: NcLoadingIcon
  },
  props: {
    group: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      newGroupName: "",
      renaming: false,
      deleting: false
    };
  },
  computed: {
    contacts() {
      return this.$store.getters.getContacts;
    },
    isEmpty() {
      return this.group.contacts.length === 0;
    }
  },
  methods: {
    /**
     * @param groups
     * @param groupId
     */
    isInGroup(groups, groupId) {
      return groups.includes(groupId);
    },
    /**
     * Drop contact on group handler.
     *
     * @param {object} event drop event
     * @param {object} group to add to dropped contact
     * @return {Promise<void>}
     */
    async onDrop(event, group) {
      try {
        const contactFromDropData = JSON.parse(event.dataTransfer.getData("item"));
        const contactFromStore = this.$store.getters.getContact(`${contactFromDropData.uid}~${contactFromDropData.addressbookId}`);
        if (contactFromStore && !this.isInGroup(contactFromStore.groups, group.id)) {
          const contact = this.$store.getters.getContact(`${contactFromDropData.uid}~${contactFromDropData.addressbookId}`);
          await this.$store.dispatch("updateContactGroups", {
            groupNames: [...contactFromStore.groups, group.id],
            contact
          });
          const localContact = Object.assign(
            Object.create(Object.getPrototypeOf(contact)),
            contact
          );
          localContact.groups = [...contactFromStore.groups, group.id];
          await this.$store.dispatch("updateContact", localContact);
        }
      } catch (e2) {
        console.error(e2);
        showError("Tried to drop an invalid contact!");
      } finally {
        event.target.closest(".group-drop-area").removeAttribute("drop-active");
      }
    },
    // Add marker for drop area
    onDragOver(event) {
      event.preventDefault();
      event.target.closest(".group-drop-area").setAttribute("drop-active", true);
    },
    // Remove marker from drop area
    onDragLeave(event) {
      event.target.closest(".group-drop-area").removeAttribute("drop-active");
    },
    // Trigger the entity picker view
    addContactsToGroup() {
      emit("contacts:group:append", this.group.name);
    },
    /**
     * Download group of contacts
     *
     * @param {object} group of contacts to be downloaded
     */
    downloadGroup(group) {
      let groupedContacts = {};
      group.contacts.forEach((key) => {
        const id2 = this.contacts[key].addressbook.id;
        groupedContacts = Object.assign({
          [id2]: {
            addressbook: this.contacts[key].addressbook,
            contacts: []
          }
        }, groupedContacts);
        groupedContacts[id2].contacts.push(this.contacts[key].url);
      });
      const vcardPromise = Promise.all(
        Object.keys(groupedContacts).map((key) => groupedContacts[key].addressbook.dav.addressbookMultigetExport(groupedContacts[key].contacts))
      ).then((response) => ({
        groupName: group.name,
        data: response.map((data) => data.body).join("")
      }));
      this.downloadVcardPromise(vcardPromise);
    },
    /**
     * Download vcard promise as vcard file
     *
     * @param {Promise} vcardPromise the full vcf file promise
     */
    async downloadVcardPromise(vcardPromise) {
      vcardPromise.then((response) => {
        const filename = hooks().format("YYYY-MM-DD_HH-mm") + "_" + response.groupName + ".vcf";
        const content = "data:text/plain;charset=utf-8," + window.encodeURIComponent(response.data);
        download(content, filename, "text/vcard");
      });
    },
    /**
     * Open mailto: for contacts in a group
     *
     * @param {object} group of contacts to be emailed
     * @param {string} mode
     */
    emailGroup(group, mode = "to") {
      const emails = [];
      group.contacts.filter((key) => this.contacts[key].email !== null).forEach((key) => {
        const email = this.contacts[key].email.replace(/(.*<)([^>]*)(>)/g, "$2").trim();
        const name = this.contacts[key].fullName.replace(/[,<>]/g, "").trim();
        if (email === "") {
          return;
        }
        if (name === null || name === "") {
          emails.push(email);
          return;
        }
        emails.push(`${name} <${email}>`);
      });
      window.location.href = `mailto:?${mode}=${emails.map(encodeURIComponent).join(",")}`;
    },
    /**
     * Rename group in store and on server
     */
    async renameGroup() {
      if (this.newGroupName === "") {
        return;
      }
      this.renaming = true;
      for (const key of this.group.contacts) {
        const contact = this.$store.getters.getContact(key);
        if (contact === void 0) {
          return;
        }
        try {
          await renameContactFromGroup(contact, this.group.name, this.newGroupName);
        } catch (e2) {
          console.error("Error renaming group", e2);
        }
      }
      this.$store.commit("renameGroup", {
        oldGroupName: this.group.name,
        newGroupName: this.newGroupName
      });
      this.renaming = false;
    },
    /**
     * Delete group from store and on server
     */
    async deleteGroup() {
      this.deleting = true;
      for (const key of this.group.contacts) {
        const contact = this.$store.getters.getContact(key);
        if (contact === void 0) {
          return;
        }
        try {
          await removeContactFromGroup(contact, this.group.name);
        } catch (e2) {
          console.error("Error deleting group", e2);
        }
      }
      this.$store.commit("removeGroup", this.group.name);
      this.deleting = false;
    }
  }
};
var _sfc_render$4 = function render77() {
  var _vm = this, _c = _vm._self._c;
  return !_vm.isEmpty ? _c("div", { staticClass: "group-drop-area", attrs: { "data-testid": "group-drop-area" }, on: { "drop": function($event) {
    return _vm.onDrop($event, _vm.group);
  }, "dragenter": function($event) {
    $event.preventDefault();
  }, "dragover": function($event) {
    return _vm.onDragOver($event);
  }, "dragleave": function($event) {
    return _vm.onDragLeave($event);
  } } }, [_c("AppNavigationItem", { key: _vm.group.key, attrs: { "to": _vm.group.router, "name": _vm.group.name }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconContact", { attrs: { "size": 20 } })];
  }, proxy: true }, { key: "actions", fn: function() {
    return [_c("ActionButton", { attrs: { "close-after-click": true }, on: { "click": function($event) {
      return _vm.addContactsToGroup(_vm.group);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconAdd", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 2388353250) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Add contacts")) + " ")]), _c("ActionInput", { attrs: { "value": _vm.newGroupName, "disabled": _vm.renaming }, on: { "update:value": function($event) {
      _vm.newGroupName = $event;
    }, "submit": _vm.renameGroup }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_vm.renaming ? _c("IconLoading", { attrs: { "size": 20 } }) : _c("IconRename", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 1268619769) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Rename")) + " ")]), _c("ActionButton", { attrs: { "close-after-click": true }, on: { "click": function($event) {
      return _vm.downloadGroup(_vm.group);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconDownload", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 2487097783) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Export")) + " ")]), _c("ActionButton", { on: { "click": function($event) {
      return _vm.emailGroup(_vm.group);
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconEmail", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 984773423) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Send email")) + " ")]), _c("ActionButton", { on: { "click": function($event) {
      return _vm.emailGroup(_vm.group, "bcc");
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconEmail", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 984773423) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Send email as BCC")) + " ")]), _c("ActionButton", { attrs: { "disabled": _vm.deleting }, on: { "click": _vm.deleteGroup }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_vm.deleting ? _c("IconLoading", { attrs: { "size": 20 } }) : _c("IconDelete", { attrs: { "size": 20 } })];
    }, proxy: true }], null, false, 411196473) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Delete")) + " ")])];
  }, proxy: true }, { key: "counter", fn: function() {
    return [_vm.group.contacts.length > 0 ? _c("NcCounterBubble", [_vm._v(" " + _vm._s(_vm.group.contacts.length) + " ")]) : _vm._e()];
  }, proxy: true }], null, false, 2818531691) })], 1) : _vm._e();
};
var _sfc_staticRenderFns$4 = [];
var __component__$4 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$4,
  _sfc_render$4,
  _sfc_staticRenderFns$4,
  false,
  null,
  "dc69e4be"
);
const GroupNavigationItem = __component__$4.exports;
const _sfc_main$3 = {
  name: "NewCircleIntro",
  components: {
    CheckboxRadioSwitch: NcCheckboxRadioSwitch,
    Modal: NcModal
  },
  props: {
    loading: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      circleName: "",
      isPersonal: false,
      isLocal: false,
      CIRCLE_DESC
    };
  },
  computed: {
    isEmptyName() {
      return this.circleName.trim() === "";
    },
    isGlobalScale() {
      return e$1().circles?.status?.globalScale !== false;
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.$refs.input.focus();
      this.$refs.input.select();
    });
  },
  methods: {
    onCancel() {
      this.$emit("close");
    },
    onSubmit() {
      this.$emit("submit", this.circleName, this.isPersonal, this.isLocal);
    }
  }
};
var _sfc_render$3 = function render78() {
  var _vm = this, _c = _vm._self._c;
  return _c("Modal", { attrs: { "size": "normal" }, on: { "close": _vm.onCancel } }, [_c("div", { staticClass: "entity-picker" }, [_c("div", { staticClass: "entity-picker__new" }, [_c("input", { directives: [{ name: "model", rawName: "v-model", value: _vm.circleName, expression: "circleName" }], ref: "input", staticClass: "entity-picker__new-input", attrs: { "placeholder": _vm.t("contacts", "New team name"), "type": "text" }, domProps: { "value": _vm.circleName }, on: { "keypress": function($event) {
    if (!$event.type.indexOf("key") && _vm._k($event.keyCode, "enter", 13, $event.key, "Enter")) return null;
    return _vm.onSubmit.apply(null, arguments);
  }, "input": function($event) {
    if ($event.target.composing) return;
    _vm.circleName = $event.target.value;
  } } })]), _c("div", { staticClass: "entity-picker__content" }, [_c("p", [_vm._v(" " + _vm._s(_vm.CIRCLE_DESC))]), _c("br"), _vm._e(), _vm.isGlobalScale ? [_c("CheckboxRadioSwitch", { attrs: { "checked": _vm.isLocal, "disabled": _vm.loading !== false }, on: { "update:checked": function($event) {
    _vm.isLocal = $event;
  } } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Local team")) + " ")]), _c("p", [_vm._v(" " + _vm._s(_vm.t("contacts", "This team will not be shared with the other instances of the global scale")) + " ")])] : _vm._e()], 2), _c("div", { staticClass: "entity-picker__navigation" }, [_c("button", { staticClass: "navigation__button-left", attrs: { "disabled": _vm.loading }, on: { "click": _vm.onCancel } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Cancel")) + " ")]), _c("button", { staticClass: "navigation__button-right primary", attrs: { "disabled": _vm.isEmptyName || _vm.loading }, on: { "click": _vm.onSubmit } }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Create team")) + " ")])])])]);
};
var _sfc_staticRenderFns$3 = [];
var __component__$3 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$3,
  _sfc_render$3,
  _sfc_staticRenderFns$3,
  false,
  null,
  "30a6d125"
);
const NewCircleIntro = __component__$3.exports;
const isContactsInteractionEnabled = loadState("contacts", "isContactsInteractionEnabled", false);
const _sfc_main$2 = {
  name: "IconRecentlyContacted",
  props: {
    title: {
      type: String,
      default: ""
    },
    size: {
      type: Number,
      default: 20
    },
    fillColor: {
      type: String,
      default: "currentColor"
    }
  }
};
var _sfc_render$2 = function render79(_c, _vm) {
  return _c("span", _vm._g(_vm._b({ staticClass: "material-design-icon icon-recently-contacted", class: [_vm.data.class, _vm.data.staticClass], attrs: { "aria-hidden": !_vm.props.title, "aria-label": _vm.props.title, "role": "img" } }, "span", _vm.data.attrs, false), _vm.listeners), [_c("svg", { staticClass: "material-design-icon__svg", attrs: { "fill": _vm.props.fillColor, "width": _vm.props.size, "height": _vm.props.size, "viewBox": "0 0 16 16" } }, [_c("path", { attrs: { "d": "M0 0h24v24H0V0z", "fill": "none" } }), _c("path", { attrs: { "d": "M14 3v10h1V3zM12 13h1V3h-1zM1.7 3a.7.7 0 00-.7.7v8.6c0 .4.3.7.7.7h8.6c.4 0 .7-.3.7-.7V3.7a.7.7 0 00-.7-.7zM6 5a1.6 1.6 0 010 3.2A1.6 1.6 0 016 5zm0 4.4c1 0 3.2.6 3.2 1.6v.6H2.8V11c0-1 2.1-1.6 3.2-1.6z" } })])]);
};
var _sfc_staticRenderFns$2 = [];
var __component__$2 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$2,
  _sfc_render$2,
  _sfc_staticRenderFns$2,
  true,
  null,
  null
);
const IconRecentlyContacted = __component__$2.exports;
const _sfc_main$1 = {
  name: "RootNavigation",
  components: {
    ActionInput: NcActionInput,
    ActionText: NcActionText,
    NcActionButton,
    AppNavigation: NcAppNavigation,
    NcCounterBubble,
    AppNavigationItem: NcAppNavigationItem,
    AppNavigationCaption: NcAppNavigationCaption,
    CircleNavigationItem,
    Cog,
    ContactsSettings,
    GroupNavigationItem,
    IconContact,
    IconUser,
    IconAdd,
    IconError,
    IconLoading: NcLoadingIcon,
    IconRecentlyContacted,
    NewCircleIntro
  },
  mixins: [RouterMixin],
  props: {
    loading: {
      type: Boolean,
      default: true
    },
    contactsList: {
      type: Array,
      required: true
    }
  },
  data() {
    return {
      CIRCLE_DESC,
      CONTACTS_SETTINGS,
      ELLIPSIS_COUNT,
      GROUP_ALL_CONTACTS,
      CHART_ALL_CONTACTS,
      GROUP_NO_GROUP_CONTACTS,
      GROUP_RECENTLY_CONTACTED,
      // create group
      isNewGroupMenuOpen: false,
      createGroupError: null,
      // create circle
      isNewCircleModalOpen: false,
      createCircleLoading: false,
      createCircleError: null,
      isCirclesEnabled,
      isContactsInteractionEnabled,
      collapsedGroups: true,
      collapsedCircles: true,
      showSettings: false
    };
  },
  computed: {
    // store variables
    circles() {
      return this.$store.getters.getCircles;
    },
    contacts() {
      return this.$store.getters.getContacts;
    },
    groups() {
      return this.$store.getters.getGroups;
    },
    sortedContacts() {
      return this.$store.getters.getSortedContacts;
    },
    // list all the contacts that doesn't have a group
    ungroupedContacts() {
      return this.sortedContacts.filter((contact) => this.contacts[contact.key].groups && this.contacts[contact.key].groups.length === 0);
    },
    // check if any contact has manager, if not then is no need for organization chart menu
    existChart() {
      return !!Object.keys(this.contacts).filter((key) => this.contacts[key].managersName).length;
    },
    // generate groups menu from the groups store
    groupsMenu() {
      const menu = this.groups.map((group) => {
        return Object.assign({}, group, {
          id: group.name.replace(" ", "_"),
          key: group.name.replace(" ", "_"),
          router: {
            name: "group",
            params: { selectedGroup: group.name }
          },
          toString: () => group.name
        });
      });
      menu.sort((a, b) => naturalCompare$1(a.toString(), b.toString(), { caseInsensitive: true }));
      const recentlyIndex = menu.findIndex((group) => group.name === GROUP_RECENTLY_CONTACTED);
      if (recentlyIndex >= 0) {
        menu.splice(recentlyIndex, 1);
      }
      return menu;
    },
    ellipsisGroupsMenu() {
      if (this.isCirclesEnabled && this.collapsedGroups) {
        return this.groupsMenu.slice(0, ELLIPSIS_COUNT);
      }
      return this.groupsMenu;
    },
    // generate circles menu from the circles store
    circlesMenu() {
      const menu = this.circles || [];
      menu.sort((a, b) => {
        if (a?.initiator?.level !== b?.initiator?.level && a?.initiator?.level && b?.initiator?.level) {
          return b.initiator.level - a.initiator.level;
        }
        if (a.initiator && !b.initiator) {
          return -1;
        }
        if (!a.initiator && b.initiator) {
          return 1;
        }
        return naturalCompare$1(a.toString(), b.toString(), { caseInsensitive: true });
      });
      return menu;
    },
    ellipsisCirclesMenu() {
      if (this.collapsedCircles) {
        return this.circlesMenu.slice(0, ELLIPSIS_COUNT);
      }
      return this.circlesMenu;
    },
    // Recently contacted data
    recentlyContactedContacts() {
      return this.groups.find((group) => group.name === GROUP_RECENTLY_CONTACTED);
    },
    // Titles for the ellipsis toggle buttons
    collapseGroupsTitle() {
      return this.collapsedGroups ? t("contacts", "Show all groups") : t("contacts", "Collapse groups");
    },
    collapseCirclesTitle() {
      return this.collapsedCircles ? t("contacts", "Show all teams") : t("contacts", "Collapse teams");
    }
  },
  methods: {
    toggleNewGroupMenu() {
      this.isNewGroupMenuOpen = !this.isNewGroupMenuOpen;
    },
    createNewGroup(e2) {
      const input = e2.target.querySelector("input[type=text]");
      const groupName = input.value.trim();
      if (groupName.length === 0) {
        showError(t("contacts", "Group name cannot be empty"));
        return;
      }
      this.logger.debug("Creating new group", { groupName });
      if (this.groups.find((group) => group.name === groupName)) {
        this.createGroupError = t("contacts", "This group already exists");
        emit("contacts:group:append", this.groups.find((group) => group.name === groupName).name);
        return;
      }
      this.createGroupError = null;
      this.logger.debug("Created new local group", { groupName });
      try {
        this.$store.dispatch("addGroup", groupName);
        this.isNewGroupMenuOpen = false;
        emit("contacts:group:append", groupName);
      } catch (error) {
        showError(t("contacts", "An error occurred while creating the group"));
      }
    },
    // Ellipsis item toggles
    onToggleGroups() {
      this.collapsedGroups = !this.collapsedGroups;
    },
    onToggleCircles() {
      this.collapsedCircles = !this.collapsedCircles;
    },
    toggleNewCircleModal() {
      this.isNewCircleModalOpen = true;
    },
    async createNewCircle(circleName, isPersonal, isLocal) {
      this.logger.debug("Creating new team", { circleName });
      this.createCircleLoading = true;
      if (this.circles.find((circle) => circle.name === circleName)) {
        this.createCircleError = t("contacts", "This team already exists");
        return;
      }
      this.createCircleError = null;
      try {
        const circle = await this.$store.dispatch("createCircle", { circleName, isPersonal, isLocal });
        this.closeNewCircleIntro();
        this.$router.push({
          name: "circle",
          params: {
            selectedCircle: circle.id
          }
        });
      } catch (error) {
        showError(t("contacts", "An error happened during the creation of the team"));
      } finally {
        this.createCircleLoading = false;
      }
    },
    closeNewCircleIntro() {
      this.isNewCircleModalOpen = false;
    },
    /**
     * Shows the contacts settings
     */
    showContactsSettings() {
      this.showSettings = true;
    }
  }
};
var _sfc_render$1 = function render80() {
  var _vm = this, _c = _vm._self._c;
  return _c("AppNavigation", { scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_vm.loading ? _c("IconLoading", { attrs: { "size": 20 } }) : _vm._e()];
  }, proxy: true }, { key: "search", fn: function() {
    return [_c("header", { staticClass: "header" }, [_vm._t("default")], 2)];
  }, proxy: true }, { key: "list", fn: function() {
    return [_c("AppNavigationItem", { attrs: { "id": "everyone", "name": _vm.GROUP_ALL_CONTACTS, "to": {
      name: "group",
      params: { selectedGroup: _vm.GROUP_ALL_CONTACTS }
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconContact", { attrs: { "size": 20 } })];
    }, proxy: true }, { key: "counter", fn: function() {
      return [_vm.sortedContacts.length ? _c("NcCounterBubble", [_vm._v(" " + _vm._s(_vm.sortedContacts.length) + " ")]) : _vm._e()];
    }, proxy: true }]) }), _vm.existChart ? _c("AppNavigationItem", { attrs: { "id": "chart", "name": _vm.CHART_ALL_CONTACTS, "to": {
      name: "chart",
      params: { selectedChart: _vm.GROUP_ALL_CONTACTS }
    }, "icon": "icon-category-monitoring" } }) : _vm._e(), _vm.ungroupedContacts.length > 0 ? _c("AppNavigationItem", { attrs: { "id": "notgrouped", "name": _vm.GROUP_NO_GROUP_CONTACTS, "to": {
      name: "group",
      params: { selectedGroup: _vm.GROUP_NO_GROUP_CONTACTS }
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconUser", { attrs: { "size": 20 } })];
    }, proxy: true }, { key: "counter", fn: function() {
      return [_vm.ungroupedContacts.length ? _c("NcCounterBubble", [_vm._v(" " + _vm._s(_vm.ungroupedContacts.length) + " ")]) : _vm._e()];
    }, proxy: true }], null, false, 754420496) }) : _vm._e(), _vm.isContactsInteractionEnabled && _vm.recentlyContactedContacts && _vm.recentlyContactedContacts.contacts.length > 0 ? _c("AppNavigationItem", { attrs: { "id": "recentlycontacted", "name": _vm.GROUP_RECENTLY_CONTACTED, "to": {
      name: "group",
      params: { selectedGroup: _vm.GROUP_RECENTLY_CONTACTED }
    } }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
      return [_c("IconRecentlyContacted", { attrs: { "size": 20 } })];
    }, proxy: true }, { key: "counter", fn: function() {
      return [_vm.recentlyContactedContacts.contacts.length ? _c("NcCounterBubble", [_vm._v(" " + _vm._s(_vm.recentlyContactedContacts.contacts.length) + " ")]) : _vm._e()];
    }, proxy: true }], null, false, 1951174078) }) : _vm._e(), _c("AppNavigationCaption", { attrs: { "id": "newgroup", "force-menu": true, "menu-open": _vm.isNewGroupMenuOpen, "name": _vm.t("contacts", "Contact groups") }, on: { "update:menuOpen": function($event) {
      _vm.isNewGroupMenuOpen = $event;
    }, "update:menu-open": function($event) {
      _vm.isNewGroupMenuOpen = $event;
    }, "click": function($event) {
      $event.preventDefault();
      $event.stopPropagation();
      return _vm.toggleNewGroupMenu.apply(null, arguments);
    } }, scopedSlots: _vm._u([{ key: "actionsTriggerIcon", fn: function() {
      return [_c("IconAdd", { attrs: { "size": 20 } })];
    }, proxy: true }, { key: "actions", fn: function() {
      return [_c("ActionText", { directives: [{ name: "show", rawName: "v-show", value: _vm.isNewGroupMenuOpen, expression: "isNewGroupMenuOpen" }], scopedSlots: _vm._u([{ key: "icon", fn: function() {
        return [_vm.createGroupError ? _c("IconError", { attrs: { "size": 20 } }) : !_vm.createGroupError ? _c("IconContact", { attrs: { "size": 20 } }) : _vm._e()];
      }, proxy: true }]) }, [_vm._v(" " + _vm._s(_vm.createGroupError ? _vm.createGroupError : _vm.t("contacts", "Create a new contact group")) + " ")]), _c("ActionInput", { directives: [{ name: "show", rawName: "v-show", value: _vm.isNewGroupMenuOpen, expression: "isNewGroupMenuOpen" }], attrs: { "icon": "", "placeholder": _vm.t("contacts", "Contact group name") }, on: { "submit": function($event) {
        $event.preventDefault();
        $event.stopPropagation();
        return _vm.createNewGroup.apply(null, arguments);
      } } })];
    }, proxy: true }]) }), _vm._l(_vm.ellipsisGroupsMenu, function(group) {
      return _c("GroupNavigationItem", { key: group.key, attrs: { "group": group } });
    }), _vm.isCirclesEnabled ? [_vm.groupsMenu.length > _vm.ELLIPSIS_COUNT ? _c("AppNavigationItem", { staticClass: "app-navigation__collapse", attrs: { "name": _vm.collapseGroupsTitle, "icon": "" }, on: { "click": _vm.onToggleGroups } }) : _vm._e(), _c("AppNavigationCaption", { attrs: { "id": "newcircle", "name": _vm.t("contacts", "Teams") }, scopedSlots: _vm._u([{ key: "actions", fn: function() {
      return [_c("NcActionButton", { on: { "click": _vm.toggleNewCircleModal }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
        return [_c("IconAdd", { attrs: { "size": 20 } })];
      }, proxy: true }], null, false, 2388353250) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "Create a new team")) + " ")])];
    }, proxy: true }], null, false, 640863801) }), _vm.isNewCircleModalOpen ? _c("NewCircleIntro", { attrs: { "loading": _vm.createCircleLoading }, on: { "close": _vm.closeNewCircleIntro, "submit": _vm.createNewCircle } }) : _vm._e(), _vm.circlesMenu.length > 0 ? [_vm._l(_vm.ellipsisCirclesMenu, function(circle) {
      return _c("CircleNavigationItem", { key: circle.key, attrs: { "circle": circle } });
    }), _vm.circlesMenu.length > _vm.ELLIPSIS_COUNT ? _c("AppNavigationItem", { staticClass: "app-navigation__collapse", attrs: { "name": _vm.collapseCirclesTitle, "icon": "" }, on: { "click": _vm.onToggleCircles } }) : _vm._e()] : _vm._e(), _c("p", { staticClass: "app-navigation__circle-desc" }, [_vm._v(" " + _vm._s(_vm.CIRCLE_DESC) + " ")])] : _vm._e()];
  }, proxy: true }, { key: "footer", fn: function() {
    return [_c("div", { staticClass: "contacts-settings" }, [_c("AppNavigationItem", { attrs: { "aria-label": _vm.t("contacts", "Open the contacts app settings"), "name": _vm.CONTACTS_SETTINGS }, on: { "click": _vm.showContactsSettings } }, [_c("Cog", { attrs: { "slot": "icon", "size": 20 }, slot: "icon" })], 1)], 1)];
  }, proxy: true }], null, true) }, [_c("ContactsSettings", { attrs: { "open": _vm.showSettings }, on: { "update:open": function($event) {
    _vm.showSettings = $event;
  } } })], 1);
};
var _sfc_staticRenderFns$1 = [];
var __component__$1 = /* @__PURE__ */ normalizeComponent(
  _sfc_main$1,
  _sfc_render$1,
  _sfc_staticRenderFns$1,
  false,
  null,
  "76fa343d"
);
const RootNavigation = __component__$1.exports;
const _sfc_main = {
  name: "Contacts",
  components: {
    Button: NcButton,
    CircleContent,
    ChartContent,
    ContactsContent,
    ContactsPicker,
    Content: NcContent,
    ImportView,
    IconAdd,
    Modal: NcModal,
    RootNavigation,
    SettingsImportContacts
  },
  mixins: [
    index
  ],
  // passed by the router
  props: {
    selectedCircle: {
      type: String,
      default: void 0
    },
    selectedGroup: {
      type: String,
      default: void 0
    },
    selectedContact: {
      type: String,
      default: void 0
    },
    selectedChart: {
      type: String,
      default: void 0
    }
  },
  data() {
    return {
      // The object shorthand syntax is breaking builds (bug in @babel/preset-env)
      /* eslint-disable object-shorthand */
      appName,
      // Let's but the loading state to true if circles is enabled
      loadingCircles: isCirclesEnabled,
      loadingContacts: true
    };
  },
  computed: {
    // store getters
    addressbooks() {
      return this.$store.getters.getAddressbooks;
    },
    contacts() {
      return this.$store.getters.getContacts;
    },
    sortedContacts() {
      return this.$store.getters.getSortedContacts;
    },
    groups() {
      return this.$store.getters.getGroups;
    },
    circles() {
      return this.$store.getters.getCircles;
    },
    orderKey() {
      return this.$store.getters.getOrderKey;
    },
    importState() {
      return this.$store.getters.getImportState;
    },
    isEmptyGroup() {
      return this.contactsList.length === 0;
    },
    isChartView() {
      return !!this.selectedChart;
    },
    /**
     * Are we importing contacts ?
     *
     * @return {boolean}
     */
    isImporting() {
      return this.importState.stage !== "default";
    },
    /**
     * Are we done importing contacts ?
     *
     * @return {boolean}
     */
    isImportDone() {
      return this.importState.stage === "done";
    },
    // first enabled addressbook of the list
    defaultAddressbook() {
      return this.addressbooks.find((addressbook) => !addressbook.readOnly && addressbook.enabled);
    },
    /**
     * Contacts list based on the selected group.
     * Those filters are pretty fast, so let's only
     * intersect the groups contacts and the full
     * sorted contacts List.
     *
     * @return {Array}
     */
    contactsList() {
      if (this.selectedGroup === GROUP_ALL_CONTACTS) {
        return this.sortedContacts;
      } else if (this.selectedGroup === GROUP_NO_GROUP_CONTACTS) {
        return this.ungroupedContacts.map((contact) => this.sortedContacts.find((item) => item.key === contact.key));
      } else if (this.selectedGroup === ROUTE_CIRCLE) {
        return [];
      }
      const group = this.groups.filter((group2) => group2.name === this.selectedGroup)[0];
      if (group) {
        return this.sortedContacts.filter((contact) => group.contacts.indexOf(contact.key) >= 0);
      }
      return [];
    },
    isCirclesView() {
      return this.selectedGroup === ROUTE_CIRCLE;
    },
    ungroupedContacts() {
      return this.sortedContacts.filter((contact) => this.contacts[contact.key].groups && this.contacts[contact.key].groups.length === 0);
    }
  },
  watch: {
    // watch url change and group select
    selectedGroup() {
      if (!this.isMobile && !this.selectedChart) {
        this.selectFirstContactIfNone();
      }
    },
    // watch url change and contact select
    selectedContact() {
      if (!this.isMobile && !this.selectedChart) {
        this.selectFirstContactIfNone();
      }
    }
  },
  mounted() {
    if (this.isCirclesEnabled) {
      this.logger.info("Circles frontend enabled");
    } else {
      this.logger.info("No compatible version of circles found");
    }
  },
  async beforeMount() {
    client.connect({ enableCardDAV: true }).then(() => {
      this.logger.debug("Connected to dav!", { client });
      const principalsStore = usePrincipalsStore();
      principalsStore.setCurrentUserPrincipal(client);
      this.$store.dispatch("getAddressbooks").then((addressbooks) => {
        const writeableAddressBooks = addressbooks.filter((addressbook) => !addressbook.readOnly);
        if (writeableAddressBooks.length === 0) {
          this.$store.dispatch("appendAddressbook", { displayName: t("contacts", "Contacts") }).then(() => {
            this.fetchContacts();
          });
        } else {
          this.fetchContacts();
        }
      });
      if (localStorage.getItem("orderKey")) {
        this.$store.commit("setOrder", localStorage.getItem("orderKey"));
      }
    });
    if (isCirclesEnabled) {
      this.$store.dispatch("getCircles").then(() => {
        this.loadingCircles = false;
      });
    }
  },
  methods: {
    async newContact() {
      const rev = new ICALmodule.VCardTime();
      const contact = new Contact(
        `
				BEGIN:VCARD
				VERSION:4.0
				PRODID:-//Nextcloud Contacts v${appVersion}
				END:VCARD
			`.trim().replace(/\t/gm, ""),
        this.defaultAddressbook
      );
      contact.fullName = t("contacts", "Name");
      rev.fromUnixTime(Date.now() / 1e3);
      contact.rev = rev;
      const properties = rfcProps.properties;
      for (const name in properties) {
        if (properties[name].default) {
          const defaultData = properties[name].defaultValue;
          let defaultValue = defaultData.value;
          if (Array.isArray(defaultValue)) {
            defaultValue = [...defaultValue];
          }
          const property = contact.vCard.addPropertyWithValue(name, defaultValue);
          if (defaultData.type) {
            property.setParameter("type", defaultData.type);
          }
        }
      }
      if ([GROUP_ALL_CONTACTS, GROUP_NO_GROUP_CONTACTS].indexOf(this.selectedGroup) === -1) {
        contact.groups = [this.selectedGroup];
      }
      try {
        await this.$store.dispatch("addContact", contact);
        await this.$router.push({
          name: "contact",
          params: {
            selectedGroup: this.selectedGroup,
            selectedContact: contact.key
          }
        });
      } catch (error) {
        showError(t("contacts", "Unable to create the contact."));
        console.error(error);
      }
    },
    /**
     * Dispatch sorting update request to the store
     *
     * @param {string} orderKey the object key to order by
     */
    updateSorting(orderKey = "displayName") {
      this.$store.commit("setOrder", orderKey);
      this.$store.commit("sortContacts");
    },
    /**
     * Fetch the contacts of each addressbooks
     */
    fetchContacts() {
      Promise.all(
        this.addressbooks.map((addressbook) => {
          return this.$store.dispatch("getContactsFromAddressBook", { addressbook });
        })
      ).then(() => {
        this.loadingContacts = false;
        if (!this.isMobile && !this.selectedChart) {
          this.selectFirstContactIfNone();
        }
      });
    },
    /**
     * Select the first contact of the list
     * if none are selected already
     */
    selectFirstContactIfNone() {
      if (this.$route.name === "import") {
        return;
      }
      const inList = this.contactsList.findIndex((contact) => contact.key === this.selectedContact) > -1;
      if (this.selectedContact === void 0 || !inList) {
        if (this.selectedContact && !inList) {
          showError(t("contacts", "Contact not found"));
          this.$router.push({
            name: "group",
            params: {
              selectedGroup: this.selectedGroup
            }
          });
        }
        if (!this.selectedCircle && !this.groups.find((group) => group.name === this.selectedGroup) && GROUP_ALL_CONTACTS !== this.selectedGroup && GROUP_NO_GROUP_CONTACTS !== this.selectedGroup && ROUTE_CIRCLE !== this.selectedGroup) {
          showError(t("contacts", "Group {group} not found", { group: this.selectedGroup }));
          console.error("Group not found", this.selectedGroup);
          this.$router.push({
            name: "root"
          });
          return;
        }
        if (Object.keys(this.contactsList).length) {
          this.$router.push({
            name: "contact",
            params: {
              selectedGroup: this.selectedGroup,
              selectedContact: Object.values(this.contactsList)[0].key
            }
          });
        }
      }
    },
    /**
     * Done importing, the user closed the import status screen
     */
    closeImport() {
      this.$store.dispatch("changeStage", "default");
    }
  }
};
var _sfc_render = function render81() {
  var _vm = this, _c = _vm._self._c;
  return _c("Content", { attrs: { "app-name": _vm.appName } }, [_c("RootNavigation", { attrs: { "contacts-list": _vm.contactsList, "loading": _vm.loadingContacts || _vm.loadingCircles, "selected-group": _vm.selectedGroup, "selected-contact": _vm.selectedContact } }, [_c("div", { staticClass: "import-and-new-contact-buttons" }, [!_vm.loadingContacts && _vm.isEmptyGroup && !_vm.isChartView && !_vm.isCirclesView ? _c("SettingsImportContacts") : _vm._e(), !_vm.loadingContacts ? _c("Button", { attrs: { "type": "secondary", "wide": true, "disabled": !_vm.defaultAddressbook }, on: { "click": _vm.newContact }, scopedSlots: _vm._u([{ key: "icon", fn: function() {
    return [_c("IconAdd", { attrs: { "size": 20 } })];
  }, proxy: true }], null, false, 2388353250) }, [_vm._v(" " + _vm._s(_vm.t("contacts", "New contact")) + " ")]) : _vm._e()], 1)]), _vm.selectedCircle ? _c("CircleContent", { attrs: { "loading": _vm.loadingCircles } }) : _vm.selectedChart ? _c("ChartContent", { attrs: { "contacts-list": _vm.contacts } }) : _c("ContactsContent", { attrs: { "contacts-list": _vm.contactsList, "loading": _vm.loadingContacts }, on: { "new-contact": _vm.newContact } }), _vm.isImporting ? _c("Modal", { attrs: { "clear-view-delay": -1, "can-close": _vm.isImportDone }, on: { "close": _vm.closeImport } }, [_c("ImportView", { on: { "close": _vm.closeImport } })], 1) : _vm._e(), _c("ContactsPicker")], 1);
};
var _sfc_staticRenderFns = [];
var __component__ = /* @__PURE__ */ normalizeComponent(
  _sfc_main,
  _sfc_render,
  _sfc_staticRenderFns,
  false,
  null,
  "19e4e447"
);
const Contacts = __component__.exports;
Vue.use(VueRouter$1);
const router = new VueRouter$1({
  mode: "history",
  // if index.php is in the url AND we got this far, then it's working:
  // let's keep using index.php in the url
  base: _("/apps/contacts", ""),
  linkActiveClass: "active",
  routes: [
    {
      path: "/",
      component: Contacts,
      props: true,
      name: "root",
      // always load default group
      redirect: {
        name: "group",
        params: { selectedGroup: t("contacts", "All contacts") }
      },
      children: [
        {
          path: `/${ROUTE_CHART}/:selectedChart`,
          name: "chart",
          component: Contacts
        },
        {
          path: "import",
          name: "import",
          component: Contacts
        },
        {
          path: `${ROUTE_CIRCLE}/:selectedCircle`,
          name: "circle",
          component: Contacts
        },
        {
          path: ":selectedGroup",
          name: "group",
          component: Contacts
        },
        {
          path: ":selectedGroup/:selectedContact",
          name: "contact",
          component: Contacts
        }
      ]
    }
  ]
});
Vue.use(PiniaVuePlugin);
const pinia = createPinia();
Vue.directive("ClickOutside", ClickOutside);
Vue.directive("Tooltip", VTooltip);
sync(store, router);
Vue.prototype.t = t;
Vue.prototype.n = n;
Vue.prototype.appName = appName;
Vue.prototype.appVersion = appVersion;
Vue.prototype.logger = logger$1;
Vue.prototype.OC = window.OC;
Vue.prototype.OCA = window.OCA;
if (window.location.pathname.split("/")[1] === "index.php" && window.OC.config.modRewriteWorking) {
  router.push({
    name: "group",
    params: { selectedGroup: t("contacts", "All contacts") }
  });
}
new Vue({
  el: "#content",
  name: "ContactsApp",
  router,
  store,
  render: (h) => h(App),
  pinia
});
//# sourceMappingURL=contacts-main.mjs.map
