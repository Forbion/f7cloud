import { AxiosResponse } from 'axios';
import { ComponentOptionsMixin } from 'vue';
import { default as default_2 } from 'p-cancelable';
import { default as default_3 } from 'vue';
import { Entry } from '@nextcloud/files';
import { ExtendedVue } from 'vue/types/vue';
import { Folder } from '@nextcloud/files';
import { InvalidFilenameError } from '@nextcloud/files';
import { Node as Node_2 } from '@nextcloud/files';

export declare interface ConflictPickerOptions {
    /**
     * When this is set to true a hint is shown that conflicts in directories are handles recursivly
     * You still need to call this function for each directory separatly.
     */
    recursive?: boolean;
}

export declare type ConflictResolutionResult<T extends File | FileSystemEntry | Node_2> = {
    selected: T[];
    renamed: T[];
};

/**
 * SPDX-FileCopyrightText: 2024 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
/**
 * Helpers to generate a file tree when the File and Directory API is used (e.g. Drag and Drop or <input type="file" webkitdirectory>)
 */
/**
 * This is a helper class to allow building a file tree for uploading
 * It allows to create virtual directories
 */
export declare class Directory extends File {
    private _originalName;
    private _path;
    private _children;
    constructor(path: string, children?: Array<File | FileSystemEntry>);
    get size(): number;
    get lastModified(): number;
    get originalName(): string;
    get children(): Array<File | Directory>;
    get webkitRelativePath(): string;
    getChild(name: string): File | Directory | null;
    addChild(file: File | FileSystemEntry): Promise<void>;
}

/**
 * Get the conflicts between two sets of files
 * @param {Array<File|FileSystemEntry|Node>} files the incoming files
 * @param {Node[]} content all the existing files in the directory
 * @return {boolean} true if there is a conflict
 */
export declare function getConflicts<T extends File | FileSystemEntry | Node_2>(files: T[], content: Node_2[]): T[];

/**
 * Get the global Uploader instance.
 *
 * Note: If you need a local uploader you can just create a new instance,
 * this global instance will be shared with other apps.
 *
 * @param isPublic Set to true to use public upload endpoint (by default it is auto detected)
 * @param forceRecreate Force a new uploader instance - main purpose is for testing
 */
export declare function getUploader(isPublic?: boolean, forceRecreate?: boolean): Uploader;

/**
 * Check if there is a conflict between two sets of files
 * @param {Array<File|FileSystemEntry|Node>} files the incoming files
 * @param {Node[]} content all the existing files in the directory
 * @return {boolean} true if there is a conflict
 */
export declare function hasConflict(files: (File | FileSystemEntry | Node_2)[], content: Node_2[]): boolean;

/**
 * Interface of the internal Directory class
 */
export declare type IDirectory = Pick<Directory, keyof Directory>;

/**
 * Open the conflict resolver
 * @param {string} dirname the directory name
 * @param {(File|Node)[]} conflicts the incoming files
 * @param {Node[]} content all the existing files in the directory
 * @param {ConflictPickerOptions} options Optional settings for the conflict picker
 * @return {Promise<ConflictResolutionResult>} the selected and renamed files
 */
export declare function openConflictPicker<T extends File | FileSystemEntry | Node_2>(dirname: string | undefined, conflicts: T[], content: Node_2[], options?: ConflictPickerOptions): Promise<ConflictResolutionResult<T>>;

export declare class Upload {
    private _source;
    private _file;
    private _isChunked;
    private _chunks;
    private _size;
    private _uploaded;
    private _startTime;
    private _status;
    private _controller;
    private _response;
    constructor(source: string, chunked: boolean | undefined, size: number, file: File);
    get source(): string;
    get file(): File;
    get isChunked(): boolean;
    get chunks(): number;
    get size(): number;
    get startTime(): number;
    set response(response: AxiosResponse | null);
    get response(): AxiosResponse | null;
    get uploaded(): number;
    /**
     * Update the uploaded bytes of this upload
     */
    set uploaded(length: number);
    get status(): number;
    /**
     * Update this upload status
     */
    set status(status: UploadStatus);
    /**
     * Returns the axios cancel token source
     */
    get signal(): AbortSignal;
    /**
     * Cancel any ongoing requests linked to this upload
     */
    cancel(): void;
}

/**
 * Upload a file
 * This will init an Uploader instance if none exists.
 * You will be able to retrieve it with `getUploader`
 *
 * @param {string} destinationPath the destination path
 * @param {File} file the file to upload
 * @return {Uploader} the uploader instance
 */
export declare function upload(destinationPath: string, file: File): Uploader;

export declare class Uploader {
    private _destinationFolder;
    private _isPublic;
    private _customHeaders;
    private _uploadQueue;
    private _jobQueue;
    private _queueSize;
    private _queueProgress;
    private _queueStatus;
    private _notifiers;
    /**
     * Initialize uploader
     *
     * @param {boolean} isPublic are we in public mode ?
     * @param {Folder} destinationFolder the context folder to operate, relative to the root folder
     */
    constructor(isPublic?: boolean, destinationFolder?: Folder);
    /**
     * Get the upload destination path relative to the root folder
     */
    get destination(): Folder;
    /**
     * Set the upload destination path relative to the root folder
     */
    set destination(folder: Folder);
    /**
     * Get the root folder
     */
    get root(): string;
    /**
     * Get registered custom headers for uploads
     */
    get customHeaders(): Record<string, string>;
    /**
     * Set a custom header
     * @param name The header to set
     * @param value The string value
     */
    setCustomHeader(name: string, value?: string): void;
    /**
     * Unset a custom header
     * @param name The header to unset
     */
    deleteCustomerHeader(name: string): void;
    /**
     * Get the upload queue
     */
    get queue(): Upload[];
    private reset;
    /**
     * Pause any ongoing upload(s)
     */
    pause(): void;
    /**
     * Resume any pending upload(s)
     */
    start(): void;
    /**
     * Get the upload queue stats
     */
    get info(): {
        size: number;
        progress: number;
        status: UploaderStatus;
    };
    private updateStats;
    addNotifier(notifier: (upload: Upload) => void): void;
    /**
     * Notify listeners of the upload completion
     * @param upload The upload that finished
     */
    private _notifyAll;
    /**
     * Uploads multiple files or folders while preserving the relative path (if available)
     * @param {string} destination The destination path relative to the root folder. e.g. /foo/bar (a file "a.txt" will be uploaded then to "/foo/bar/a.txt")
     * @param {Array<File|FileSystemEntry>} files The files and/or folders to upload
     * @param {Function} callback Callback that receives the nodes in the current folder and the current path to allow resolving conflicts, all nodes that are returned will be uploaded (if a folder does not exist it will be created)
     * @return Cancelable promise that resolves to an array of uploads
     *
     * @example
     * ```ts
     * // For example this is from handling the onchange event of an input[type=file]
     * async handleFiles(files: File[]) {
     *   this.uploads = await this.uploader.batchUpload('uploads', files, this.handleConflicts)
     * }
     *
     * async handleConflicts(nodes: File[], currentPath: string) {
     *   const conflicts = getConflicts(nodes, this.fetchContent(currentPath))
     *   if (conflicts.length === 0) {
     *     // No conflicts so upload all
     *     return nodes
     *   } else {
     *     // Open the conflict picker to resolve conflicts
     *     try {
     *       const { selected, renamed } = await openConflictPicker(currentPath, conflicts, this.fetchContent(currentPath), { recursive: true })
     *       return [...selected, ...renamed]
     *     } catch (e) {
     *       return false
     *     }
     *   }
     * }
     * ```
     */
    batchUpload(destination: string, files: (File | FileSystemEntry)[], callback?: (nodes: Array<File | IDirectory>, currentPath: string) => Promise<Array<File | IDirectory> | false>): default_2<Upload[]>;
    /**
     * Helper to create a directory wrapped inside an Upload class
     * @param destination Destination where to create the directory
     * @param directory The directory to create
     * @param client The cached WebDAV client
     */
    private createDirectory;
    private uploadDirectory;
    /**
     * Upload a file to the given path
     * @param {string} destination the destination path relative to the root folder. e.g. /foo/bar.txt
     * @param {File|FileSystemFileEntry} fileHandle the file to upload
     * @param {string} root the root folder to upload to
     * @param retries number of retries
     */
    upload(destination: string, fileHandle: File | FileSystemFileEntry, root?: string, retries?: number): default_2<Upload>;
}

export declare enum UploaderStatus {
    IDLE = 0,
    UPLOADING = 1,
    PAUSED = 2
}

export declare const UploadPicker: ExtendedVue<default_3<Record<string, any>, Record<string, any>, never, never, (event: string, ...args: any[]) => default_3>, {
eta: null;
timeLeft: string;
newFileMenuEntries: Entry[];
uploadManager: Uploader;
}, {
/**
* Handle clicking a new-menu entry
* @param entry The entry that was clicked
*/
onClick(entry: Entry): Promise<void>;
/**
* Trigger file picker
* @param uploadFolders Upload folders
*/
onTriggerPick(uploadFolders?: boolean): void;
/**
* Helper for backwards compatibility that queries the content of the current directory
* @param path The current path
*/
getContent(path?: string): Promise<Node_2[]>;
/**
* Show a dialog to let the user decide how to proceed with invalid filenames.
* The returned promise resolves to false if the file should be skipped, and resolves to a string if it should be renamed.
* The promise rejects when the user want to abort the operation.
*
* @param error the validation error
*/
showInvalidFileNameDialog(error: InvalidFilenameError): Promise<string | false>;
/**
* Wrapper to allow overwriting forbidden characters
* Remove with next major
* @param filename name to validate
*/
validateFilename(filename: string): void;
handleConflicts(nodes: Array<File | Directory>, path: string): Promise<Array<File | Directory> | false>;
/**
* Start uploading
*/
onPick(): void;
resetForm(): void;
/**
* Cancel ongoing queue
*/
onCancel(): void;
updateStatus(): void;
setDestination(destination: Folder): void;
onUploadCompletion(upload: Upload): void;
}, {
menuEntriesUpload: Entry[];
menuEntriesNew: Entry[];
menuEntriesOther: Entry[];
canUploadFolders: boolean;
totalQueueSize: number;
uploadedQueueSize: number;
progress: number;
queue: Upload[];
hasFailure: boolean;
isUploading: boolean;
isAssembling: boolean;
isPaused: boolean;
buttonLabel: string;
buttonName: any;
}, {
accept: string[];
disabled: boolean;
multiple: boolean;
noMenu: boolean;
destination: Folder | undefined;
allowFolders: boolean;
content: Node_2[] | ((relativePath?: string) => Node_2[] | PromiseLike<Node_2[]>);
forbiddenCharacters: string[];
}, {
t: (original: string, placeholders?: Record<string, string | number>) => string;
progressTimeId: string;
}, ComponentOptionsMixin, ComponentOptionsMixin>;

export declare enum UploadStatus {
    INITIALIZED = 0,
    UPLOADING = 1,
    ASSEMBLING = 2,
    FINISHED = 3,
    CANCELLED = 4,
    FAILED = 5
}

export { }
