{"version":3,"file":"talk-JitsiEncryptionWorker.worker.worker.js?v=eefe07c7d06f02b82c0a","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack:///talk/src/utils/e2ee/JitsiEncryptionWorkerContext.js","webpack:///talk/src/utils/e2ee/crypto-utils.js","webpack:///talk/webpack/bootstrap","webpack:///talk/webpack/runtime/define property getters","webpack:///talk/webpack/runtime/hasOwnProperty shorthand","webpack:///talk/webpack/runtime/make namespace object","webpack:///talk/src/utils/e2ee/JitsiEncryptionWorker.worker.js"],"sourcesContent":["import { deriveKeys, importKey, ratchet } from \"./crypto-utils.js\";\nconst KEYRING_SIZE = 16;\nconst UNENCRYPTED_BYTES = {\n  key: 10,\n  delta: 3,\n  undefined: 1\n  // frame.type is not set on audio\n};\nconst ENCRYPTION_ALGORITHM = \"AES-GCM\";\nconst IV_LENGTH = 12;\nconst RATCHET_WINDOW_SIZE = 8;\nexport class Context {\n  /**\n   * @param {Object} options\n   */\n  constructor({ sharedKey = false } = {}) {\n    this._cryptoKeyRing = new Array(KEYRING_SIZE);\n    this._currentKeyIndex = -1;\n    this._sendCounts = /* @__PURE__ */ new Map();\n    this._sharedKey = sharedKey;\n  }\n  /**\n   * Derives the different subkeys and starts using them for encryption or\n   * decryption.\n   * @param {Uint8Array|false} key bytes. Pass false to disable.\n   * @param {Number} keyIndex\n   */\n  async setKey(key, keyIndex = -1) {\n    let newKey = false;\n    if (key) {\n      if (this._sharedKey) {\n        newKey = key;\n      } else {\n        const material = await importKey(key);\n        newKey = await deriveKeys(material);\n      }\n    }\n    this._setKeys(newKey, keyIndex);\n  }\n  /**\n   * Sets a set of keys and resets the sendCount.\n   * decryption.\n   * @param {Object} keys set of keys.\n   * @param {Number} keyIndex optional\n   * @private\n   */\n  _setKeys(keys, keyIndex = -1) {\n    if (keyIndex >= 0) {\n      this._currentKeyIndex = keyIndex % this._cryptoKeyRing.length;\n    }\n    this._cryptoKeyRing[this._currentKeyIndex] = keys;\n    this._sendCount = BigInt(0);\n  }\n  /**\n   * Function that will be injected in a stream and will encrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   *\n   * The VP8 payload descriptor described in\n   * https://tools.ietf.org/html/rfc7741#section-4.2\n   * is part of the RTP packet and not part of the frame and is not controllable by us.\n   * This is fine as the SFU keeps having access to it for routing.\n   *\n   * The encrypted frame is formed as follows:\n   * 1) Leave the first (10, 3, 1) bytes unencrypted, depending on the frame type and kind.\n   * 2) Form the GCM IV for the frame as described above.\n   * 3) Encrypt the rest of the frame using AES-GCM.\n   * 4) Allocate space for the encrypted frame.\n   * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n   * 6) Append the ciphertext to the encrypted frame.\n   * 7) Append the IV.\n   * 8) Append a single byte for the key identifier.\n   * 9) Enqueue the encrypted frame for sending.\n   */\n  encodeFunction(encodedFrame, controller) {\n    const keyIndex = this._currentKeyIndex;\n    if (this._cryptoKeyRing[keyIndex]) {\n      const iv = this._makeIV(encodedFrame.getMetadata().synchronizationSource, encodedFrame.timestamp);\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, UNENCRYPTED_BYTES[encodedFrame.type]);\n      const frameTrailer = new Uint8Array(2);\n      frameTrailer[0] = IV_LENGTH;\n      frameTrailer[1] = keyIndex;\n      return crypto.subtle.encrypt({\n        name: ENCRYPTION_ALGORITHM,\n        iv,\n        additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n      }, this._cryptoKeyRing[keyIndex].encryptionKey, new Uint8Array(\n        encodedFrame.data,\n        UNENCRYPTED_BYTES[encodedFrame.type]\n      )).then((cipherText) => {\n        const newData = new ArrayBuffer(frameHeader.byteLength + cipherText.byteLength + iv.byteLength + frameTrailer.byteLength);\n        const newUint8 = new Uint8Array(newData);\n        newUint8.set(frameHeader);\n        newUint8.set(new Uint8Array(cipherText), frameHeader.byteLength);\n        newUint8.set(new Uint8Array(iv), frameHeader.byteLength + cipherText.byteLength);\n        newUint8.set(\n          frameTrailer,\n          frameHeader.byteLength + cipherText.byteLength + iv.byteLength\n        );\n        encodedFrame.data = newData;\n        return controller.enqueue(encodedFrame);\n      }, (e) => {\n        console.error(e);\n      });\n    }\n    controller.enqueue(encodedFrame);\n  }\n  /**\n   * Function that will be injected in a stream and will decrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   */\n  async decodeFunction(encodedFrame, controller) {\n    const data = new Uint8Array(encodedFrame.data);\n    const keyIndex = data[encodedFrame.data.byteLength - 1];\n    if (this._cryptoKeyRing[keyIndex]) {\n      const decodedFrame = await this._decryptFrame(\n        encodedFrame,\n        keyIndex\n      );\n      if (decodedFrame) {\n        controller.enqueue(decodedFrame);\n      }\n    }\n  }\n  /**\n   * Function that will decrypt the given encoded frame. If the decryption fails, it will\n   * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {number} keyIndex - the index of the decryption data in _cryptoKeyRing array.\n   * @param {number} ratchetCount - the number of retries after ratcheting the key.\n   * @returns {Promise<RTCEncodedVideoFrame|RTCEncodedAudioFrame>} - The decrypted frame.\n   * @private\n   */\n  async _decryptFrame(encodedFrame, keyIndex, initialKey = void 0, ratchetCount = 0) {\n    const { encryptionKey } = this._cryptoKeyRing[keyIndex];\n    let { material } = this._cryptoKeyRing[keyIndex];\n    try {\n      const frameHeader = new Uint8Array(encodedFrame.data, 0, UNENCRYPTED_BYTES[encodedFrame.type]);\n      const frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2);\n      const ivLength = frameTrailer[0];\n      const iv = new Uint8Array(\n        encodedFrame.data,\n        encodedFrame.data.byteLength - ivLength - frameTrailer.byteLength,\n        ivLength\n      );\n      const cipherTextStart = frameHeader.byteLength;\n      const cipherTextLength = encodedFrame.data.byteLength - (frameHeader.byteLength + ivLength + frameTrailer.byteLength);\n      const plainText = await crypto.subtle.decrypt(\n        {\n          name: \"AES-GCM\",\n          iv,\n          additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n        },\n        encryptionKey,\n        new Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength)\n      );\n      const newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength);\n      const newUint8 = new Uint8Array(newData);\n      newUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength));\n      newUint8.set(new Uint8Array(plainText), frameHeader.byteLength);\n      encodedFrame.data = newData;\n      return encodedFrame;\n    } catch (error) {\n      if (this._sharedKey) {\n        return;\n      }\n      if (ratchetCount < RATCHET_WINDOW_SIZE) {\n        const currentKey = this._cryptoKeyRing[this._currentKeyIndex];\n        material = await importKey(await ratchet(material));\n        const newKey = await deriveKeys(material);\n        this._setKeys(newKey);\n        return await this._decryptFrame(\n          encodedFrame,\n          keyIndex,\n          initialKey || currentKey,\n          ratchetCount + 1\n        );\n      }\n      this._setKeys(initialKey);\n    }\n  }\n  /**\n   * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n   * https://tools.ietf.org/html/rfc7714#section-8.1\n   * It concatenates\n   * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n   * - the 32 bit rtp timestamp given on the encoded frame,\n   * - a send counter that is specific to the SSRC. Starts at a random number.\n   * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n   * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n   * randomly generated and SFUs may not rewrite this is considered acceptable.\n   * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n   *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n   * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n   * opus audio) every second. For video it rolls over roughly every 13 hours.\n   * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n   * every second. It will take a long time to roll over.\n   *\n   * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n   */\n  _makeIV(synchronizationSource, timestamp) {\n    const iv = new ArrayBuffer(IV_LENGTH);\n    const ivView = new DataView(iv);\n    if (!this._sendCounts.has(synchronizationSource)) {\n      this._sendCounts.set(synchronizationSource, Math.floor(Math.random() * 65535));\n    }\n    const sendCount = this._sendCounts.get(synchronizationSource);\n    ivView.setUint32(0, synchronizationSource);\n    ivView.setUint32(4, timestamp);\n    ivView.setUint32(8, sendCount % 65535);\n    this._sendCounts.set(synchronizationSource, sendCount + 1);\n    return iv;\n  }\n}\n","export async function deriveKeys(material) {\n  const info = new ArrayBuffer();\n  const textEncoder = new TextEncoder();\n  const encryptionKey = await crypto.subtle.deriveKey({\n    name: \"HKDF\",\n    salt: textEncoder.encode(\"TalkFrameEncryptionKey\"),\n    hash: \"SHA-256\",\n    info\n  }, material, {\n    name: \"AES-GCM\",\n    length: 128\n  }, false, [\"encrypt\", \"decrypt\"]);\n  return {\n    material,\n    encryptionKey\n  };\n}\nexport async function ratchet(material) {\n  const textEncoder = new TextEncoder();\n  return crypto.subtle.deriveBits({\n    name: \"HKDF\",\n    salt: textEncoder.encode(\"TalkFrameRatchetKey\"),\n    hash: \"SHA-256\",\n    info: new ArrayBuffer()\n  }, material, 256);\n}\nexport async function importKey(keyBytes) {\n  return crypto.subtle.importKey(\"raw\", keyBytes, \"HKDF\", false, [\"deriveBits\", \"deriveKey\"]);\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * SPDX-FileCopyrightText: 2020 Jitsi team at 8x8 and the community.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Based on code from https://github.com/jitsi/jitsi-meet\n */\n\n// Worker for E2EE/Insertable streams.\n\nimport { Context } from './JitsiEncryptionWorkerContext.js'\n\nconst contexts = new Map() // Map participant id => context\n\nlet sharedContext\n\n/**\n * Retrieves the participant {@code Context}, creating it if necessary.\n *\n * @param {string} participantId - The participant whose context we need.\n * @returns {Object} The context.\n */\nfunction getParticipantContext(participantId) {\n\tif (sharedContext) {\n\t\treturn sharedContext\n\t}\n\n\tif (!contexts.has(participantId)) {\n\t\tcontexts.set(participantId, new Context())\n\t}\n\n\treturn contexts.get(participantId)\n}\n\n/**\n * Sets an encode / decode transform.\n *\n * @param {Object} context - The participant context where the transform will be applied.\n * @param {string} operation - Encode / decode.\n * @param {Object} readableStream - Readable stream part.\n * @param {Object} writableStream - Writable stream part.\n */\nfunction handleTransform(context, operation, readableStream, writableStream) {\n\tif (operation === 'encode' || operation === 'decode') {\n\t\tconst transformFn = operation === 'encode' ? context.encodeFunction : context.decodeFunction\n\t\tconst transformStream = new TransformStream({\n\t\t\ttransform: transformFn.bind(context),\n\t\t})\n\n\t\treadableStream\n\t\t\t.pipeThrough(transformStream)\n\t\t\t.pipeTo(writableStream)\n\t} else {\n\t\tconsole.error(`Invalid operation: ${operation}`)\n\t}\n}\n\nonmessage = async (event) => {\n\tconst { operation } = event.data\n\n\tif (operation === 'initialize') {\n\t\tconst { sharedKey } = event.data\n\n\t\tif (sharedKey) {\n\t\t\tsharedContext = new Context({ sharedKey })\n\t\t}\n\t} else if (operation === 'encode' || operation === 'decode') {\n\t\tconst { readableStream, writableStream, participantId } = event.data\n\t\tconst context = getParticipantContext(participantId)\n\n\t\thandleTransform(context, operation, readableStream, writableStream)\n\t} else if (operation === 'setKey') {\n\t\tconst { participantId, key, keyIndex } = event.data\n\t\tconst context = getParticipantContext(participantId)\n\n\t\tif (key) {\n\t\t\tcontext.setKey(key, keyIndex)\n\t\t} else {\n\t\t\tcontext.setKey(false, keyIndex)\n\t\t}\n\t} else if (operation === 'cleanup') {\n\t\tconst { participantId } = event.data\n\n\t\tcontexts.delete(participantId)\n\t} else if (operation === 'cleanupAll') {\n\t\tcontexts.clear()\n\t} else {\n\t\tconsole.error('e2ee worker', operation)\n\t}\n}\n\n// Operations using RTCRtpScriptTransform.\nif (self.RTCTransformEvent) {\n\tself.onrtctransform = (event) => {\n\t\tconst transformer = event.transformer\n\t\tconst { operation, participantId } = transformer.options\n\t\tconst context = getParticipantContext(participantId)\n\n\t\thandleTransform(context, operation, transformer.readable, transformer.writable)\n\t}\n}\n"],"names":[],"sourceRoot":""}