{"version":3,"file":"calendar-vendors-node_modules_pinia_dist_pinia_mjs.js?v=4fcd7de46abb76dcee18","mappings":"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","sources":["webpack:///calendar/node_modules/vue-demi/lib/index.mjs","webpack:///calendar/node_modules/@vue/devtools-api/lib/esm/env.js","webpack:///calendar/node_modules/@vue/devtools-api/lib/esm/const.js","webpack:///calendar/node_modules/@vue/devtools-api/lib/esm/time.js","webpack:///calendar/node_modules/@vue/devtools-api/lib/esm/proxy.js","webpack:///calendar/node_modules/@vue/devtools-api/lib/esm/index.js","webpack:///calendar/node_modules/pinia/dist/pinia.mjs"],"sourcesContent":["import Vue from 'vue'\nimport { getCurrentInstance } from 'vue'\n\nvar isVue2 = true\nvar isVue3 = false\nvar Vue2 = Vue\nvar warn = Vue.util.warn\n\nfunction install() {}\n\n// createApp polyfill\nexport function createApp(rootComponent, rootProps) {\n  var vm\n  var provide = {}\n  var app = {\n    config: Vue.config,\n    use: Vue.use.bind(Vue),\n    mixin: Vue.mixin.bind(Vue),\n    component: Vue.component.bind(Vue),\n    provide: function (key, value) {\n      provide[key] = value\n      return this\n    },\n    directive: function (name, dir) {\n      if (dir) {\n        Vue.directive(name, dir)\n        return app\n      } else {\n        return Vue.directive(name)\n      }\n    },\n    mount: function (el, hydrating) {\n      if (!vm) {\n        vm = new Vue(Object.assign({ propsData: rootProps }, rootComponent, { provide: Object.assign(provide, rootComponent.provide) }))\n        vm.$mount(el, hydrating)\n        return vm\n      } else {\n        return vm\n      }\n    },\n    unmount: function () {\n      if (vm) {\n        vm.$destroy()\n        vm = undefined\n      }\n    },\n  }\n  return app\n}\n\nexport {\n  Vue,\n  Vue2,\n  isVue2,\n  isVue3,\n  install,\n  warn\n}\n\n// Vue 3 components mock\nfunction createMockComponent(name) {\n  return {\n    setup() {\n      throw new Error('[vue-demi] ' + name + ' is not supported in Vue 2. It\\'s provided to avoid compiler errors.')\n    }\n  }\n}\nexport var Fragment = /*#__PURE__*/ createMockComponent('Fragment')\nexport var Transition = /*#__PURE__*/ createMockComponent('Transition')\nexport var TransitionGroup = /*#__PURE__*/ createMockComponent('TransitionGroup')\nexport var Teleport = /*#__PURE__*/ createMockComponent('Teleport')\nexport var Suspense = /*#__PURE__*/ createMockComponent('Suspense')\nexport var KeepAlive = /*#__PURE__*/ createMockComponent('KeepAlive')\n\nexport * from 'vue'\n\n// Not implemented https://github.com/vuejs/core/pull/8111, falls back to getCurrentInstance()\nexport function hasInjectionContext() {\n  return !!getCurrentInstance()\n}\n","export function getDevtoolsGlobalHook() {\n    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;\n}\nexport function getTarget() {\n    // @ts-expect-error navigator and windows are not available in all environments\n    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')\n        ? window\n        : typeof globalThis !== 'undefined'\n            ? globalThis\n            : {};\n}\nexport const isProxyAvailable = typeof Proxy === 'function';\n","export const HOOK_SETUP = 'devtools-plugin:setup';\nexport const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';\n","let supported;\nlet perf;\nexport function isPerformanceSupported() {\n    var _a;\n    if (supported !== undefined) {\n        return supported;\n    }\n    if (typeof window !== 'undefined' && window.performance) {\n        supported = true;\n        perf = window.performance;\n    }\n    else if (typeof globalThis !== 'undefined' && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {\n        supported = true;\n        perf = globalThis.perf_hooks.performance;\n    }\n    else {\n        supported = false;\n    }\n    return supported;\n}\nexport function now() {\n    return isPerformanceSupported() ? perf.now() : Date.now();\n}\n","import { HOOK_PLUGIN_SETTINGS_SET } from './const.js';\nimport { now } from './time.js';\nexport class ApiProxy {\n    constructor(plugin, hook) {\n        this.target = null;\n        this.targetQueue = [];\n        this.onQueue = [];\n        this.plugin = plugin;\n        this.hook = hook;\n        const defaultSettings = {};\n        if (plugin.settings) {\n            for (const id in plugin.settings) {\n                const item = plugin.settings[id];\n                defaultSettings[id] = item.defaultValue;\n            }\n        }\n        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;\n        let currentSettings = Object.assign({}, defaultSettings);\n        try {\n            const raw = localStorage.getItem(localSettingsSaveId);\n            const data = JSON.parse(raw);\n            Object.assign(currentSettings, data);\n        }\n        catch (e) {\n            // noop\n        }\n        this.fallbacks = {\n            getSettings() {\n                return currentSettings;\n            },\n            setSettings(value) {\n                try {\n                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));\n                }\n                catch (e) {\n                    // noop\n                }\n                currentSettings = value;\n            },\n            now() {\n                return now();\n            },\n        };\n        if (hook) {\n            hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {\n                if (pluginId === this.plugin.id) {\n                    this.fallbacks.setSettings(value);\n                }\n            });\n        }\n        this.proxiedOn = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target.on[prop];\n                }\n                else {\n                    return (...args) => {\n                        this.onQueue.push({\n                            method: prop,\n                            args,\n                        });\n                    };\n                }\n            },\n        });\n        this.proxiedTarget = new Proxy({}, {\n            get: (_target, prop) => {\n                if (this.target) {\n                    return this.target[prop];\n                }\n                else if (prop === 'on') {\n                    return this.proxiedOn;\n                }\n                else if (Object.keys(this.fallbacks).includes(prop)) {\n                    return (...args) => {\n                        this.targetQueue.push({\n                            method: prop,\n                            args,\n                            resolve: () => { },\n                        });\n                        return this.fallbacks[prop](...args);\n                    };\n                }\n                else {\n                    return (...args) => {\n                        return new Promise((resolve) => {\n                            this.targetQueue.push({\n                                method: prop,\n                                args,\n                                resolve,\n                            });\n                        });\n                    };\n                }\n            },\n        });\n    }\n    async setRealTarget(target) {\n        this.target = target;\n        for (const item of this.onQueue) {\n            this.target.on[item.method](...item.args);\n        }\n        for (const item of this.targetQueue) {\n            item.resolve(await this.target[item.method](...item.args));\n        }\n    }\n}\n","import { getDevtoolsGlobalHook, getTarget, isProxyAvailable } from './env.js';\nimport { HOOK_SETUP } from './const.js';\nimport { ApiProxy } from './proxy.js';\nexport * from './api/index.js';\nexport * from './plugin.js';\nexport * from './time.js';\nexport function setupDevtoolsPlugin(pluginDescriptor, setupFn) {\n    const descriptor = pluginDescriptor;\n    const target = getTarget();\n    const hook = getDevtoolsGlobalHook();\n    const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;\n    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {\n        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);\n    }\n    else {\n        const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;\n        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];\n        list.push({\n            pluginDescriptor: descriptor,\n            setupFn,\n            proxy,\n        });\n        if (proxy) {\n            setupFn(proxy.proxiedTarget);\n        }\n    }\n}\n","/*!\n * pinia v2.1.7\n * (c) 2023 Eduardo San Martin Morote\n * @license MIT\n */\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, del, nextTick, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\n * setActivePinia must be called to handle SSR at the top of functions like\n * `fetch`, `setup`, `serverPrefetch` and others\n */\nlet activePinia;\n/**\n * Sets or unsets the active pinia. Used in SSR and internally when calling\n * actions and getters\n *\n * @param pinia - Pinia instance\n */\n// @ts-expect-error: cannot constrain the type of the return\nconst setActivePinia = (pinia) => (activePinia = pinia);\n/**\n * Get the currently active pinia if there is any.\n */\nconst getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\no) {\n    return (o &&\n        typeof o === 'object' &&\n        Object.prototype.toString.call(o) === '[object Object]' &&\n        typeof o.toJSON !== 'function');\n}\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n// TODO: can we change these to numbers?\n/**\n * Possible types for SubscriptionCallback\n */\nvar MutationType;\n(function (MutationType) {\n    /**\n     * Direct mutation of the state:\n     *\n     * - `store.name = 'new name'`\n     * - `store.$state.name = 'new name'`\n     * - `store.list.push('new item')`\n     */\n    MutationType[\"direct\"] = \"direct\";\n    /**\n     * Mutated the state with `$patch` and an object\n     *\n     * - `store.$patch({ name: 'newName' })`\n     */\n    MutationType[\"patchObject\"] = \"patch object\";\n    /**\n     * Mutated the state with `$patch` and a function\n     *\n     * - `store.$patch(state => state.name = 'newName')`\n     */\n    MutationType[\"patchFunction\"] = \"patch function\";\n    // maybe reset? for $state = {} and $reset\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n/**\n * Should we add the devtools plugins.\n * - only if dev mode or forced through the prod devtools flag\n * - not in test\n * - only if window exists (could change in the future)\n */\nconst USE_DEVTOOLS = ((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test') && IS_CLIENT;\n\n/*\n * FileSaver.js A saveAs() FileSaver implementation.\n *\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\n * Morote.\n *\n * License : MIT\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\n    ? window\n    : typeof self === 'object' && self.self === self\n        ? self\n        : typeof global === 'object' && global.global === global\n            ? global\n            : typeof globalThis === 'object'\n                ? globalThis\n                : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n    if (autoBom &&\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\n    }\n    return blob;\n}\nfunction download(url, name, opts) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    xhr.onload = function () {\n        saveAs(xhr.response, name, opts);\n    };\n    xhr.onerror = function () {\n        console.error('could not download file');\n    };\n    xhr.send();\n}\nfunction corsEnabled(url) {\n    const xhr = new XMLHttpRequest();\n    // use sync to avoid popup blocker\n    xhr.open('HEAD', url, false);\n    try {\n        xhr.send();\n    }\n    catch (e) { }\n    return xhr.status >= 200 && xhr.status <= 299;\n}\n// `a.click()` doesn't work for all browsers (#465)\nfunction click(node) {\n    try {\n        node.dispatchEvent(new MouseEvent('click'));\n    }\n    catch (e) {\n        const evt = document.createEvent('MouseEvents');\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\n        node.dispatchEvent(evt);\n    }\n}\nconst _navigator = \n typeof navigator === 'object' ? navigator : { userAgent: '' };\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\n    /AppleWebKit/.test(_navigator.userAgent) &&\n    !/Safari/.test(_navigator.userAgent))();\nconst saveAs = !IS_CLIENT\n    ? () => { } // noop\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n        typeof HTMLAnchorElement !== 'undefined' &&\n            'download' in HTMLAnchorElement.prototype &&\n            !isMacOSWebView\n            ? downloadSaveAs\n            : // Use msSaveOrOpenBlob as a second approach\n                'msSaveOrOpenBlob' in _navigator\n                    ? msSaveAs\n                    : // Fallback to using FileReader and a popup\n                        fileSaverSaveAs;\nfunction downloadSaveAs(blob, name = 'download', opts) {\n    const a = document.createElement('a');\n    a.download = name;\n    a.rel = 'noopener'; // tabnabbing\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n    if (typeof blob === 'string') {\n        // Support regular links\n        a.href = blob;\n        if (a.origin !== location.origin) {\n            if (corsEnabled(a.href)) {\n                download(blob, name, opts);\n            }\n            else {\n                a.target = '_blank';\n                click(a);\n            }\n        }\n        else {\n            click(a);\n        }\n    }\n    else {\n        // Support blobs\n        a.href = URL.createObjectURL(blob);\n        setTimeout(function () {\n            URL.revokeObjectURL(a.href);\n        }, 4e4); // 40s\n        setTimeout(function () {\n            click(a);\n        }, 0);\n    }\n}\nfunction msSaveAs(blob, name = 'download', opts) {\n    if (typeof blob === 'string') {\n        if (corsEnabled(blob)) {\n            download(blob, name, opts);\n        }\n        else {\n            const a = document.createElement('a');\n            a.href = blob;\n            a.target = '_blank';\n            setTimeout(function () {\n                click(a);\n            });\n        }\n    }\n    else {\n        // @ts-ignore: works on windows\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n    }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank');\n    if (popup) {\n        popup.document.title = popup.document.body.innerText = 'downloading...';\n    }\n    if (typeof blob === 'string')\n        return download(blob, name, opts);\n    const force = blob.type === 'application/octet-stream';\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\n        typeof FileReader !== 'undefined') {\n        // Safari doesn't allow downloading of blob URLs\n        const reader = new FileReader();\n        reader.onloadend = function () {\n            let url = reader.result;\n            if (typeof url !== 'string') {\n                popup = null;\n                throw new Error('Wrong reader.result type');\n            }\n            url = isChromeIOS\n                ? url\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n            if (popup) {\n                popup.location.href = url;\n            }\n            else {\n                location.assign(url);\n            }\n            popup = null; // reverse-tabnabbing #460\n        };\n        reader.readAsDataURL(blob);\n    }\n    else {\n        const url = URL.createObjectURL(blob);\n        if (popup)\n            popup.location.assign(url);\n        else\n            location.href = url;\n        popup = null; // reverse-tabnabbing #460\n        setTimeout(function () {\n            URL.revokeObjectURL(url);\n        }, 4e4); // 40s\n    }\n}\n\n/**\n * Shows a toast or console.log\n *\n * @param message - message to log\n * @param type - different color of the tooltip\n */\nfunction toastMessage(message, type) {\n    const piniaMessage = '🍍 ' + message;\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\n        // No longer available :(\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n    }\n    else if (type === 'error') {\n        console.error(piniaMessage);\n    }\n    else if (type === 'warn') {\n        console.warn(piniaMessage);\n    }\n    else {\n        console.log(piniaMessage);\n    }\n}\nfunction isPinia(o) {\n    return '_a' in o && 'install' in o;\n}\n\n/**\n * This file contain devtools actions, they are not Pinia actions.\n */\n// ---\nfunction checkClipboardAccess() {\n    if (!('clipboard' in navigator)) {\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\n        return true;\n    }\n}\nfunction checkNotFocusedError(error) {\n    if (error instanceof Error &&\n        error.message.toLowerCase().includes('document is not focused')) {\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\n        return true;\n    }\n    return false;\n}\nasync function actionGlobalCopyState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n        toastMessage('Global state copied to clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalPasteState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\n        toastMessage('Global state pasted from clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalSaveState(pinia) {\n    try {\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n            type: 'text/plain;charset=utf-8',\n        }), 'pinia-state.json');\n    }\n    catch (error) {\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nlet fileInput;\nfunction getFileOpener() {\n    if (!fileInput) {\n        fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = '.json';\n    }\n    function openFile() {\n        return new Promise((resolve, reject) => {\n            fileInput.onchange = async () => {\n                const files = fileInput.files;\n                if (!files)\n                    return resolve(null);\n                const file = files.item(0);\n                if (!file)\n                    return resolve(null);\n                return resolve({ text: await file.text(), file });\n            };\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\n            fileInput.oncancel = () => resolve(null);\n            fileInput.onerror = reject;\n            fileInput.click();\n        });\n    }\n    return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n    try {\n        const open = getFileOpener();\n        const result = await open();\n        if (!result)\n            return;\n        const { text, file } = result;\n        loadStoresState(pinia, JSON.parse(text));\n        toastMessage(`Global state imported from \"${file.name}\".`);\n    }\n    catch (error) {\n        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nfunction loadStoresState(pinia, state) {\n    for (const key in state) {\n        const storeState = pinia.state.value[key];\n        // store is already instantiated, patch it\n        if (storeState) {\n            Object.assign(storeState, state[key]);\n        }\n        else {\n            // store is not instantiated, set the initial state\n            pinia.state.value[key] = state[key];\n        }\n    }\n}\n\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\nconst PINIA_ROOT_LABEL = '🍍 Pinia (root)';\nconst PINIA_ROOT_ID = '_root';\nfunction formatStoreForInspectorTree(store) {\n    return isPinia(store)\n        ? {\n            id: PINIA_ROOT_ID,\n            label: PINIA_ROOT_LABEL,\n        }\n        : {\n            id: store.$id,\n            label: store.$id,\n        };\n}\nfunction formatStoreForInspectorState(store) {\n    if (isPinia(store)) {\n        const storeNames = Array.from(store._s.keys());\n        const storeMap = store._s;\n        const state = {\n            state: storeNames.map((storeId) => ({\n                editable: true,\n                key: storeId,\n                value: store.state.value[storeId],\n            })),\n            getters: storeNames\n                .filter((id) => storeMap.get(id)._getters)\n                .map((id) => {\n                const store = storeMap.get(id);\n                return {\n                    editable: false,\n                    key: id,\n                    value: store._getters.reduce((getters, key) => {\n                        getters[key] = store[key];\n                        return getters;\n                    }, {}),\n                };\n            }),\n        };\n        return state;\n    }\n    const state = {\n        state: Object.keys(store.$state).map((key) => ({\n            editable: true,\n            key,\n            value: store.$state[key],\n        })),\n    };\n    // avoid adding empty getters\n    if (store._getters && store._getters.length) {\n        state.getters = store._getters.map((getterName) => ({\n            editable: false,\n            key: getterName,\n            value: store[getterName],\n        }));\n    }\n    if (store._customProperties.size) {\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\n            editable: true,\n            key,\n            value: store[key],\n        }));\n    }\n    return state;\n}\nfunction formatEventData(events) {\n    if (!events)\n        return {};\n    if (Array.isArray(events)) {\n        // TODO: handle add and delete for arrays and objects\n        return events.reduce((data, event) => {\n            data.keys.push(event.key);\n            data.operations.push(event.type);\n            data.oldValue[event.key] = event.oldValue;\n            data.newValue[event.key] = event.newValue;\n            return data;\n        }, {\n            oldValue: {},\n            keys: [],\n            operations: [],\n            newValue: {},\n        });\n    }\n    else {\n        return {\n            operation: formatDisplay(events.type),\n            key: formatDisplay(events.key),\n            oldValue: events.oldValue,\n            newValue: events.newValue,\n        };\n    }\n}\nfunction formatMutationType(type) {\n    switch (type) {\n        case MutationType.direct:\n            return 'mutation';\n        case MutationType.patchFunction:\n            return '$patch';\n        case MutationType.patchObject:\n            return '$patch';\n        default:\n            return 'unknown';\n    }\n}\n\n// timeline can be paused when directly changing the state\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\nconst INSPECTOR_ID = 'pinia';\nconst { assign: assign$1 } = Object;\n/**\n * Gets the displayed name of a store in devtools\n *\n * @param id - id of the store\n * @returns a formatted string\n */\nconst getStoreType = (id) => '🍍 ' + id;\n/**\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\n * as soon as it is added to the application.\n *\n * @param app - Vue application\n * @param pinia - pinia instance\n */\nfunction registerPiniaDevtools(app, pinia) {\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia 🍍',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n    }, (api) => {\n        if (typeof api.now !== 'function') {\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n        }\n        api.addTimelineLayer({\n            id: MUTATIONS_LAYER_ID,\n            label: `Pinia 🍍`,\n            color: 0xe5df88,\n        });\n        api.addInspector({\n            id: INSPECTOR_ID,\n            label: 'Pinia 🍍',\n            icon: 'storage',\n            treeFilterPlaceholder: 'Search stores',\n            actions: [\n                {\n                    icon: 'content_copy',\n                    action: () => {\n                        actionGlobalCopyState(pinia);\n                    },\n                    tooltip: 'Serialize and copy the state',\n                },\n                {\n                    icon: 'content_paste',\n                    action: async () => {\n                        await actionGlobalPasteState(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Replace the state with the content of your clipboard',\n                },\n                {\n                    icon: 'save',\n                    action: () => {\n                        actionGlobalSaveState(pinia);\n                    },\n                    tooltip: 'Save the state as a JSON file',\n                },\n                {\n                    icon: 'folder_open',\n                    action: async () => {\n                        await actionGlobalOpenStateFile(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Import the state from a JSON file',\n                },\n            ],\n            nodeActions: [\n                {\n                    icon: 'restore',\n                    tooltip: 'Reset the state (with \"$reset\")',\n                    action: (nodeId) => {\n                        const store = pinia._s.get(nodeId);\n                        if (!store) {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\n                        }\n                        else if (typeof store.$reset !== 'function') {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, 'warn');\n                        }\n                        else {\n                            store.$reset();\n                            toastMessage(`Store \"${nodeId}\" reset.`);\n                        }\n                    },\n                },\n            ],\n        });\n        api.on.inspectComponent((payload, ctx) => {\n            const proxy = (payload.componentInstance &&\n                payload.componentInstance.proxy);\n            if (proxy && proxy._pStores) {\n                const piniaStores = payload.componentInstance.proxy._pStores;\n                Object.values(piniaStores).forEach((store) => {\n                    payload.instanceData.state.push({\n                        type: getStoreType(store.$id),\n                        key: 'state',\n                        editable: true,\n                        value: store._isOptionsAPI\n                            ? {\n                                _custom: {\n                                    value: toRaw(store.$state),\n                                    actions: [\n                                        {\n                                            icon: 'restore',\n                                            tooltip: 'Reset the state of this store',\n                                            action: () => store.$reset(),\n                                        },\n                                    ],\n                                },\n                            }\n                            : // NOTE: workaround to unwrap transferred refs\n                                Object.keys(store.$state).reduce((state, key) => {\n                                    state[key] = store.$state[key];\n                                    return state;\n                                }, {}),\n                    });\n                    if (store._getters && store._getters.length) {\n                        payload.instanceData.state.push({\n                            type: getStoreType(store.$id),\n                            key: 'getters',\n                            editable: false,\n                            value: store._getters.reduce((getters, key) => {\n                                try {\n                                    getters[key] = store[key];\n                                }\n                                catch (error) {\n                                    // @ts-expect-error: we just want to show it in devtools\n                                    getters[key] = error;\n                                }\n                                return getters;\n                            }, {}),\n                        });\n                    }\n                });\n            }\n        });\n        api.on.getInspectorTree((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                let stores = [pinia];\n                stores = stores.concat(Array.from(pinia._s.values()));\n                payload.rootNodes = (payload.filter\n                    ? stores.filter((store) => '$id' in store\n                        ? store.$id\n                            .toLowerCase()\n                            .includes(payload.filter.toLowerCase())\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\n                    : stores).map(formatStoreForInspectorTree);\n            }\n        });\n        api.on.getInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    // this could be the selected store restored for a different project\n                    // so it's better not to say anything here\n                    return;\n                }\n                if (inspectedStore) {\n                    payload.state = formatStoreForInspectorState(inspectedStore);\n                }\n            }\n        });\n        api.on.editInspectorState((payload, ctx) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (!isPinia(inspectedStore)) {\n                    // access only the state\n                    if (path.length !== 1 ||\n                        !inspectedStore._customProperties.has(path[0]) ||\n                        path[0] in inspectedStore.$state) {\n                        path.unshift('$state');\n                    }\n                }\n                else {\n                    // Root access, we can omit the `.value` because the devtools API does it for us\n                    path.unshift('state');\n                }\n                isTimelineActive = false;\n                payload.set(inspectedStore, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n        api.on.editComponentState((payload) => {\n            if (payload.type.startsWith('🍍')) {\n                const storeId = payload.type.replace(/^🍍\\s*/, '');\n                const store = pinia._s.get(storeId);\n                if (!store) {\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (path[0] !== 'state') {\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\n                }\n                // rewrite the first entry to be able to directly set the state as\n                // well as any other path\n                path[0] = '$state';\n                isTimelineActive = false;\n                payload.set(store, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n    });\n}\nfunction addStoreToDevtools(app, store) {\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\n        componentStateTypes.push(getStoreType(store.$id));\n    }\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia 🍍',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n        settings: {\n            logStoreChanges: {\n                label: 'Notify about new/deleted stores',\n                type: 'boolean',\n                defaultValue: true,\n            },\n            // useEmojis: {\n            //   label: 'Use emojis in messages ⚡️',\n            //   type: 'boolean',\n            //   defaultValue: true,\n            // },\n        },\n    }, (api) => {\n        // gracefully handle errors\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\n        store.$onAction(({ after, onError, name, args }) => {\n            const groupId = runningActionId++;\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: '🛫 ' + name,\n                    subtitle: 'start',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        action: formatDisplay(name),\n                        args,\n                    },\n                    groupId,\n                },\n            });\n            after((result) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        title: '🛬 ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            result,\n                        },\n                        groupId,\n                    },\n                });\n            });\n            onError((error) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        logType: 'error',\n                        title: '💥 ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            error,\n                        },\n                        groupId,\n                    },\n                });\n            });\n        }, true);\n        store._customProperties.forEach((name) => {\n            watch(() => unref(store[name]), (newValue, oldValue) => {\n                api.notifyComponentUpdate();\n                api.sendInspectorState(INSPECTOR_ID);\n                if (isTimelineActive) {\n                    api.addTimelineEvent({\n                        layerId: MUTATIONS_LAYER_ID,\n                        event: {\n                            time: now(),\n                            title: 'Change',\n                            subtitle: name,\n                            data: {\n                                newValue,\n                                oldValue,\n                            },\n                            groupId: activeAction,\n                        },\n                    });\n                }\n            }, { deep: true });\n        });\n        store.$subscribe(({ events, type }, state) => {\n            api.notifyComponentUpdate();\n            api.sendInspectorState(INSPECTOR_ID);\n            if (!isTimelineActive)\n                return;\n            // rootStore.state[store.id] = state\n            const eventData = {\n                time: now(),\n                title: formatMutationType(type),\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\n                groupId: activeAction,\n            };\n            if (type === MutationType.patchFunction) {\n                eventData.subtitle = '⤵️';\n            }\n            else if (type === MutationType.patchObject) {\n                eventData.subtitle = '🧩';\n            }\n            else if (events && !Array.isArray(events)) {\n                eventData.subtitle = events.type;\n            }\n            if (events) {\n                eventData.data['rawEvent(s)'] = {\n                    _custom: {\n                        display: 'DebuggerEvent',\n                        type: 'object',\n                        tooltip: 'raw DebuggerEvent[]',\n                        value: events,\n                    },\n                };\n            }\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: eventData,\n            });\n        }, { detached: true, flush: 'sync' });\n        const hotUpdate = store._hotUpdate;\n        store._hotUpdate = markRaw((newStore) => {\n            hotUpdate(newStore);\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: '🔥 ' + store.$id,\n                    subtitle: 'HMR update',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        info: formatDisplay(`HMR update`),\n                    },\n                },\n            });\n            // update the devtools too\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n        });\n        const { $dispose } = store;\n        store.$dispose = () => {\n            $dispose();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n            api.getSettings().logStoreChanges &&\n                toastMessage(`Disposed \"${store.$id}\" store 🗑`);\n        };\n        // trigger an update so it can display new registered stores\n        api.notifyComponentUpdate();\n        api.sendInspectorTree(INSPECTOR_ID);\n        api.sendInspectorState(INSPECTOR_ID);\n        api.getSettings().logStoreChanges &&\n            toastMessage(`\"${store.$id}\" store installed 🆕`);\n    });\n}\nlet runningActionId = 0;\nlet activeAction;\n/**\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\n * mutation to the action.\n *\n * @param store - store to patch\n * @param actionNames - list of actionst to patch\n */\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\n    // original actions of the store as they are given by pinia. We are going to override them\n    const actions = actionNames.reduce((storeActions, actionName) => {\n        // use toRaw to avoid tracking #541\n        storeActions[actionName] = toRaw(store)[actionName];\n        return storeActions;\n    }, {});\n    for (const actionName in actions) {\n        store[actionName] = function () {\n            // the running action id is incremented in a before action hook\n            const _actionId = runningActionId;\n            const trackedStore = wrapWithProxy\n                ? new Proxy(store, {\n                    get(...args) {\n                        activeAction = _actionId;\n                        return Reflect.get(...args);\n                    },\n                    set(...args) {\n                        activeAction = _actionId;\n                        return Reflect.set(...args);\n                    },\n                })\n                : store;\n            // For Setup Stores we need https://github.com/tc39/proposal-async-context\n            activeAction = _actionId;\n            const retValue = actions[actionName].apply(trackedStore, arguments);\n            // this is safer as async actions in Setup Stores would associate mutations done outside of the action\n            activeAction = undefined;\n            return retValue;\n        };\n    }\n}\n/**\n * pinia.use(devtoolsPlugin)\n */\nfunction devtoolsPlugin({ app, store, options }) {\n    // HMR module\n    if (store.$id.startsWith('__hot:')) {\n        return;\n    }\n    // detect option api vs setup api\n    store._isOptionsAPI = !!options.state;\n    patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\n    // Upgrade the HMR to also update the new actions\n    const originalHotUpdate = store._hotUpdate;\n    toRaw(store)._hotUpdate = function (newStore) {\n        originalHotUpdate.apply(this, arguments);\n        patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\n    };\n    addStoreToDevtools(app, \n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n    store);\n}\n\n/**\n * Creates a Pinia instance to be used by the application\n */\nfunction createPinia() {\n    const scope = effectScope(true);\n    // NOTE: here we could check the window object for a state and directly set it\n    // if there is anything like it with Vue 3 SSR\n    const state = scope.run(() => ref({}));\n    let _p = [];\n    // plugins added before calling app.use(pinia)\n    let toBeInstalled = [];\n    const pinia = markRaw({\n        install(app) {\n            // this allows calling useStore() outside of a component setup after\n            // installing pinia's plugin\n            setActivePinia(pinia);\n            if (!isVue2) {\n                pinia._a = app;\n                app.provide(piniaSymbol, pinia);\n                app.config.globalProperties.$pinia = pinia;\n                /* istanbul ignore else */\n                if (USE_DEVTOOLS) {\n                    registerPiniaDevtools(app, pinia);\n                }\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\n                toBeInstalled = [];\n            }\n        },\n        use(plugin) {\n            if (!this._a && !isVue2) {\n                toBeInstalled.push(plugin);\n            }\n            else {\n                _p.push(plugin);\n            }\n            return this;\n        },\n        _p,\n        // it's actually undefined here\n        // @ts-expect-error\n        _a: null,\n        _e: scope,\n        _s: new Map(),\n        state,\n    });\n    // pinia devtools rely on dev only features so they cannot be forced unless\n    // the dev build of Vue is used. Avoid old browsers like IE11.\n    if (USE_DEVTOOLS && typeof Proxy !== 'undefined') {\n        pinia.use(devtoolsPlugin);\n    }\n    return pinia;\n}\n\n/**\n * Checks if a function is a `StoreDefinition`.\n *\n * @param fn - object to test\n * @returns true if `fn` is a StoreDefinition\n */\nconst isUseStore = (fn) => {\n    return typeof fn === 'function' && typeof fn.$id === 'string';\n};\n/**\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\n * remove any key not existing in `newState` and recursively merge plain\n * objects.\n *\n * @param newState - new state object to be patched\n * @param oldState - old state that should be used to patch newState\n * @returns - newState\n */\nfunction patchObject(newState, oldState) {\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in oldState) {\n        const subPatch = oldState[key];\n        // skip the whole sub tree\n        if (!(key in newState)) {\n            continue;\n        }\n        const targetValue = newState[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            newState[key] = patchObject(targetValue, subPatch);\n        }\n        else {\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\n            // just set the whole thing\n            if (isVue2) {\n                set(newState, key, subPatch);\n            }\n            else {\n                newState[key] = subPatch;\n            }\n        }\n    }\n    return newState;\n}\n/**\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\n *\n * @example\n * ```js\n * const useUser = defineStore(...)\n * if (import.meta.hot) {\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\n * }\n * ```\n *\n * @param initialUseStore - return of the defineStore to hot update\n * @param hot - `import.meta.hot`\n */\nfunction acceptHMRUpdate(initialUseStore, hot) {\n    // strip as much as possible from iife.prod\n    if (!(process.env.NODE_ENV !== 'production')) {\n        return () => { };\n    }\n    return (newModule) => {\n        const pinia = hot.data.pinia || initialUseStore._pinia;\n        if (!pinia) {\n            // this store is still not used\n            return;\n        }\n        // preserve the pinia instance across loads\n        hot.data.pinia = pinia;\n        // console.log('got data', newStore)\n        for (const exportName in newModule) {\n            const useStore = newModule[exportName];\n            // console.log('checking for', exportName)\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n                // console.log('Accepting update for', useStore.$id)\n                const id = useStore.$id;\n                if (id !== initialUseStore.$id) {\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\n                    // return import.meta.hot.invalidate()\n                    return hot.invalidate();\n                }\n                const existingStore = pinia._s.get(id);\n                if (!existingStore) {\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n                    return;\n                }\n                useStore(pinia, existingStore);\n            }\n        }\n    };\n}\n\nconst noop = () => { };\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n    subscriptions.push(callback);\n    const removeSubscription = () => {\n        const idx = subscriptions.indexOf(callback);\n        if (idx > -1) {\n            subscriptions.splice(idx, 1);\n            onCleanup();\n        }\n    };\n    if (!detached && getCurrentScope()) {\n        onScopeDispose(removeSubscription);\n    }\n    return removeSubscription;\n}\nfunction triggerSubscriptions(subscriptions, ...args) {\n    subscriptions.slice().forEach((callback) => {\n        callback(...args);\n    });\n}\n\nconst fallbackRunWithContext = (fn) => fn();\nfunction mergeReactiveObjects(target, patchToApply) {\n    // Handle Map instances\n    if (target instanceof Map && patchToApply instanceof Map) {\n        patchToApply.forEach((value, key) => target.set(key, value));\n    }\n    // Handle Set instances\n    if (target instanceof Set && patchToApply instanceof Set) {\n        patchToApply.forEach(target.add, target);\n    }\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in patchToApply) {\n        if (!patchToApply.hasOwnProperty(key))\n            continue;\n        const subPatch = patchToApply[key];\n        const targetValue = target[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            target.hasOwnProperty(key) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\n        }\n        else {\n            // @ts-expect-error: subPatch is a valid value\n            target[key] = subPatch;\n        }\n    }\n    return target;\n}\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\n    ? Symbol('pinia:skipHydration')\n    : /* istanbul ignore next */ Symbol();\nconst skipHydrateMap = /*#__PURE__*/ new WeakMap();\n/**\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\n *\n * @param obj - target object\n * @returns obj\n */\nfunction skipHydrate(obj) {\n    return isVue2\n        ? // in @vue/composition-api, the refs are sealed so defineProperty doesn't work...\n            /* istanbul ignore next */ skipHydrateMap.set(obj, 1) && obj\n        : Object.defineProperty(obj, skipHydrateSymbol, {});\n}\n/**\n * Returns whether a value should be hydrated\n *\n * @param obj - target variable\n * @returns true if `obj` should be hydrated\n */\nfunction shouldHydrate(obj) {\n    return isVue2\n        ? /* istanbul ignore next */ !skipHydrateMap.has(obj)\n        : !isPlainObject(obj) || !obj.hasOwnProperty(skipHydrateSymbol);\n}\nconst { assign } = Object;\nfunction isComputed(o) {\n    return !!(isRef(o) && o.effect);\n}\nfunction createOptionsStore(id, options, pinia, hot) {\n    const { state, actions, getters } = options;\n    const initialState = pinia.state.value[id];\n    let store;\n    function setup() {\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(pinia.state.value, id, state ? state() : {});\n            }\n            else {\n                pinia.state.value[id] = state ? state() : {};\n            }\n        }\n        // avoid creating a state in pinia.state.value\n        const localState = (process.env.NODE_ENV !== 'production') && hot\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n                toRefs(ref(state ? state() : {}).value)\n            : toRefs(pinia.state.value[id]);\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\n                console.warn(`[🍍]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\n            }\n            computedGetters[name] = markRaw(computed(() => {\n                setActivePinia(pinia);\n                // it was created just before\n                const store = pinia._s.get(id);\n                // allow cross using stores\n                /* istanbul ignore next */\n                if (isVue2 && !store._r)\n                    return;\n                // @ts-expect-error\n                // return getters![name].call(context, context)\n                // TODO: avoid reading the getter while assigning with a global variable\n                return getters[name].call(store, store);\n            }));\n            return computedGetters;\n        }, {}));\n    }\n    store = createSetupStore(id, setup, options, pinia, hot, true);\n    return store;\n}\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\n    let scope;\n    const optionsForPlugin = assign({ actions: {} }, options);\n    /* istanbul ignore if */\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\n        throw new Error('Pinia destroyed');\n    }\n    // watcher options for $subscribe\n    const $subscribeOptions = {\n        deep: true,\n        // flush: 'post',\n    };\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\n        $subscribeOptions.onTrigger = (event) => {\n            /* istanbul ignore else */\n            if (isListening) {\n                debuggerEvents = event;\n                // avoid triggering this while the store is being built and the state is being set in pinia\n            }\n            else if (isListening == false && !store._hotUpdating) {\n                // let patch send all the events together later\n                /* istanbul ignore else */\n                if (Array.isArray(debuggerEvents)) {\n                    debuggerEvents.push(event);\n                }\n                else {\n                    console.error('🍍 debuggerEvents should be an array. This is most likely an internal Pinia bug.');\n                }\n            }\n        };\n    }\n    // internal state\n    let isListening; // set to true at the end\n    let isSyncListening; // set to true at the end\n    let subscriptions = [];\n    let actionSubscriptions = [];\n    let debuggerEvents;\n    const initialState = pinia.state.value[$id];\n    // avoid setting the state for option stores if it is set\n    // by the setup\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n        /* istanbul ignore if */\n        if (isVue2) {\n            set(pinia.state.value, $id, {});\n        }\n        else {\n            pinia.state.value[$id] = {};\n        }\n    }\n    const hotState = ref({});\n    // avoid triggering too many listeners\n    // https://github.com/vuejs/pinia/issues/1129\n    let activeListener;\n    function $patch(partialStateOrMutator) {\n        let subscriptionMutation;\n        isListening = isSyncListening = false;\n        // reset the debugger events since patches are sync\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            debuggerEvents = [];\n        }\n        if (typeof partialStateOrMutator === 'function') {\n            partialStateOrMutator(pinia.state.value[$id]);\n            subscriptionMutation = {\n                type: MutationType.patchFunction,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        else {\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n            subscriptionMutation = {\n                type: MutationType.patchObject,\n                payload: partialStateOrMutator,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        const myListenerId = (activeListener = Symbol());\n        nextTick().then(() => {\n            if (activeListener === myListenerId) {\n                isListening = true;\n            }\n        });\n        isSyncListening = true;\n        // because we paused the watcher, we need to manually call the subscriptions\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n    }\n    const $reset = isOptionsStore\n        ? function $reset() {\n            const { state } = options;\n            const newState = state ? state() : {};\n            // we use a patch to group all changes into one single subscription\n            this.$patch(($state) => {\n                assign($state, newState);\n            });\n        }\n        : /* istanbul ignore next */\n            (process.env.NODE_ENV !== 'production')\n                ? () => {\n                    throw new Error(`🍍: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\n                }\n                : noop;\n    function $dispose() {\n        scope.stop();\n        subscriptions = [];\n        actionSubscriptions = [];\n        pinia._s.delete($id);\n    }\n    /**\n     * Wraps an action to handle subscriptions.\n     *\n     * @param name - name of the action\n     * @param action - action to wrap\n     * @returns a wrapped action to handle subscriptions\n     */\n    function wrapAction(name, action) {\n        return function () {\n            setActivePinia(pinia);\n            const args = Array.from(arguments);\n            const afterCallbackList = [];\n            const onErrorCallbackList = [];\n            function after(callback) {\n                afterCallbackList.push(callback);\n            }\n            function onError(callback) {\n                onErrorCallbackList.push(callback);\n            }\n            // @ts-expect-error\n            triggerSubscriptions(actionSubscriptions, {\n                args,\n                name,\n                store,\n                after,\n                onError,\n            });\n            let ret;\n            try {\n                ret = action.apply(this && this.$id === $id ? this : store, args);\n                // handle sync errors\n            }\n            catch (error) {\n                triggerSubscriptions(onErrorCallbackList, error);\n                throw error;\n            }\n            if (ret instanceof Promise) {\n                return ret\n                    .then((value) => {\n                    triggerSubscriptions(afterCallbackList, value);\n                    return value;\n                })\n                    .catch((error) => {\n                    triggerSubscriptions(onErrorCallbackList, error);\n                    return Promise.reject(error);\n                });\n            }\n            // trigger after callbacks\n            triggerSubscriptions(afterCallbackList, ret);\n            return ret;\n        };\n    }\n    const _hmrPayload = /*#__PURE__*/ markRaw({\n        actions: {},\n        getters: {},\n        state: [],\n        hotState,\n    });\n    const partialStore = {\n        _p: pinia,\n        // _s: scope,\n        $id,\n        $onAction: addSubscription.bind(null, actionSubscriptions),\n        $patch,\n        $reset,\n        $subscribe(callback, options = {}) {\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\n                    callback({\n                        storeId: $id,\n                        type: MutationType.direct,\n                        events: debuggerEvents,\n                    }, state);\n                }\n            }, assign({}, $subscribeOptions, options)));\n            return removeSubscription;\n        },\n        $dispose,\n    };\n    /* istanbul ignore if */\n    if (isVue2) {\n        // start as non ready\n        partialStore._r = false;\n    }\n    const store = reactive((process.env.NODE_ENV !== 'production') || USE_DEVTOOLS\n        ? assign({\n            _hmrPayload,\n            _customProperties: markRaw(new Set()), // devtools custom properties\n        }, partialStore\n        // must be added later\n        // setupStore\n        )\n        : partialStore);\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\n    // creating infinite loops.\n    pinia._s.set($id, store);\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(setup)));\n    // overwrite existing actions to support $onAction\n    for (const key in setupStore) {\n        const prop = setupStore[key];\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\n            // mark it as a piece of state to be serialized\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                set(hotState.value, key, toRef(setupStore, key));\n                // createOptionStore directly sets the state in pinia.state.value so we\n                // can just skip that\n            }\n            else if (!isOptionsStore) {\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n                if (initialState && shouldHydrate(prop)) {\n                    if (isRef(prop)) {\n                        prop.value = initialState[key];\n                    }\n                    else {\n                        // probably a reactive object, lets recursively assign\n                        // @ts-expect-error: prop is unknown\n                        mergeReactiveObjects(prop, initialState[key]);\n                    }\n                }\n                // transfer the ref to the pinia state to keep everything in sync\n                /* istanbul ignore if */\n                if (isVue2) {\n                    set(pinia.state.value[$id], key, prop);\n                }\n                else {\n                    pinia.state.value[$id][key] = prop;\n                }\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.state.push(key);\n            }\n            // action\n        }\n        else if (typeof prop === 'function') {\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\n            // this a hot module replacement store because the hotUpdate method needs\n            // to do it with the right context\n            /* istanbul ignore if */\n            if (isVue2) {\n                set(setupStore, key, actionValue);\n            }\n            else {\n                // @ts-expect-error\n                setupStore[key] = actionValue;\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.actions[key] = prop;\n            }\n            // list actions so they can be used in plugins\n            // @ts-expect-error\n            optionsForPlugin.actions[key] = prop;\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            // add getters for devtools\n            if (isComputed(prop)) {\n                _hmrPayload.getters[key] = isOptionsStore\n                    ? // @ts-expect-error\n                        options.getters[key]\n                    : prop;\n                if (IS_CLIENT) {\n                    const getters = setupStore._getters ||\n                        // @ts-expect-error: same\n                        (setupStore._getters = markRaw([]));\n                    getters.push(key);\n                }\n            }\n        }\n    }\n    // add the state, getters, and action properties\n    /* istanbul ignore if */\n    if (isVue2) {\n        Object.keys(setupStore).forEach((key) => {\n            set(store, key, setupStore[key]);\n        });\n    }\n    else {\n        assign(store, setupStore);\n        // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n        // Make `storeToRefs()` work with `reactive()` #799\n        assign(toRaw(store), setupStore);\n    }\n    // use this instead of a computed with setter to be able to create it anywhere\n    // without linking the computed lifespan to wherever the store is first\n    // created.\n    Object.defineProperty(store, '$state', {\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\n        set: (state) => {\n            /* istanbul ignore if */\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                throw new Error('cannot set hotState');\n            }\n            $patch(($state) => {\n                assign($state, state);\n            });\n        },\n    });\n    // add the hotUpdate before plugins to allow them to override it\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        store._hotUpdate = markRaw((newStore) => {\n            store._hotUpdating = true;\n            newStore._hmrPayload.state.forEach((stateKey) => {\n                if (stateKey in store.$state) {\n                    const newStateTarget = newStore.$state[stateKey];\n                    const oldStateSource = store.$state[stateKey];\n                    if (typeof newStateTarget === 'object' &&\n                        isPlainObject(newStateTarget) &&\n                        isPlainObject(oldStateSource)) {\n                        patchObject(newStateTarget, oldStateSource);\n                    }\n                    else {\n                        // transfer the ref\n                        newStore.$state[stateKey] = oldStateSource;\n                    }\n                }\n                // patch direct access properties to allow store.stateProperty to work as\n                // store.$state.stateProperty\n                set(store, stateKey, toRef(newStore.$state, stateKey));\n            });\n            // remove deleted state properties\n            Object.keys(store.$state).forEach((stateKey) => {\n                if (!(stateKey in newStore.$state)) {\n                    del(store, stateKey);\n                }\n            });\n            // avoid devtools logging this as a mutation\n            isListening = false;\n            isSyncListening = false;\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\n            isSyncListening = true;\n            nextTick().then(() => {\n                isListening = true;\n            });\n            for (const actionName in newStore._hmrPayload.actions) {\n                const action = newStore[actionName];\n                set(store, actionName, wrapAction(actionName, action));\n            }\n            // TODO: does this work in both setup and option store?\n            for (const getterName in newStore._hmrPayload.getters) {\n                const getter = newStore._hmrPayload.getters[getterName];\n                const getterValue = isOptionsStore\n                    ? // special handling of options api\n                        computed(() => {\n                            setActivePinia(pinia);\n                            return getter.call(store, store);\n                        })\n                    : getter;\n                set(store, getterName, getterValue);\n            }\n            // remove deleted getters\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\n                if (!(key in newStore._hmrPayload.getters)) {\n                    del(store, key);\n                }\n            });\n            // remove old actions\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\n                if (!(key in newStore._hmrPayload.actions)) {\n                    del(store, key);\n                }\n            });\n            // update the values used in devtools and to allow deleting new properties later on\n            store._hmrPayload = newStore._hmrPayload;\n            store._getters = newStore._getters;\n            store._hotUpdating = false;\n        });\n    }\n    if (USE_DEVTOOLS) {\n        const nonEnumerable = {\n            writable: true,\n            configurable: true,\n            // avoid warning on devtools trying to display this property\n            enumerable: false,\n        };\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\n        });\n    }\n    /* istanbul ignore if */\n    if (isVue2) {\n        // mark the store as ready before plugins\n        store._r = true;\n    }\n    // apply all plugins\n    pinia._p.forEach((extender) => {\n        /* istanbul ignore else */\n        if (USE_DEVTOOLS) {\n            const extensions = scope.run(() => extender({\n                store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            }));\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\n            assign(store, extensions);\n        }\n        else {\n            assign(store, scope.run(() => extender({\n                store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            })));\n        }\n    });\n    if ((process.env.NODE_ENV !== 'production') &&\n        store.$state &&\n        typeof store.$state === 'object' &&\n        typeof store.$state.constructor === 'function' &&\n        !store.$state.constructor.toString().includes('[native code]')) {\n        console.warn(`[🍍]: The \"state\" must be a plain object. It cannot be\\n` +\n            `\\tstate: () => new MyClass()\\n` +\n            `Found in store \"${store.$id}\".`);\n    }\n    // only apply hydrate to option stores with an initial state in pinia\n    if (initialState &&\n        isOptionsStore &&\n        options.hydrate) {\n        options.hydrate(store.$state, initialState);\n    }\n    isListening = true;\n    isSyncListening = true;\n    return store;\n}\nfunction defineStore(\n// TODO: add proper types from above\nidOrOptions, setup, setupOptions) {\n    let id;\n    let options;\n    const isSetupStore = typeof setup === 'function';\n    if (typeof idOrOptions === 'string') {\n        id = idOrOptions;\n        // the option store setup will contain the actual options in this case\n        options = isSetupStore ? setupOptions : setup;\n    }\n    else {\n        options = idOrOptions;\n        id = idOrOptions.id;\n        if ((process.env.NODE_ENV !== 'production') && typeof id !== 'string') {\n            throw new Error(`[🍍]: \"defineStore()\" must be passed a store id as its first argument.`);\n        }\n    }\n    function useStore(pinia, hot) {\n        const hasContext = hasInjectionContext();\n        pinia =\n            // in test mode, ignore the argument provided as we can always retrieve a\n            // pinia instance with getActivePinia()\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\n                (hasContext ? inject(piniaSymbol, null) : null);\n        if (pinia)\n            setActivePinia(pinia);\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\n            throw new Error(`[🍍]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\\n` +\n                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\n` +\n                `This will fail in production.`);\n        }\n        pinia = activePinia;\n        if (!pinia._s.has(id)) {\n            // creating the store registers it in `pinia._s`\n            if (isSetupStore) {\n                createSetupStore(id, setup, options, pinia);\n            }\n            else {\n                createOptionsStore(id, options, pinia);\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                // @ts-expect-error: not the right inferred type\n                useStore._pinia = pinia;\n            }\n        }\n        const store = pinia._s.get(id);\n        if ((process.env.NODE_ENV !== 'production') && hot) {\n            const hotId = '__hot:' + id;\n            const newStore = isSetupStore\n                ? createSetupStore(hotId, setup, options, pinia, true)\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\n            hot._hotUpdate(newStore);\n            // cleanup the state properties and the store from the cache\n            delete pinia.state.value[hotId];\n            pinia._s.delete(hotId);\n        }\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\n            const currentInstance = getCurrentInstance();\n            // save stores in instances to access them devtools\n            if (currentInstance &&\n                currentInstance.proxy &&\n                // avoid adding stores that are just built for hot module replacement\n                !hot) {\n                const vm = currentInstance.proxy;\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\n                cache[id] = store;\n            }\n        }\n        // StoreGeneric cannot be casted towards Store\n        return store;\n    }\n    useStore.$id = id;\n    return useStore;\n}\n\nlet mapStoreSuffix = 'Store';\n/**\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\n * interface if you are using TypeScript.\n *\n * @param suffix - new suffix\n */\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\n) {\n    mapStoreSuffix = suffix;\n}\n/**\n * Allows using stores without the composition API (`setup()`) by generating an\n * object to be spread in the `computed` field of a component. It accepts a list\n * of store definitions.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapStores(useUserStore, useCartStore)\n *   },\n *\n *   created() {\n *     this.userStore // store with id \"user\"\n *     this.cartStore // store with id \"cart\"\n *   }\n * }\n * ```\n *\n * @param stores - list of stores to map to an object\n */\nfunction mapStores(...stores) {\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\n        console.warn(`[🍍]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\n            `Replace\\n` +\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\n            `with\\n` +\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\n            `This will fail in production if not fixed.`);\n        stores = stores[0];\n    }\n    return stores.reduce((reduced, useStore) => {\n        // @ts-expect-error: $id is added by defineStore\n        reduced[useStore.$id + mapStoreSuffix] = function () {\n            return useStore(this.$pinia);\n        };\n        return reduced;\n    }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = function () {\n                return useStore(this.$pinia)[key];\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function () {\n                const store = useStore(this.$pinia);\n                const storeKey = keysOrMapper[key];\n                // for some reason TS is unable to infer the type of storeKey to be a\n                // function\n                return typeof storeKey === 'function'\n                    ? storeKey.call(this, store)\n                    : store[storeKey];\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Alias for `mapState()`. You should use `mapState()` instead.\n * @deprecated use `mapState()` instead.\n */\nconst mapGetters = mapState;\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapActions(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                return useStore(this.$pinia)[key](...args);\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapWritableState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[key];\n                },\n                set(value) {\n                    // it's easier to type it here as any\n                    return (useStore(this.$pinia)[key] = value);\n                },\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-ignore\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[keysOrMapper[key]];\n                },\n                set(value) {\n                    // it's easier to type it here as any\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\n                },\n            };\n            return reduced;\n        }, {});\n}\n\n/**\n * Creates an object of references with all the state, getters, and plugin-added\n * state properties of the store. Similar to `toRefs()` but specifically\n * designed for Pinia stores so methods and non reactive properties are\n * completely ignored.\n *\n * @param store - store to extract the refs from\n */\nfunction storeToRefs(store) {\n    // See https://github.com/vuejs/pinia/issues/852\n    // It's easier to just use toRefs() even if it includes more stuff\n    if (isVue2) {\n        // @ts-expect-error: toRefs include methods and others\n        return toRefs(store);\n    }\n    else {\n        store = toRaw(store);\n        const refs = {};\n        for (const key in store) {\n            const value = store[key];\n            if (isRef(value) || isReactive(value)) {\n                // @ts-expect-error: the key is state or getter\n                refs[key] =\n                    // ---\n                    toRef(store, key);\n            }\n        }\n        return refs;\n    }\n}\n\n/**\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\n * https://pinia.vuejs.org/ssr/nuxt.html.\n *\n * @example\n * ```js\n * import Vue from 'vue'\n * import { PiniaVuePlugin, createPinia } from 'pinia'\n *\n * Vue.use(PiniaVuePlugin)\n * const pinia = createPinia()\n *\n * new Vue({\n *   el: '#app',\n *   // ...\n *   pinia,\n * })\n * ```\n *\n * @param _Vue - `Vue` imported from 'vue'.\n */\nconst PiniaVuePlugin = function (_Vue) {\n    // Equivalent of\n    // app.config.globalProperties.$pinia = pinia\n    _Vue.mixin({\n        beforeCreate() {\n            const options = this.$options;\n            if (options.pinia) {\n                const pinia = options.pinia;\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/main/src/apis/inject.ts#L31\n                /* istanbul ignore else */\n                if (!this._provided) {\n                    const provideCache = {};\n                    Object.defineProperty(this, '_provided', {\n                        get: () => provideCache,\n                        set: (v) => Object.assign(provideCache, v),\n                    });\n                }\n                this._provided[piniaSymbol] = pinia;\n                // propagate the pinia instance in an SSR friendly way\n                // avoid adding it to nuxt twice\n                /* istanbul ignore else */\n                if (!this.$pinia) {\n                    this.$pinia = pinia;\n                }\n                pinia._a = this;\n                if (IS_CLIENT) {\n                    // this allows calling useStore() outside of a component setup after\n                    // installing pinia's plugin\n                    setActivePinia(pinia);\n                }\n                if (USE_DEVTOOLS) {\n                    registerPiniaDevtools(pinia._a, pinia);\n                }\n            }\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\n                this.$pinia = options.parent.$pinia;\n            }\n        },\n        destroyed() {\n            delete this._pStores;\n        },\n    });\n};\n\nexport { MutationType, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, skipHydrate, storeToRefs };\n"],"names":["util","warn","getTarget","navigator","window","globalThis","isProxyAvailable","Proxy","HOOK_SETUP","supported","perf","now","undefined","performance","_a","perf_hooks","Date","ApiProxy","constructor","plugin","hook","this","target","targetQueue","onQueue","defaultSettings","settings","id","item","defaultValue","localSettingsSaveId","currentSettings","Object","assign","raw","localStorage","getItem","data","JSON","parse","e","fallbacks","getSettings","setSettings","value","setItem","stringify","on","pluginId","proxiedOn","get","_target","prop","args","push","method","proxiedTarget","keys","includes","resolve","Promise","setRealTarget","setupDevtoolsPlugin","pluginDescriptor","setupFn","descriptor","__VUE_DEVTOOLS_GLOBAL_HOOK__","enableProxy","enableEarlyProxy","__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__","proxy","__VUE_DEVTOOLS_PLUGINS__","emit","activePinia","setActivePinia","pinia","piniaSymbol","Symbol","isPlainObject","o","prototype","toString","call","toJSON","MutationType","IS_CLIENT","USE_DEVTOOLS","__VUE_PROD_DEVTOOLS__","_global","self","global","HTMLElement","download","url","name","opts","xhr","XMLHttpRequest","open","responseType","onload","saveAs","response","onerror","console","error","send","corsEnabled","status","click","node","dispatchEvent","MouseEvent","evt","document","createEvent","initMouseEvent","_navigator","userAgent","isMacOSWebView","test","HTMLAnchorElement","blob","a","createElement","rel","href","origin","location","URL","createObjectURL","setTimeout","revokeObjectURL","msSaveOrOpenBlob","autoBom","type","Blob","String","fromCharCode","bom","popup","title","body","innerText","force","isSafari","isChromeIOS","FileReader","reader","onloadend","result","Error","replace","readAsDataURL","toastMessage","message","piniaMessage","__VUE_DEVTOOLS_TOAST__","log","isPinia","checkClipboardAccess","checkNotFocusedError","toLowerCase","fileInput","async","actionGlobalOpenStateFile","accept","reject","onchange","files","file","text","oncancel","loadStoresState","state","key","storeState","formatDisplay","display","_custom","PINIA_ROOT_LABEL","PINIA_ROOT_ID","formatStoreForInspectorTree","store","label","$id","formatEventData","events","Array","isArray","reduce","event","operations","oldValue","newValue","operation","formatMutationType","direct","patchFunction","patchObject","isTimelineActive","componentStateTypes","MUTATIONS_LAYER_ID","INSPECTOR_ID","assign$1","getStoreType","registerPiniaDevtools","app","logo","packageName","homepage","api","addTimelineLayer","color","addInspector","icon","treeFilterPlaceholder","actions","action","clipboard","writeText","actionGlobalCopyState","tooltip","readText","actionGlobalPasteState","sendInspectorTree","sendInspectorState","actionGlobalSaveState","nodeActions","nodeId","_s","$reset","inspectComponent","payload","ctx","componentInstance","_pStores","piniaStores","values","forEach","instanceData","editable","_isOptionsAPI","$state","_getters","length","getters","getInspectorTree","inspectorId","stores","concat","from","rootNodes","filter","map","getInspectorState","inspectedStore","storeNames","storeMap","storeId","getterName","_customProperties","size","customProperties","formatStoreForInspectorState","editInspectorState","path","unshift","has","set","editComponentState","startsWith","activeAction","runningActionId","patchActionForGrouping","actionNames","wrapWithProxy","storeActions","actionName","_actionId","trackedStore","Reflect","retValue","apply","arguments","devtoolsPlugin","options","originalHotUpdate","_hotUpdate","newStore","_hmrPayload","logStoreChanges","bind","$onAction","after","onError","groupId","addTimelineEvent","layerId","time","subtitle","logType","notifyComponentUpdate","deep","$subscribe","eventData","detached","flush","hotUpdate","info","$dispose","addStoreToDevtools","createPinia","scope","run","_p","toBeInstalled","install","provide","config","globalProperties","$pinia","use","_e","Map","noop","addSubscription","subscriptions","callback","onCleanup","removeSubscription","idx","indexOf","splice","triggerSubscriptions","slice","fallbackRunWithContext","fn","mergeReactiveObjects","patchToApply","Set","add","hasOwnProperty","subPatch","targetValue","skipHydrateSymbol","skipHydrateMap","WeakMap","createSetupStore","setup","hot","isOptionsStore","optionsForPlugin","$subscribeOptions","isListening","isSyncListening","debuggerEvents","actionSubscriptions","initialState","hotState","activeListener","$patch","partialStateOrMutator","subscriptionMutation","myListenerId","then","newState","wrapAction","afterCallbackList","onErrorCallbackList","ret","catch","partialStore","stopWatcher","stop","delete","_r","setupStore","runWithContext","effect","obj","actionValue","defineProperty","nonEnumerable","writable","configurable","enumerable","p","extender","extensions","hydrate","defineStore","idOrOptions","setupOptions","isSetupStore","useStore","hasContext","localState","computedGetters","createOptionsStore","mapStoreSuffix","mapStores","reduced","mapState","keysOrMapper","storeKey","PiniaVuePlugin","_Vue","mixin","beforeCreate","$options","_provided","provideCache","v","parent","destroyed"],"sourceRoot":""}