import Docker from 'dockerode';
import waitOn from 'wait-on';
import { PassThrough } from 'stream';
import { basename, resolve, join, sep } from 'path';
import { existsSync, readFileSync } from 'fs';
import { XMLParser } from 'fast-xml-parser';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

/* eslint-disable no-console */
/**
 * SPDX-FileCopyrightText: 2022 Nextcloud GmbH and Nextcloud contributors
 * SPDX-License-Identifier: AGPL-3.0-or-later
 */
const SERVER_IMAGE = 'ghcr.io/nextcloud/continuous-integration-shallow-server';
const VENDOR_APPS = {
    text: 'https://github.com/nextcloud/text.git',
    viewer: 'https://github.com/nextcloud/viewer.git',
    notifications: 'https://github.com/nextcloud/notifications.git',
    activity: 'https://github.com/nextcloud/activity.git',
};
const docker = new Docker();
// Store the container name, different names are used to prevent conflicts when testing multiple apps locally
let _containerName = null;
// Store latest server branch used, will be used for vendored apps
let _serverBranch = 'master';
/**
 * Get the container name that is currently created and/or used by dockerode
 */
const getContainerName = function () {
    if (_containerName === null) {
        const app = basename(process.cwd()).replace(' ', '');
        _containerName = `nextcloud-cypress-tests_${app}`;
    }
    return _containerName;
};
/**
 * Get the current container used
 * Throws if not found
 */
const getContainer = function () {
    return docker.getContainer(getContainerName());
};
/**
 * Start the testing container
 *
 * @param {string|undefined} branch server branch to use (default 'master')
 * @param {boolean|string|undefined} mountApp bind mount app within server (`true` for autodetect, `false` to disable, or a string to force a path) (default true)
 * @param {StartOptions|undefined} options Optional parameters to configure the container creation
 * @return Promise resolving to the IP address of the server
 * @throws {Error} If Nextcloud container could not be started
 */
function startNextcloud() {
    return __awaiter(this, arguments, void 0, function* (branch = 'master', mountApp = true, options = {}) {
        var _a;
        let appPath = mountApp === true ? process.cwd() : mountApp;
        let appId;
        let appVersion;
        if (appPath) {
            console.log('Mounting app directories…');
            while (appPath) {
                const appInfoPath = resolve(join(appPath, 'appinfo', 'info.xml'));
                if (existsSync(appInfoPath)) {
                    const parser = new XMLParser();
                    const xmlDoc = parser.parse(readFileSync(appInfoPath));
                    appId = xmlDoc.info.id;
                    appVersion = xmlDoc.info.version;
                    console.log(`└─ Found ${appId} version ${appVersion}`);
                    break;
                }
                else {
                    // skip if root is reached or manual directory was set
                    if (appPath === sep || typeof mountApp === 'string') {
                        console.log('└─ No appinfo found');
                        appPath = false;
                        break;
                    }
                    appPath = join(appPath, '..');
                }
            }
        }
        try {
            yield pullImage();
            // Getting latest image
            console.log('\nChecking running containers… 🔍');
            const localImage = yield docker.listImages({ filters: `{"reference": ["${SERVER_IMAGE}"]}` });
            // Remove old container if exists and not initialized by us
            try {
                const oldContainer = getContainer();
                const oldContainerData = yield oldContainer.inspect();
                if (oldContainerData.State.Running) {
                    console.log('├─ Existing running container found');
                    if (options.forceRecreate === true) {
                        console.log('└─ Forced recreation of container was enabled, removing…');
                    }
                    else if (localImage[0].Id !== oldContainerData.Image) {
                        console.log('└─ But running container is outdated, replacing…');
                    }
                    else {
                        // Get container's IP
                        console.log('├─ Reusing that container');
                        const ip = yield getContainerIP(oldContainer);
                        return ip;
                    }
                }
                else {
                    console.log('└─ None found!');
                }
                // Forcing any remnants to be removed just in case
                yield oldContainer.remove({ force: true });
            }
            catch (error) {
                console.log('└─ None found!');
            }
            // Starting container
            console.log('\nStarting Nextcloud container… 🚀');
            console.log(`├─ Using branch '${branch}'`);
            const mounts = [];
            if (appPath !== false) {
                mounts.push(`${appPath}:/var/www/html/apps/${appId}:ro`);
            }
            Object.entries((_a = options.mounts) !== null && _a !== void 0 ? _a : {})
                .forEach(([server, local]) => mounts.push(`${local}:/var/www/html/${server}:ro`));
            const PortBindings = !options.exposePort ? undefined : {
                '80/tcp': [{
                        HostIP: '0.0.0.0',
                        HostPort: options.exposePort.toString(),
                    }],
            };
            // On macOS we need to expose the port since the docker container is running within a VM
            const autoExposePort = process.platform === 'darwin';
            const container = yield docker.createContainer({
                Image: SERVER_IMAGE,
                name: getContainerName(),
                Env: [`BRANCH=${branch}`, 'APCU=1'],
                HostConfig: {
                    Binds: mounts.length > 0 ? mounts : undefined,
                    PortBindings,
                    PublishAllPorts: autoExposePort,
                    // Mount data directory in RAM for faster IO
                    Mounts: [{
                            Target: '/var/www/html/data',
                            Source: '',
                            Type: 'tmpfs',
                            ReadOnly: false,
                        }],
                },
            });
            yield container.start();
            // Set proper permissions for the data folder
            yield runExec(['chown', '-R', 'www-data:www-data', '/var/www/html/data'], { container, user: 'root' });
            yield runExec(['chmod', '0770', '/var/www/html/data'], { container, user: 'root' });
            // Get container's IP
            const ip = yield getContainerIP(container);
            console.log(`├─ Nextcloud container's IP is ${ip} 🌏`);
            _serverBranch = branch;
            return ip;
        }
        catch (err) {
            console.log('└─ Unable to start the container 🛑');
            console.log(err);
            stopNextcloud();
            throw new Error('Unable to start the container');
        }
    });
}
const pullImage = function () {
    // Pulling images
    console.log('\nPulling images… ⏳');
    return new Promise((resolve, reject) => docker.pull(SERVER_IMAGE, (_err, stream) => {
        const onFinished = function (err) {
            if (!err) {
                return resolve(true);
            }
            reject(err);
        };
        // https://github.com/apocas/dockerode/issues/357
        if (stream) {
            docker.modem.followProgress(stream, onFinished);
        }
        else {
            reject('Failed to open stream');
        }
    }))
        .then(() => console.log('└─ Done'))
        .catch(err => console.log(`└─ 🛑 FAILED! Trying to continue with existing image. (${err})`));
};
/**
 * Configure Nextcloud
 *
 * @param {string[]} apps List of default apps to install (default is ['viewer'])
 * @param {string|undefined} vendoredBranch The branch used for vendored apps, should match server (defaults to latest branch used for `startNextcloud` or fallsback to `master`)
 * @param {Container|undefined} container Optional server container to use (defaults to current container)
 */
const configureNextcloud = function () {
    return __awaiter(this, arguments, void 0, function* (apps = ['viewer'], vendoredBranch, container) {
        vendoredBranch = vendoredBranch || _serverBranch;
        console.log('\nConfiguring Nextcloud…');
        container = container !== null && container !== void 0 ? container : getContainer();
        yield runOcc('--version', { container, verbose: true });
        // Be consistent for screenshots
        yield setSystemConfig('default_language', 'en', { container });
        yield setSystemConfig('force_language', 'en', { container });
        yield setSystemConfig('default_locale', 'en_US', { container });
        yield setSystemConfig('force_locale', 'en_US', { container });
        yield setSystemConfig('enforce_theme', 'light', { container });
        // Checking apcu
        console.log('├─ Checking APCu configuration... 👀');
        const distributed = yield getSystemConfig('memcache.distributed', { container });
        const local = yield getSystemConfig('memcache.local', { container });
        const hashing = yield getSystemConfig('hashing_default_password', { container });
        if (!distributed.includes('Memcache\\APCu')
            || !local.includes('Memcache\\APCu')
            || !hashing.includes('true')) {
            console.log('└─ APCu is not properly configured 🛑');
            throw new Error('APCu is not properly configured');
        }
        console.log('│  └─ OK !');
        // Build app list
        const json = yield runOcc(['app:list', '--output', 'json'], { container });
        // fix dockerode bug returning invalid leading characters
        const applist = JSON.parse(json.substring(json.indexOf('{')));
        // Enable apps and give status
        for (const app of apps) {
            if (app in applist.enabled) {
                console.log(`├─ ${app} version ${applist.enabled[app]} already installed and enabled`);
            }
            else if (app in applist.disabled) {
                // built in or mounted already as the app under development
                yield runOcc(['app:enable', '--force', app], { container, verbose: true });
            }
            else if (app in VENDOR_APPS) {
                // apps that are vendored but still missing (i.e. not build in or mounted already)
                yield runExec(['git', 'clone', '--depth=1', `--branch=${vendoredBranch}`, VENDOR_APPS[app], `apps/${app}`], { container, verbose: true });
                yield runOcc(['app:enable', '--force', app], { container, verbose: true });
            }
            else {
                // try appstore
                yield runOcc(['app:install', '--force', app], { container, verbose: true });
            }
        }
        console.log('└─ Nextcloud is now ready to use 🎉');
    });
};
/**
 * Setup test users
 *
 * @param {Container|undefined} container Optional server container to use (defaults to current container)
 */
const setupUsers = function (container) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('\nCreating test users… 👤');
        const users = ['test1', 'test2', 'test3', 'test4', 'test5'];
        for (const user of users) {
            yield addUser(user, { container, verbose: true });
        }
        console.log('└─ Done');
    });
};
/**
 * Create a snapshot of the current database
 * @param {string|undefined} snapshot Name of the snapshot (default is a timestamp)
 * @param {Container|undefined} container Optional server container to use (defaults to current container)
 * @return Promise resolving to the snapshot name
 */
const createSnapshot = function (snapshot, container) {
    return __awaiter(this, void 0, void 0, function* () {
        const hash = new Date().toISOString().replace(/[^0-9]/g, '');
        console.log('\nCreating init DB snapshot…');
        yield runExec(['cp', '/var/www/html/data/owncloud.db', `/var/www/html/data/owncloud.db-${snapshot !== null && snapshot !== void 0 ? snapshot : hash}`], { container, verbose: true });
        console.log('└─ Done');
        return snapshot !== null && snapshot !== void 0 ? snapshot : hash;
    });
};
/**
 * Restore a snapshot of the database
 * @param {string|undefined} snapshot Name of the snapshot (default is 'init')
 * @param {Container|undefined} container Optional server container to use (defaults to current container)
 */
const restoreSnapshot = function () {
    return __awaiter(this, arguments, void 0, function* (snapshot = 'init', container) {
        console.log('\nRestoring DB snapshot…');
        yield runExec(['cp', `/var/www/html/data/owncloud.db-${snapshot}`, '/var/www/html/data/owncloud.db'], { container, verbose: true });
        console.log('└─ Done');
    });
};
/**
 * Force stop the testing container
 */
const stopNextcloud = function () {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const container = getContainer();
            console.log('Stopping Nextcloud container…');
            container.remove({ force: true });
            console.log('└─ Nextcloud container removed 🥀');
        }
        catch (err) {
            console.log(err);
        }
    });
};
/**
 * Get the testing container's IP
 *
 * @param container name of the container
 */
const getContainerIP = function () {
    return __awaiter(this, arguments, void 0, function* (container = getContainer()) {
        var _a, _b;
        const containerInspect = yield container.inspect();
        const hostPort = (_b = (_a = containerInspect.NetworkSettings.Ports['80/tcp']) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.HostPort;
        if (hostPort) {
            return `localhost:${hostPort}`;
        }
        let ip = '';
        let tries = 0;
        while (ip === '' && tries < 10) {
            tries++;
            yield container.inspect((_err, data) => {
                var _a;
                ip = ((_a = data === null || data === void 0 ? void 0 : data.NetworkSettings) === null || _a === void 0 ? void 0 : _a.IPAddress) || '';
            });
            if (ip !== '') {
                break;
            }
            yield sleep(1000 * tries);
        }
        return ip;
    });
};
// Would be simpler to start the container from cypress.config.ts,
// but when checking out different branches, it can take a few seconds
// Until we can properly configure the baseUrl retry intervals,
// We need to make sure the server is already running before cypress
// https://github.com/cypress-io/cypress/issues/22676
const waitOnNextcloud = function (ip) {
    return __awaiter(this, void 0, void 0, function* () {
        console.log('├─ Waiting for Nextcloud to be ready… ⏳');
        yield waitOn({ resources: [`http://${ip}/index.php`] });
        console.log('└─ Done');
    });
};
/**
 * Execute a command in the container
 */
const runExec = function (command_1) {
    return __awaiter(this, arguments, void 0, function* (command, { container, user = 'www-data', verbose = false, env = [] } = {}) {
        container = container || getContainer();
        const exec = yield container.exec({
            Cmd: typeof command === 'string' ? [command] : command,
            AttachStdout: true,
            AttachStderr: true,
            User: user,
            Env: env,
        });
        return new Promise((resolve, reject) => {
            const dataStream = new PassThrough();
            exec.start({}, (err, stream) => {
                if (stream) {
                    // Pass stdout and stderr to dataStream
                    exec.modem.demuxStream(stream, dataStream, dataStream);
                    stream.on('end', () => dataStream.end());
                }
                else {
                    reject(err);
                }
            });
            const data = [];
            dataStream.on('data', (chunk) => {
                var _a;
                data.push(chunk.toString('utf8'));
                const printable = (_a = data.at(-1)) === null || _a === void 0 ? void 0 : _a.trim();
                if (verbose && printable) {
                    console.log(`├─ ${printable.replace(/\n/gi, '\n├─ ')}`);
                }
            });
            dataStream.on('error', (err) => reject(err));
            dataStream.on('end', () => resolve(data.join('')));
        });
    });
};
/**
 * Execute an occ command in the container
 */
const runOcc = function (command, { container, env = [], verbose = false } = {}) {
    const cmdArray = typeof command === 'string' ? [command] : command;
    return runExec(['php', 'occ', ...cmdArray], { container, verbose, env });
};
/**
 * Set a Nextcloud system config in the container.
 */
const setSystemConfig = function (key, value, { container } = {}) {
    return runOcc(['config:system:set', key, '--value', value], { container, verbose: true });
};
/**
 * Get a Nextcloud system config value from the container.
 */
const getSystemConfig = function (key, { container } = {}) {
    return runOcc(['config:system:get', key], { container });
};
/**
 * Add a user to the Nextcloud in the container.
 */
const addUser = function (user, { container, env = [], verbose = false } = {}) {
    return runOcc(['user:add', user, '--password-from-env'], { container, verbose, env: ['OC_PASS=' + user, ...env] });
};
const sleep = function (milliseconds) {
    return new Promise((resolve) => setTimeout(resolve, milliseconds));
};

export { addUser, configureNextcloud, createSnapshot, docker, getContainer, getContainerIP, getContainerName, getSystemConfig, restoreSnapshot, runExec, runOcc, setSystemConfig, setupUsers, startNextcloud, stopNextcloud, waitOnNextcloud };
